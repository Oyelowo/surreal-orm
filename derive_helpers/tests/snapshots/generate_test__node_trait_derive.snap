---
source: derive_helpers/tests/generate_test.rs
expression: "format!(\"{:#}\", node_token.to_token_stream())"
---
use surreal_orm :: ToRaw as _ ; use surreal_orm :: Aliasable as _ ; use :: std :: str :: FromStr as _ ; impl surreal_orm :: SchemaGetter for Student { type Schema = student :: Schema ; fn schema () -> student :: Schema { student :: Schema :: new () } fn schema_prefixed (prefix : impl :: std :: convert :: Into < surreal_orm :: ValueLike >) -> student :: Schema { student :: Schema :: new_prefixed (prefix) } } impl surreal_orm :: PartialUpdater for Student { type StructPartial = StudentPartial ; type PartialBuilder = StudentPartialBuilder ; fn partial_builder () -> Self :: PartialBuilder { StudentPartialBuilder :: new () } } impl surreal_orm :: Node for Student { type TableNameChecker = ________internal_student_schema :: TableNameStaticChecker ; type Aliases = ________internal_student_schema :: StudentAliases ; fn with (clause : impl :: std :: convert :: Into < surreal_orm :: NodeClause >) -> < Self as surreal_orm :: SchemaGetter > :: Schema { let clause : surreal_orm :: NodeClause = clause . into () ; ________internal_student_schema :: Student :: __________connect_node_to_graph_traversal_string (________internal_student_schema :: Student :: empty () , clause . with_table ("student") ,) } fn aliases () -> Self :: Aliases { ________internal_student_schema :: StudentAliases :: new () } fn get_table () -> surreal_orm :: Table { "student" . into () } fn get_fields_relations_aliased () -> :: std :: vec :: Vec < surreal_orm :: Alias > { vec ! [surreal_orm :: Field :: new ("->writes->Blog") . __as__ (surreal_orm :: AliasName :: new ("written_blogs"))] } } # [allow (non_snake_case)] # [derive (surreal_orm :: serde :: Serialize , Debug , Clone , Default)] pub struct StudentPartial { # [serde (skip)] _____struct_marker_ident : surreal_orm :: Maybe < :: std :: marker :: PhantomData < () > > , # [serde (skip_serializing_if = "surreal_orm::Maybe::is_none" , rename = "id")] pub id : surreal_orm :: Maybe < SurrealSimpleId < Student > > , # [serde (skip_serializing_if = "surreal_orm::Maybe::is_none" , rename = "first_name")] pub first_name : surreal_orm :: Maybe < String > , # [serde (skip_serializing_if = "surreal_orm::Maybe::is_none" , rename = "course")] pub course : surreal_orm :: Maybe < LinkOne < Book > > , # [serde (skip_serializing_if = "surreal_orm::Maybe::is_none" , rename = "lowo")] pub all_semester_courses : surreal_orm :: Maybe < LinkMany < Book > > } # [derive (surreal_orm :: serde :: Serialize , Debug , Clone , Default)] pub struct StudentPartialBuilder (StudentPartial) ; impl StudentPartialBuilder { pub fn new () -> Self { Self (StudentPartial { _____struct_marker_ident : surreal_orm :: Maybe :: None , id : surreal_orm :: Maybe :: None , first_name : surreal_orm :: Maybe :: None , course : surreal_orm :: Maybe :: None , all_semester_courses : surreal_orm :: Maybe :: None }) } pub fn id (mut self , value : SurrealSimpleId < Student >) -> Self { self . 0. id = surreal_orm :: Maybe :: Some (value) ; self } pub fn first_name (mut self , value : String) -> Self { self . 0. first_name = surreal_orm :: Maybe :: Some (value) ; self } pub fn course (mut self , value : LinkOne < Book >) -> Self { self . 0. course = surreal_orm :: Maybe :: Some (value) ; self } pub fn all_semester_courses (mut self , value : LinkMany < Book >) -> Self { self . 0. all_semester_courses = surreal_orm :: Maybe :: Some (value) ; self } pub fn build (self) -> StudentPartial { self . 0 } } # [allow (non_snake_case)] # [derive (surreal_orm :: serde :: Serialize , surreal_orm :: serde :: Deserialize , Debug , Clone)] pub struct StudentRenamedCreator { pub id : & 'static str , pub first_name : & 'static str , pub course : & 'static str , pub lowo : & 'static str } impl Student { pub const fn __get_serializable_field_names () -> [& 'static str ; 4usize] { [stringify ! ("id" . into ()) , stringify ! ("first_name" . into ()) , stringify ! ("course" . into ()) , stringify ! ("lowo" . into ())] } } impl surreal_orm :: Model for Student { type Id = SurrealSimpleId < Self > ; type StructRenamedCreator = StudentRenamedCreator ; fn table () -> surreal_orm :: Table { "student" . into () } fn get_id (self) -> Self :: Id { self . id } fn get_id_as_thing (& self) -> surreal_orm :: sql :: Thing { surreal_orm :: sql :: thing (self . id . to_raw () . as_str ()) . unwrap () } fn get_serializable_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! ["id" . into () , "first_name" . into () , "course" . into () , "lowo" . into ()] } fn get_linked_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [surreal_orm :: Field :: new ("course") , surreal_orm :: Field :: new ("lowo")] } fn get_link_one_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [surreal_orm :: Field :: new ("course")] } fn get_link_self_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [] } fn get_link_one_and_self_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [surreal_orm :: Field :: new ("course")] } fn get_link_many_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [surreal_orm :: Field :: new ("lowo")] } fn get_field_meta () -> :: std :: vec :: Vec < surreal_orm :: FieldMetadata > { return :: std :: vec ! [surreal_orm :: FieldMetadata { name : "id" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("id")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Self :: table ()])) . to_raw ()] } , surreal_orm :: FieldMetadata { name : "first_name" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("first_name")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: String) . to_raw ()] } , surreal_orm :: FieldMetadata { name : "course" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("course")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Book :: table ()])) . to_raw ()] } , surreal_orm :: FieldMetadata { name : "lowo" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("lowo")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Array (:: std :: boxed :: Box :: new (surreal_orm :: FieldType :: Record (:: std :: vec ! [Book :: table ()])) , :: std :: option :: Option :: None)) . to_raw ()] }] } fn define_table () -> surreal_orm :: Raw { surreal_orm :: statements :: define_table (Self :: table ()) . drop () . schemafull () . permissions (perm () . to_raw ()) . to_raw () } fn define_fields () -> :: std :: vec :: Vec < surreal_orm :: Raw > { :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("id")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Self :: table ()])) . to_raw () , surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("first_name")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: String) . to_raw () , surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("course")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Book :: table ()])) . to_raw () , surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("lowo")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Array (:: std :: boxed :: Box :: new (surreal_orm :: FieldType :: Record (:: std :: vec ! [Book :: table ()])) , :: std :: option :: Option :: None)) . to_raw ()] } } # [allow (non_snake_case)] pub mod student { pub use super :: ________internal_student_schema :: _____schema_def :: __Schema__ as Schema ; } # [allow (non_snake_case)] mod ________internal_student_schema { use surreal_orm :: Parametric as _ ; use surreal_orm :: Buildable as _ ; use surreal_orm :: Erroneous as _ ; use super :: * ; pub struct TableNameStaticChecker { pub student : :: std :: string :: String , } type Book = < super :: Book as surreal_orm :: SchemaGetter > :: Schema ; pub (super) mod _____field_names { use super :: super :: * ; use surreal_orm :: Parametric as _ ; use surreal_orm :: Buildable as _ ; # [derive (Debug , Clone)] pub struct __Id__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __Id__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __Id__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __Id__ > for surreal_orm :: ValueLike { fn from (value : & __Id__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __Id__ > for surreal_orm :: ValueLike { fn from (value : __Id__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __Id__ > for surreal_orm :: Field { fn from (field_name : & __Id__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __Id__ > for surreal_orm :: Field { fn from (field_name : __Id__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __Id__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __Id__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __Id__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __Id__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __Id__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __Id__) -> Self { Self :: Field (value . into ()) } } impl surreal_orm :: SetterAssignable < SurrealSimpleId < Student > > for self :: __Id__ { } # [derive (Debug , Clone)] pub struct __FirstName__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __FirstName__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __FirstName__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __FirstName__ > for surreal_orm :: ValueLike { fn from (value : & __FirstName__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __FirstName__ > for surreal_orm :: ValueLike { fn from (value : __FirstName__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __FirstName__ > for surreal_orm :: Field { fn from (field_name : & __FirstName__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __FirstName__ > for surreal_orm :: Field { fn from (field_name : __FirstName__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __FirstName__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __FirstName__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __FirstName__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __FirstName__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __FirstName__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __FirstName__) -> Self { Self :: Field (value . into ()) } } impl surreal_orm :: SetterAssignable < String > for self :: __FirstName__ { } impl surreal_orm :: Patchable < String > for self :: __FirstName__ { } # [derive (Debug , Clone)] pub struct __Course__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __Course__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __Course__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __Course__ > for surreal_orm :: ValueLike { fn from (value : & __Course__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __Course__ > for surreal_orm :: ValueLike { fn from (value : __Course__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __Course__ > for surreal_orm :: Field { fn from (field_name : & __Course__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __Course__ > for surreal_orm :: Field { fn from (field_name : __Course__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __Course__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __Course__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __Course__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __Course__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __Course__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __Course__) -> Self { Self :: Field (value . into ()) } } impl surreal_orm :: SetterAssignable < LinkOne < Book > > for self :: __Course__ { } impl surreal_orm :: Patchable < LinkOne < Book > > for self :: __Course__ { } # [derive (Debug , Clone)] pub struct __Lowo__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __Lowo__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __Lowo__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __Lowo__ > for surreal_orm :: ValueLike { fn from (value : & __Lowo__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __Lowo__ > for surreal_orm :: ValueLike { fn from (value : __Lowo__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __Lowo__ > for surreal_orm :: Field { fn from (field_name : & __Lowo__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __Lowo__ > for surreal_orm :: Field { fn from (field_name : __Lowo__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __Lowo__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __Lowo__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __Lowo__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __Lowo__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __Lowo__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __Lowo__) -> Self { Self :: Field (value . into ()) } } impl surreal_orm :: SetterAssignable < LinkMany < Book > > for self :: __Lowo__ { } impl surreal_orm :: Patchable < LinkMany < Book > > for self :: __Lowo__ { } impl surreal_orm :: SetterArray < < Book as surreal_orm :: Model > :: Id > for self :: __Lowo__ { } } pub mod _____schema_def { use super :: _____field_names ; use super :: super :: * ; # [allow (non_snake_case)] # [derive (Debug , Clone)] pub struct __Schema__ { pub id : _____field_names :: __Id__ , pub first_name : _____field_names :: __FirstName__ , pub course : _____field_names :: __Course__ , pub lowo : _____field_names :: __Lowo__ , pub (super) ___________graph_traversal_string : :: std :: string :: String , pub (super) ___________bindings : surreal_orm :: BindingsList , pub (super) ___________errors : :: std :: vec :: Vec < :: std :: string :: String > , pub (super) _____struct_marker_ident : :: std :: marker :: PhantomData < () > } } pub type Student = _____schema_def :: __Schema__ ; # [derive (Debug , Clone)] pub struct StudentAliases { pub written_blogs : surreal_orm :: AliasName , } impl StudentAliases { pub fn new () -> Self { Self { written_blogs : "written_blogs" . into () , } } } impl surreal_orm :: Aliasable for Student { } impl From < Student > for surreal_orm :: ValueLike { fn from (node : Student) -> Self { Self :: new (node) } } impl surreal_orm :: Parametric for Student { fn get_bindings (& self) -> surreal_orm :: BindingsList { self . ___________bindings . to_vec () } } impl surreal_orm :: Buildable for Student { fn build (& self) -> :: std :: string :: String { self . ___________graph_traversal_string . to_string () } } impl surreal_orm :: Erroneous for Student { fn get_errors (& self) -> :: std :: vec :: Vec < :: std :: string :: String > { self . ___________errors . to_vec () } } impl :: std :: fmt :: Display for Student { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (format_args ! ("{}" , self . ___________graph_traversal_string)) } } impl surreal_orm :: Aliasable for & Student { } impl surreal_orm :: Parametric for & Student { fn get_bindings (& self) -> surreal_orm :: BindingsList { self . ___________bindings . to_vec () } } impl surreal_orm :: Buildable for & Student { fn build (& self) -> :: std :: string :: String { self . ___________graph_traversal_string . to_string () } } impl surreal_orm :: Erroneous for & Student { fn get_errors (& self) -> :: std :: vec :: Vec < :: std :: string :: String > { self . ___________errors . to_vec () } } impl Student { pub fn new () -> Self { Self { id : "id" . into () , first_name : "first_name" . into () , course : "course" . into () , lowo : "lowo" . into () , ___________graph_traversal_string : "" . into () , ___________bindings : :: std :: vec ! [] , ___________errors : :: std :: vec ! [] , _____struct_marker_ident : :: std :: marker :: PhantomData , } } pub fn new_prefixed (prefix : impl :: std :: convert :: Into < surreal_orm :: ValueLike >) -> Self { let prefix : surreal_orm :: ValueLike = prefix . into () ; Self { id : surreal_orm :: Field :: new (format ! ("{}.{}" , prefix . build () , "id")) . with_bindings (prefix . get_bindings ()) . into () , first_name : surreal_orm :: Field :: new (format ! ("{}.{}" , prefix . build () , "first_name")) . with_bindings (prefix . get_bindings ()) . into () , course : surreal_orm :: Field :: new (format ! ("{}.{}" , prefix . build () , "course")) . with_bindings (prefix . get_bindings ()) . into () , lowo : surreal_orm :: Field :: new (format ! ("{}.{}" , prefix . build () , "lowo")) . with_bindings (prefix . get_bindings ()) . into () , ___________graph_traversal_string : prefix . build () , ___________bindings : prefix . get_bindings () , ___________errors : :: std :: vec ! [] , _____struct_marker_ident : :: std :: marker :: PhantomData , } } pub fn empty () -> Self { Self { id : "" . into () , first_name : "" . into () , course : "" . into () , lowo : "" . into () , ___________graph_traversal_string : "" . into () , ___________bindings : :: std :: vec ! [] , ___________errors : :: std :: vec ! [] , _____struct_marker_ident : :: std :: marker :: PhantomData , } } pub fn __________connect_node_to_graph_traversal_string (connection : impl surreal_orm :: Buildable + surreal_orm :: Parametric + surreal_orm :: Erroneous , clause : impl :: std :: convert :: Into < surreal_orm :: NodeClause > ,) -> Self { let mut schema_instance = Self :: new () ; let clause : surreal_orm :: NodeClause = clause . into () ; let bindings = [connection . get_bindings () . as_slice () , clause . get_bindings () . as_slice ()] . concat () ; let bindings = bindings . as_slice () ; schema_instance . ___________bindings = bindings . into () ; let errors = [connection . get_errors () . as_slice () , clause . get_errors () . as_slice ()] . concat () ; let errors = errors . as_slice () ; schema_instance . ___________errors = errors . into () ; let connection_str = format ! ("{}{}" , connection . build () , clause . build ()) ; schema_instance . ___________graph_traversal_string . push_str (connection_str . as_str ()) ; let ___________graph_traversal_string = & schema_instance . ___________graph_traversal_string ; schema_instance . id = schema_instance . id . set_graph_string (format ! ("{}.{}" , ___________graph_traversal_string , "id")) . ____________update_many_bindings (bindings) . into () ; schema_instance . first_name = schema_instance . first_name . set_graph_string (format ! ("{}.{}" , ___________graph_traversal_string , "first_name")) . ____________update_many_bindings (bindings) . into () ; schema_instance . course = schema_instance . course . set_graph_string (format ! ("{}.{}" , ___________graph_traversal_string , "course")) . ____________update_many_bindings (bindings) . into () ; schema_instance . lowo = schema_instance . lowo . set_graph_string (format ! ("{}.{}" , ___________graph_traversal_string , "lowo")) . ____________update_many_bindings (bindings) . into () ; schema_instance } pub fn course (& self) -> Book { let clause = surreal_orm :: Clause :: from (surreal_orm :: Empty) ; let normalized_field_name_str = if self . build () . is_empty () { "course" } else { ".course" } ; Book :: __________connect_node_to_graph_traversal_string (self , clause . with_field (normalized_field_name_str)) } pub fn lowo (& self , clause : impl :: std :: convert :: Into < surreal_orm :: NodeAliasClause >) -> Book { let clause : surreal_orm :: NodeAliasClause = clause . into () ; let clause : surreal_orm :: NodeClause = clause . into_inner () ; let db_field_name = if self . build () . is_empty () { "lowo" . to_string () } else { format ! (".{}" , "lowo") } ; Book :: __________connect_node_to_graph_traversal_string (self , clause . with_field (db_field_name)) } } use super :: StudentWritesBlog ; impl Student { pub fn writes__ (& self , clause : impl :: std :: convert :: Into < surreal_orm :: EdgeClause > ,) -> writes___schema________________ :: writes__ { let clause : surreal_orm :: EdgeClause = clause . into () ; let clause = clause . with_arrow (surreal_orm :: Arrow :: Right) . with_table ("writes") ; writes___schema________________ :: Writes :: __________connect_edge_to_graph_traversal_string (self , clause ,) . into () } } mod writes___schema________________ { use super :: StudentWritesBlog ; use surreal_orm :: Parametric as _ ; use surreal_orm :: Buildable as _ ; use surreal_orm :: Erroneous as _ ; type Blog = << super :: super :: StudentWritesBlog as surreal_orm :: Edge > :: Out as surreal_orm :: SchemaGetter > :: Schema ; pub type Writes = < super :: super :: StudentWritesBlog as surreal_orm :: SchemaGetter > :: Schema ; pub struct writes__ (Writes) ; impl :: std :: convert :: From < Writes > for writes__ { fn from (value : Writes) -> Self { Self (value) } } impl surreal_orm :: Buildable for writes__ { fn build (& self) -> :: std :: string :: String { self . 0 . build () } } impl surreal_orm :: Parametric for writes__ { fn get_bindings (& self) -> surreal_orm :: BindingsList { self . 0 . get_bindings () } } impl surreal_orm :: Erroneous for writes__ { fn get_errors (& self) -> Vec < :: std :: string :: String > { self . 0 . get_errors () } } impl surreal_orm :: Buildable for & writes__ { fn build (& self) -> :: std :: string :: String { self . 0 . build () } } impl surreal_orm :: Parametric for & writes__ { fn get_bindings (& self) -> surreal_orm :: BindingsList { self . 0 . get_bindings () } } impl surreal_orm :: Erroneous for & writes__ { fn get_errors (& self) -> :: std :: vec :: Vec < :: std :: string :: String > { self . 0 . get_errors () } } impl :: std :: ops :: Deref for writes__ { type Target = Writes ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl writes__ { pub fn Blog (self , clause : impl :: std :: convert :: Into < surreal_orm :: NodeClause >) -> Blog { let clause : surreal_orm :: NodeClause = clause . into () ; let clause = clause . with_arrow (surreal_orm :: Arrow :: Right) . with_table ("Blog") ; Blog :: __________connect_node_to_graph_traversal_string (self , clause ,) } pub fn writes__ (& self , clause : impl :: std :: convert :: Into < surreal_orm :: EdgeClause > ,) -> writes__ { let clause : surreal_orm :: EdgeClause = clause . into () ; let clause = clause . with_arrow (surreal_orm :: Arrow :: Right) . with_table ("writes") ; Writes :: __________connect_edge_to_graph_traversal_string (self , clause ,) . into () } } } } # [allow (non_snake_case)] # [allow (unreachable_code)] fn _________test_________internal_student_schema_static_funcs_name__________ () { surreal_orm :: validators :: assert_type_is_thing :: < SurrealSimpleId < Student > > () ; surreal_orm :: validators :: assert_type_is_string :: < String > () ; surreal_orm :: validators :: assert_type_eq_all ! (LinkOne < Book > , surreal_orm :: LinkOne < Book >) ; surreal_orm :: validators :: assert_impl_one ! (Book : surreal_orm :: Node) ; surreal_orm :: validators :: assert_type_eq_all ! (LinkMany < Book > , surreal_orm :: LinkMany < Book >) ; surreal_orm :: validators :: assert_impl_one ! (Book : surreal_orm :: Node) ; { surreal_orm :: validators :: assert_type_eq_all ! (< StudentWritesBlog as surreal_orm :: Edge > :: In , Student) ; surreal_orm :: validators :: assert_impl_one ! (< StudentWritesBlog as surreal_orm :: Edge > :: In : surreal_orm :: Node) ; } surreal_orm :: validators :: assert_fields ! (< < StudentWritesBlog as surreal_orm :: Edge > :: Out as surreal_orm :: Node > :: TableNameChecker : Blog) ; surreal_orm :: validators :: assert_impl_one ! (< StudentWritesBlog as surreal_orm :: Edge > :: Out : surreal_orm :: Node) ; surreal_orm :: validators :: assert_fields ! (< StudentWritesBlog as surreal_orm :: Edge > :: TableNameChecker : writes) ; surreal_orm :: validators :: assert_impl_one ! (StudentWritesBlog : surreal_orm :: Edge) ; surreal_orm :: validators :: assert_type_eq_all ! (Relate < Blog > , surreal_orm :: Relate < < StudentWritesBlog as surreal_orm :: Edge > :: Out >) ; }

---
source: derive_helpers/tests/generate_test.rs
expression: "format!(\"{:#}\", node_token.to_token_stream())"
---
"use surreal_orm :: ToRaw as _ ; use surreal_orm :: Aliasable as _ ; use :: std :: str :: FromStr as _ ; impl surreal_orm :: SchemaGetter for Student { type Schema = student :: Schema ; fn schema () -> student :: Schema { student :: Schema :: new () } fn schema_prefixed (prefix : impl :: std :: convert :: Into < surreal_orm :: ValueLike >) -> student :: Schema { student :: Schema :: new_prefixed (prefix) } } impl surreal_orm :: PartialUpdater for Student { type StructPartial = StudentPartial ; type PartialBuilder = StudentPartialBuilder ; fn partial_builder () -> Self :: PartialBuilder { StudentPartialBuilder :: new () } } impl surreal_orm :: Node for Student { type TableNameChecker = ________internal_student_schema :: TableNameStaticChecker ; type Aliases = ________internal_student_schema :: StudentAliases ; fn with (clause : impl :: std :: convert :: Into < surreal_orm :: NodeClause >) -> < Self as surreal_orm :: SchemaGetter > :: Schema { let clause : surreal_orm :: NodeClause = clause . into () ; ________internal_student_schema :: Student :: __________connect_node_to_graph_traversal_string (________internal_student_schema :: Student :: empty () , clause . with_table (\"student\") ,) } fn aliases () -> Self :: Aliases { ________internal_student_schema :: StudentAliases :: new () } fn get_table () -> surreal_orm :: Table { \"student\" . into () } fn get_fields_relations_aliased () -> :: std :: vec :: Vec < surreal_orm :: Alias > { vec ! [surreal_orm :: Field :: new (\"->writes->Blog\") . __as__ (surreal_orm :: AliasName :: new (\"written_blogs\"))] } } # [allow (non_snake_case)] # [derive (surreal_orm :: serde :: Serialize , Debug , Clone , Default)] pub struct StudentPartial { # [serde (skip)] _____struct_marker_ident : surreal_orm :: Maybe < :: std :: marker :: PhantomData < () > > , # [serde (skip_serializing_if = \"surreal_orm::Maybe::is_none\" , rename = \"id\")] pub id : surreal_orm :: Maybe < SurrealSimpleId < Student > > , # [serde (skip_serializing_if = \"surreal_orm::Maybe::is_none\" , rename = \"first_name\")] pub first_name : surreal_orm :: Maybe < String > , # [serde (skip_serializing_if = \"surreal_orm::Maybe::is_none\" , rename = \"course\")] pub course : surreal_orm :: Maybe < LinkOne < Book > > , # [serde (skip_serializing_if = \"surreal_orm::Maybe::is_none\" , rename = \"lowo\")] pub all_semester_courses : surreal_orm :: Maybe < LinkMany < Book > > } # [derive (surreal_orm :: serde :: Serialize , Debug , Clone , Default)] pub struct StudentPartialBuilder (StudentPartial) ; impl StudentPartialBuilder { pub fn new () -> Self { Self (StudentPartial { _____struct_marker_ident : surreal_orm :: Maybe :: None , id : surreal_orm :: Maybe :: None , first_name : surreal_orm :: Maybe :: None , course : surreal_orm :: Maybe :: None , all_semester_courses : surreal_orm :: Maybe :: None }) } pub fn id (mut self , value : SurrealSimpleId < Student >) -> Self { self . 0. id = surreal_orm :: Maybe :: Some (value) ; self } pub fn first_name (mut self , value : String) -> Self { self . 0. first_name = surreal_orm :: Maybe :: Some (value) ; self } pub fn course (mut self , value : LinkOne < Book >) -> Self { self . 0. course = surreal_orm :: Maybe :: Some (value) ; self } pub fn all_semester_courses (mut self , value : LinkMany < Book >) -> Self { self . 0. all_semester_courses = surreal_orm :: Maybe :: Some (value) ; self } pub fn build (self) -> StudentPartial { self . 0 } } # [allow (non_snake_case)] # [derive (surreal_orm :: serde :: Serialize , surreal_orm :: serde :: Deserialize , Debug , Clone)] pub struct StudentRenamedCreator { pub id : & 'static str , pub first_name : & 'static str , pub course : & 'static str , pub lowo : & 'static str } impl Student { pub const fn __get_serializable_field_names () -> [& 'static str ; 4usize] { [stringify ! (\"id\" . into ()) , stringify ! (\"first_name\" . into ()) , stringify ! (\"course\" . into ()) , stringify ! (\"lowo\" . into ())] } } impl surreal_orm :: Model for Student { type Id = SurrealSimpleId < Self > ; type StructRenamedCreator = StudentRenamedCreator ; fn table () -> surreal_orm :: Table { \"student\" . into () } fn get_id (self) -> Self :: Id { self . id } fn get_id_as_thing (& self) -> surreal_orm :: sql :: Thing { surreal_orm :: sql :: thing (self . id . to_raw () . as_str ()) . unwrap () } fn get_serializable_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [\"id\" . into () , \"first_name\" . into () , \"course\" . into () , \"lowo\" . into ()] } fn get_linked_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [surreal_orm :: Field :: new (\"course\") , surreal_orm :: Field :: new (\"lowo\")] } fn get_link_one_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [surreal_orm :: Field :: new (\"course\")] } fn get_link_self_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [] } fn get_link_one_and_self_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [surreal_orm :: Field :: new (\"course\")] } fn get_link_many_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [surreal_orm :: Field :: new (\"lowo\")] } fn get_field_meta () -> :: std :: vec :: Vec < surreal_orm :: FieldMetadata > { return :: std :: vec ! [surreal_orm :: FieldMetadata { name : \"id\" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"id\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Self :: table ()])) . to_raw ()] } , surreal_orm :: FieldMetadata { name : \"first_name\" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"first_name\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: String) . to_raw ()] } , surreal_orm :: FieldMetadata { name : \"course\" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"course\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Book :: table ()])) . to_raw ()] } , surreal_orm :: FieldMetadata { name : \"lowo\" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"lowo\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Array (:: std :: boxed :: Box :: new (surreal_orm :: FieldType :: Record (:: std :: vec ! [Book :: table ()])) , :: std :: option :: Option :: None)) . to_raw ()] }] } fn define_table () -> surreal_orm :: Raw { surreal_orm :: statements :: define_table (Self :: table ()) . drop () . schemafull () . permissions (perm () . to_raw ()) . to_raw () } fn define_fields () -> :: std :: vec :: Vec < surreal_orm :: Raw > { :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"id\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Self :: table ()])) . to_raw () , surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"first_name\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: String) . to_raw () , surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"course\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Book :: table ()])) . to_raw () , surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"lowo\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Array (:: std :: boxed :: Box :: new (surreal_orm :: FieldType :: Record (:: std :: vec ! [Book :: table ()])) , :: std :: option :: Option :: None)) . to_raw ()] } } # [allow (non_snake_case)] pub mod student { pub use super :: ________internal_student_schema :: _____schema_def :: __Schema__ as Schema ; } # [allow (non_snake_case)] mod ________internal_student_schema { use surreal_orm :: Parametric as _ ; use surreal_orm :: Buildable as _ ; use surreal_orm :: Erroneous as _ ; use super :: * ; pub struct TableNameStaticChecker { pub student : :: std :: string :: String , } type Book = < super :: Book as surreal_orm :: SchemaGetter > :: Schema ; pub (super) mod _____field_names { use super :: super :: * ; use surreal_orm :: Parametric as _ ; use surreal_orm :: Buildable as _ ; # [derive (Debug , Clone)] pub struct __Id__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __Id__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __Id__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __Id__ > for surreal_orm :: ValueLike { fn from (value : & __Id__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __Id__ > for surreal_orm :: ValueLike { fn from (value : __Id__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __Id__ > for surreal_orm :: Field { fn from (field_name : & __Id__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __Id__ > for surreal_orm :: Field { fn from (field_name : __Id__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __Id__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __Id__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __Id__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __Id__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __Id__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __Id__) -> Self { Self :: Field (value . into ()) } } impl surreal_orm :: SetterAssignable < SurrealSimpleId < Student > > for self :: __Id__ { } # [derive (Debug , Clone)] pub struct __FirstName__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __FirstName__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __FirstName__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __FirstName__ > for surreal_orm :: ValueLike { fn from (value : & __FirstName__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __FirstName__ > for surreal_orm :: ValueLike { fn from (value : __FirstName__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __FirstName__ > for surreal_orm :: Field { fn from (field_name : & __FirstName__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __FirstName__ > for surreal_orm :: Field { fn from (field_name : __FirstName__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __FirstName__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __FirstName__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __FirstName__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __FirstName__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __FirstName__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __FirstName__) -> Self { Self :: Field (value . into ()) } } impl surreal_orm :: SetterAssignable < String > for self :: __FirstName__ { } impl surreal_orm :: Patchable < String > for self :: __FirstName__ { } # [derive (Debug , Clone)] pub struct __Course__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __Course__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __Course__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __Course__ > for surreal_orm :: ValueLike { fn from (value : & __Course__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __Course__ > for surreal_orm :: ValueLike { fn from (value : __Course__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __Course__ > for surreal_orm :: Field { fn from (field_name : & __Course__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __Course__ > for surreal_orm :: Field { fn from (field_name : __Course__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __Course__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __Course__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __Course__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __Course__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __Course__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __Course__) -> Self { Self :: Field (value . into ()) } } impl surreal_orm :: SetterAssignable < LinkOne < Book > > for self :: __Course__ { } impl surreal_orm :: Patchable < LinkOne < Book > > for self :: __Course__ { } # [derive (Debug , Clone)] pub struct __Lowo__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __Lowo__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __Lowo__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __Lowo__ > for surreal_orm :: ValueLike { fn from (value : & __Lowo__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __Lowo__ > for surreal_orm :: ValueLike { fn from (value : __Lowo__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __Lowo__ > for surreal_orm :: Field { fn from (field_name : & __Lowo__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __Lowo__ > for surreal_orm :: Field { fn from (field_name : __Lowo__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __Lowo__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __Lowo__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __Lowo__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __Lowo__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __Lowo__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __Lowo__) -> Self { Self :: Field (value . into ()) } } impl surreal_orm :: SetterAssignable < LinkMany < Book > > for self :: __Lowo__ { } impl surreal_orm :: Patchable < LinkMany < Book > > for self :: __Lowo__ { } impl surreal_orm :: SetterArray < < Book as surreal_orm :: Model > :: Id > for self :: __Lowo__ { } } pub mod _____schema_def { use super :: _____field_names ; use super :: super :: * ; # [allow (non_snake_case)] # [derive (Debug , Clone)] pub struct __Schema__ { pub id : _____field_names :: __Id__ , pub first_name : _____field_names :: __FirstName__ , pub course : _____field_names :: __Course__ , pub lowo : _____field_names :: __Lowo__ , pub (super) ___________graph_traversal_string : :: std :: string :: String , pub (super) ___________bindings : surreal_orm :: BindingsList , pub (super) ___________errors : :: std :: vec :: Vec < :: std :: string :: String > , pub (super) _____struct_marker_ident : :: std :: marker :: PhantomData < () > } } pub type Student = _____schema_def :: __Schema__ ; # [derive (Debug , Clone)] pub struct StudentAliases { pub written_blogs : surreal_orm :: AliasName , } impl StudentAliases { pub fn new () -> Self { Self { written_blogs : \"written_blogs\" . into () , } } } impl surreal_orm :: Aliasable for Student { } impl From < Student > for surreal_orm :: ValueLike { fn from (node : Student) -> Self { Self :: new (node) } } impl surreal_orm :: Parametric for Student { fn get_bindings (& self) -> surreal_orm :: BindingsList { self . ___________bindings . to_vec () } } impl surreal_orm :: Buildable for Student { fn build (& self) -> :: std :: string :: String { self . ___________graph_traversal_string . to_string () } } impl surreal_orm :: Erroneous for Student { fn get_errors (& self) -> :: std :: vec :: Vec < :: std :: string :: String > { self . ___________errors . to_vec () } } impl :: std :: fmt :: Display for Student { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (format_args ! (\"{}\" , self . ___________graph_traversal_string)) } } impl surreal_orm :: Aliasable for & Student { } impl surreal_orm :: Parametric for & Student { fn get_bindings (& self) -> surreal_orm :: BindingsList { self . ___________bindings . to_vec () } } impl surreal_orm :: Buildable for & Student { fn build (& self) -> :: std :: string :: String { self . ___________graph_traversal_string . to_string () } } impl surreal_orm :: Erroneous for & Student { fn get_errors (& self) -> :: std :: vec :: Vec < :: std :: string :: String > { self . ___________errors . to_vec () } } impl Student { pub fn new () -> Self { Self { id : \"id\" . into () , first_name : \"first_name\" . into () , course : \"course\" . into () , lowo : \"lowo\" . into () , ___________graph_traversal_string : \"\" . into () , ___________bindings : :: std :: vec ! [] , ___________errors : :: std :: vec ! [] , _____struct_marker_ident : :: std :: marker :: PhantomData , } } pub fn new_prefixed (prefix : impl :: std :: convert :: Into < surreal_orm :: ValueLike >) -> Self { let prefix : surreal_orm :: ValueLike = prefix . into () ; Self { id : surreal_orm :: Field :: new (format ! (\"{}.{}\" , prefix . build () , \"id\")) . with_bindings (prefix . get_bindings ()) . into () , first_name : surreal_orm :: Field :: new (format ! (\"{}.{}\" , prefix . build () , \"first_name\")) . with_bindings (prefix . get_bindings ()) . into () , course : surreal_orm :: Field :: new (format ! (\"{}.{}\" , prefix . build () , \"course\")) . with_bindings (prefix . get_bindings ()) . into () , lowo : surreal_orm :: Field :: new (format ! (\"{}.{}\" , prefix . build () , \"lowo\")) . with_bindings (prefix . get_bindings ()) . into () , ___________graph_traversal_string : prefix . build () , ___________bindings : prefix . get_bindings () , ___________errors : :: std :: vec ! [] , _____struct_marker_ident : :: std :: marker :: PhantomData , } } pub fn empty () -> Self { Self { id : \"\" . into () , first_name : \"\" . into () , course : \"\" . into () , lowo : \"\" . into () , ___________graph_traversal_string : \"\" . into () , ___________bindings : :: std :: vec ! [] , ___________errors : :: std :: vec ! [] , _____struct_marker_ident : :: std :: marker :: PhantomData , } } pub fn __________connect_node_to_graph_traversal_string (connection : impl surreal_orm :: Buildable + surreal_orm :: Parametric + surreal_orm :: Erroneous , clause : impl :: std :: convert :: Into < surreal_orm :: NodeClause > ,) -> Self { let mut schema_instance = Self :: new () ; let clause : surreal_orm :: NodeClause = clause . into () ; let bindings = [connection . get_bindings () . as_slice () , clause . get_bindings () . as_slice ()] . concat () ; let bindings = bindings . as_slice () ; schema_instance . ___________bindings = bindings . into () ; let errors = [connection . get_errors () . as_slice () , clause . get_errors () . as_slice ()] . concat () ; let errors = errors . as_slice () ; schema_instance . ___________errors = errors . into () ; let connection_str = format ! (\"{}{}\" , connection . build () , clause . build ()) ; schema_instance . ___________graph_traversal_string . push_str (connection_str . as_str ()) ; let ___________graph_traversal_string = & schema_instance . ___________graph_traversal_string ; schema_instance . id = schema_instance . id . set_graph_string (format ! (\"{}.{}\" , ___________graph_traversal_string , \"id\")) . ____________update_many_bindings (bindings) . into () ; schema_instance . first_name = schema_instance . first_name . set_graph_string (format ! (\"{}.{}\" , ___________graph_traversal_string , \"first_name\")) . ____________update_many_bindings (bindings) . into () ; schema_instance . course = schema_instance . course . set_graph_string (format ! (\"{}.{}\" , ___________graph_traversal_string , \"course\")) . ____________update_many_bindings (bindings) . into () ; schema_instance . lowo = schema_instance . lowo . set_graph_string (format ! (\"{}.{}\" , ___________graph_traversal_string , \"lowo\")) . ____________update_many_bindings (bindings) . into () ; schema_instance } pub fn course (& self) -> Book { let clause = surreal_orm :: Clause :: from (surreal_orm :: Empty) ; let normalized_field_name_str = if self . build () . is_empty () { \"course\" } else { \".course\" } ; Book :: __________connect_node_to_graph_traversal_string (self , clause . with_field (normalized_field_name_str)) } pub fn lowo (& self , clause : impl :: std :: convert :: Into < surreal_orm :: NodeAliasClause >) -> Book { let clause : surreal_orm :: NodeAliasClause = clause . into () ; let clause : surreal_orm :: NodeClause = clause . into_inner () ; let db_field_name = if self . build () . is_empty () { \"lowo\" . to_string () } else { format ! (\".{}\" , \"lowo\") } ; Book :: __________connect_node_to_graph_traversal_string (self , clause . with_field (db_field_name)) } } use super :: StudentWritesBlog ; impl Student { pub fn writes__ (& self , clause : impl :: std :: convert :: Into < surreal_orm :: EdgeClause > ,) -> writes___schema________________ :: writes__ { let clause : surreal_orm :: EdgeClause = clause . into () ; let clause = clause . with_arrow (surreal_orm :: Arrow :: Right) . with_table (\"writes\") ; writes___schema________________ :: Writes :: __________connect_edge_to_graph_traversal_string (self , clause ,) . into () } } mod writes___schema________________ { use super :: StudentWritesBlog ; use surreal_orm :: Parametric as _ ; use surreal_orm :: Buildable as _ ; use surreal_orm :: Erroneous as _ ; type Blog = << super :: super :: StudentWritesBlog as surreal_orm :: Edge > :: Out as surreal_orm :: SchemaGetter > :: Schema ; pub type Writes = < super :: super :: StudentWritesBlog as surreal_orm :: SchemaGetter > :: Schema ; pub struct writes__ (Writes) ; impl :: std :: convert :: From < Writes > for writes__ { fn from (value : Writes) -> Self { Self (value) } } impl surreal_orm :: Buildable for writes__ { fn build (& self) -> :: std :: string :: String { self . 0 . build () } } impl surreal_orm :: Parametric for writes__ { fn get_bindings (& self) -> surreal_orm :: BindingsList { self . 0 . get_bindings () } } impl surreal_orm :: Erroneous for writes__ { fn get_errors (& self) -> Vec < :: std :: string :: String > { self . 0 . get_errors () } } impl surreal_orm :: Buildable for & writes__ { fn build (& self) -> :: std :: string :: String { self . 0 . build () } } impl surreal_orm :: Parametric for & writes__ { fn get_bindings (& self) -> surreal_orm :: BindingsList { self . 0 . get_bindings () } } impl surreal_orm :: Erroneous for & writes__ { fn get_errors (& self) -> :: std :: vec :: Vec < :: std :: string :: String > { self . 0 . get_errors () } } impl :: std :: ops :: Deref for writes__ { type Target = Writes ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl writes__ { pub fn Blog (self , clause : impl :: std :: convert :: Into < surreal_orm :: NodeClause >) -> Blog { let clause : surreal_orm :: NodeClause = clause . into () ; let clause = clause . with_arrow (surreal_orm :: Arrow :: Right) . with_table (\"Blog\") ; Blog :: __________connect_node_to_graph_traversal_string (self , clause ,) } pub fn writes__ (& self , clause : impl :: std :: convert :: Into < surreal_orm :: EdgeClause > ,) -> writes__ { let clause : surreal_orm :: EdgeClause = clause . into () ; let clause = clause . with_arrow (surreal_orm :: Arrow :: Right) . with_table (\"writes\") ; Writes :: __________connect_edge_to_graph_traversal_string (self , clause ,) . into () } } } } # [allow (non_snake_case)] # [allow (unreachable_code)] fn _________test_________internal_student_schema_static_funcs_name__________ () { surreal_orm :: validators :: assert_type_is_thing :: < SurrealSimpleId < Student > > () ; surreal_orm :: validators :: assert_type_is_string :: < String > () ; surreal_orm :: validators :: assert_type_eq_all ! (LinkOne < Book > , surreal_orm :: LinkOne < Book >) ; surreal_orm :: validators :: assert_impl_one ! (Book : surreal_orm :: Node) ; surreal_orm :: validators :: assert_type_eq_all ! (LinkMany < Book > , surreal_orm :: LinkMany < Book >) ; surreal_orm :: validators :: assert_impl_one ! (Book : surreal_orm :: Node) ; { surreal_orm :: validators :: assert_type_eq_all ! (< StudentWritesBlog as surreal_orm :: Edge > :: In , Student) ; surreal_orm :: validators :: assert_impl_one ! (< StudentWritesBlog as surreal_orm :: Edge > :: In : surreal_orm :: Node) ; } surreal_orm :: validators :: assert_fields ! (< < StudentWritesBlog as surreal_orm :: Edge > :: Out as surreal_orm :: Node > :: TableNameChecker : Blog) ; surreal_orm :: validators :: assert_impl_one ! (< StudentWritesBlog as surreal_orm :: Edge > :: Out : surreal_orm :: Node) ; surreal_orm :: validators :: assert_fields ! (< StudentWritesBlog as surreal_orm :: Edge > :: TableNameChecker : writes) ; surreal_orm :: validators :: assert_impl_one ! (StudentWritesBlog : surreal_orm :: Edge) ; surreal_orm :: validators :: assert_type_eq_all ! (Relate < Blog > , surreal_orm :: Relate < < StudentWritesBlog as surreal_orm :: Edge > :: Out >) ; }"

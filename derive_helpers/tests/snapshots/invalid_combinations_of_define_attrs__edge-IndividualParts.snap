---
source: derive_helpers/tests/invalid_combinations_of_define_attrs.rs
expression: node_token
---
use surreal_orm :: ToRaw as _ ; use surreal_orm :: Aliasable as _ ; use :: std :: str :: FromStr as _ ; impl < In , Out > surreal_orm :: SchemaGetter for Writes < In , Out > { type Schema = writes :: Schema < In , Out > ; fn schema () -> writes :: Schema < In , Out > { writes :: Schema :: < In , Out > :: new () } fn schema_prefixed (prefix : impl :: std :: convert :: Into < surreal_orm :: ValueLike >) -> writes :: Schema < In , Out > { writes :: Schema :: < In , Out > :: new_prefixed (prefix) } } impl < In , Out > surreal_orm :: PartialUpdater for Writes < In , Out > { type StructPartial = WritesPartial < In , Out > ; type PartialBuilder = WritesPartialBuilder < In , Out > ; fn partial_builder () -> Self :: PartialBuilder { WritesPartialBuilder :: new () } } impl < In , Out > surreal_orm :: Node for Writes < In , Out > { type TableNameChecker = ________internal_writes_schema :: TableNameStaticChecker ; type Aliases = ________internal_writes_schema :: WritesAliases ; fn with (clause : impl :: std :: convert :: Into < surreal_orm :: NodeClause >) -> < Self as surreal_orm :: SchemaGetter > :: Schema { let clause : surreal_orm :: NodeClause = clause . into () ; ________internal_writes_schema :: Writes :: < In , Out > :: __________connect_node_to_graph_traversal_string (________internal_writes_schema :: Writes :: < In , Out > :: empty () , clause . with_table ("writes") ,) } fn aliases () -> Self :: Aliases { ________internal_writes_schema :: WritesAliases :: new () } fn get_table () -> surreal_orm :: Table { "writes" . into () } fn get_fields_relations_aliased () -> :: std :: vec :: Vec < surreal_orm :: Alias > { vec ! [] } } # [allow (non_snake_case)] # [derive (surreal_orm :: serde :: Serialize , Debug , Clone , Default)] pub struct WritesPartial < In , Out > { # [serde (skip)] _____struct_marker_ident : surreal_orm :: Maybe < :: std :: marker :: PhantomData < (In , Out) > > , # [serde (skip_serializing_if = "surreal_orm::Maybe::is_none" , rename = "id")] pub id : surreal_orm :: Maybe < SurrealSimpleId < Writes < In , Out > > > , # [serde (skip_serializing_if = "surreal_orm::Maybe::is_none" , rename = "in")] pub r#in : surreal_orm :: Maybe < LinkOne < In > > , # [serde (skip_serializing_if = "surreal_orm::Maybe::is_none" , rename = "out")] pub out : surreal_orm :: Maybe < LinkOne < Out > > } # [derive (surreal_orm :: serde :: Serialize , Debug , Clone , Default)] pub struct WritesPartialBuilder < In , Out > (WritesPartial < In , Out >) ; impl < In , Out > WritesPartialBuilder < In , Out > { pub fn new () -> Self { Self (WritesPartial { _____struct_marker_ident : surreal_orm :: Maybe :: None , id : surreal_orm :: Maybe :: None , r#in : surreal_orm :: Maybe :: None , out : surreal_orm :: Maybe :: None }) } pub fn id (mut self , value : SurrealSimpleId < Writes < In , Out > >) -> Self { self . 0. id = surreal_orm :: Maybe :: Some (value) ; self } pub fn r#in (mut self , value : LinkOne < In >) -> Self { self . 0. r#in = surreal_orm :: Maybe :: Some (value) ; self } pub fn out (mut self , value : LinkOne < Out >) -> Self { self . 0. out = surreal_orm :: Maybe :: Some (value) ; self } pub fn build (self) -> WritesPartial < In , Out > { self . 0 } } # [allow (non_snake_case)] # [derive (surreal_orm :: serde :: Serialize , surreal_orm :: serde :: Deserialize , Debug , Clone)] pub struct WritesRenamedCreator { pub id : & 'static str , pub r#in : & 'static str , pub out : & 'static str } impl < In , Out > Writes < In , Out > { pub const fn __get_serializable_field_names () -> [& 'static str ; 3usize] { [stringify ! ("id" . into ()) , stringify ! ("in" . into ()) , stringify ! ("out" . into ())] } } impl < In , Out > surreal_orm :: Model for Writes < In , Out > { type Id = SurrealSimpleId < Self > ; type StructRenamedCreator = WritesRenamedCreator ; fn table () -> surreal_orm :: Table { "writes" . into () } fn get_id (self) -> Self :: Id { self . id } fn get_id_as_thing (& self) -> surreal_orm :: sql :: Thing { surreal_orm :: sql :: thing (self . id . to_raw () . as_str ()) . unwrap () } fn get_serializable_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! ["id" . into () , "in" . into () , "out" . into ()] } fn get_linked_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [surreal_orm :: Field :: new ("in") , surreal_orm :: Field :: new ("out")] } fn get_link_one_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [surreal_orm :: Field :: new ("in") , surreal_orm :: Field :: new ("out")] } fn get_link_self_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [] } fn get_link_one_and_self_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [surreal_orm :: Field :: new ("in") , surreal_orm :: Field :: new ("out")] } fn get_link_many_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [] } fn get_field_meta () -> :: std :: vec :: Vec < surreal_orm :: FieldMetadata > { return :: std :: vec ! [surreal_orm :: FieldMetadata { name : "id" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("id")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Self :: table ()])) . to_raw ()] } , surreal_orm :: FieldMetadata { name : "in" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("in")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [In :: table ()])) . to_raw ()] } , surreal_orm :: FieldMetadata { name : "out" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("out")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Out :: table ()])) . to_raw ()] }] } fn define_table () -> surreal_orm :: Raw { surreal_orm :: statements :: define_table (Self :: table ()) . drop () . schemafull () . permissions (perm () . to_raw ()) . to_raw () } fn define_fields () -> :: std :: vec :: Vec < surreal_orm :: Raw > { :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("id")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Self :: table ()])) . to_raw () , surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("in")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [In :: table ()])) . to_raw () , surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("out")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Out :: table ()])) . to_raw ()] } } # [allow (non_snake_case)] pub mod writes { pub use super :: ________internal_writes_schema :: _____schema_def :: __Schema__ as Schema ; } # [allow (non_snake_case)] mod ________internal_writes_schema { use surreal_orm :: Parametric as _ ; use surreal_orm :: Buildable as _ ; use surreal_orm :: Erroneous as _ ; use super :: * ; pub struct TableNameStaticChecker { pub writes : :: std :: string :: String , } type Out = < super :: Out as surreal_orm :: SchemaGetter > :: Schema ; type In = < super :: In as surreal_orm :: SchemaGetter > :: Schema ; pub (super) mod _____field_names { use super :: super :: * ; use surreal_orm :: Parametric as _ ; use surreal_orm :: Buildable as _ ; # [derive (Debug , Clone)] pub struct __Id__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __Id__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __Id__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __Id__ > for surreal_orm :: ValueLike { fn from (value : & __Id__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __Id__ > for surreal_orm :: ValueLike { fn from (value : __Id__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __Id__ > for surreal_orm :: Field { fn from (field_name : & __Id__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __Id__ > for surreal_orm :: Field { fn from (field_name : __Id__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __Id__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __Id__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __Id__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __Id__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __Id__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __Id__) -> Self { Self :: Field (value . into ()) } } impl < In , Out > surreal_orm :: SetterAssignable < SurrealSimpleId < Writes < In , Out > > > for self :: __Id__ { } # [derive (Debug , Clone)] pub struct __In__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __In__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __In__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __In__ > for surreal_orm :: ValueLike { fn from (value : & __In__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __In__ > for surreal_orm :: ValueLike { fn from (value : __In__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __In__ > for surreal_orm :: Field { fn from (field_name : & __In__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __In__ > for surreal_orm :: Field { fn from (field_name : __In__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __In__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __In__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __In__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __In__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __In__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __In__) -> Self { Self :: Field (value . into ()) } } impl < In > surreal_orm :: SetterAssignable < LinkOne < In > > for self :: __In__ { } impl < In > surreal_orm :: Patchable < LinkOne < In > > for self :: __In__ { } # [derive (Debug , Clone)] pub struct __Out__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __Out__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __Out__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __Out__ > for surreal_orm :: ValueLike { fn from (value : & __Out__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __Out__ > for surreal_orm :: ValueLike { fn from (value : __Out__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __Out__ > for surreal_orm :: Field { fn from (field_name : & __Out__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __Out__ > for surreal_orm :: Field { fn from (field_name : __Out__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __Out__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __Out__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __Out__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __Out__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __Out__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __Out__) -> Self { Self :: Field (value . into ()) } } impl < Out > surreal_orm :: SetterAssignable < LinkOne < Out > > for self :: __Out__ { } impl < Out > surreal_orm :: Patchable < LinkOne < Out > > for self :: __Out__ { } } pub mod _____schema_def { use super :: _____field_names ; use super :: super :: * ; # [allow (non_snake_case)] # [derive (Debug , Clone)] pub struct __Schema__ < In , Out > { pub id : _____field_names :: __Id__ , pub r#in : _____field_names :: __In__ , pub out : _____field_names :: __Out__ , pub (super) ___________graph_traversal_string : :: std :: string :: String , pub (super) ___________bindings : surreal_orm :: BindingsList , pub (super) ___________errors : :: std :: vec :: Vec < :: std :: string :: String > , pub (super) _____struct_marker_ident : :: std :: marker :: PhantomData < (In , Out) > } } pub type Writes < In , Out > = _____schema_def :: __Schema__ < In , Out > ; # [derive (Debug , Clone)] pub struct WritesAliases { } impl WritesAliases { pub fn new () -> Self { Self { } } } impl < In , Out > surreal_orm :: Aliasable for Writes < In , Out > { } impl < In , Out > From < Writes < In , Out > > for surreal_orm :: ValueLike { fn from (node : Writes < In , Out >) -> Self { Self :: new (node) } } impl < In , Out > surreal_orm :: Parametric for Writes < In , Out > { fn get_bindings (& self) -> surreal_orm :: BindingsList { self . ___________bindings . to_vec () } } impl < In , Out > surreal_orm :: Buildable for Writes < In , Out > { fn build (& self) -> :: std :: string :: String { self . ___________graph_traversal_string . to_string () } } impl < In , Out > surreal_orm :: Erroneous for Writes < In , Out > { fn get_errors (& self) -> :: std :: vec :: Vec < :: std :: string :: String > { self . ___________errors . to_vec () } } impl < In , Out > :: std :: fmt :: Display for Writes < In , Out > { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (format_args ! ("{}" , self . ___________graph_traversal_string)) } } impl < In , Out > surreal_orm :: Aliasable for & Writes < In , Out > { } impl < In , Out > surreal_orm :: Parametric for & Writes < In , Out > { fn get_bindings (& self) -> surreal_orm :: BindingsList { self . ___________bindings . to_vec () } } impl < In , Out > surreal_orm :: Buildable for & Writes < In , Out > { fn build (& self) -> :: std :: string :: String { self . ___________graph_traversal_string . to_string () } } impl < In , Out > surreal_orm :: Erroneous for & Writes < In , Out > { fn get_errors (& self) -> :: std :: vec :: Vec < :: std :: string :: String > { self . ___________errors . to_vec () } } impl < In , Out > Writes < In , Out > { pub fn new () -> Self { Self { id : "id" . into () , r#in : "in" . into () , out : "out" . into () , ___________graph_traversal_string : "" . into () , ___________bindings : :: std :: vec ! [] , ___________errors : :: std :: vec ! [] , _____struct_marker_ident : :: std :: marker :: PhantomData , } } pub fn new_prefixed (prefix : impl :: std :: convert :: Into < surreal_orm :: ValueLike >) -> Self { let prefix : surreal_orm :: ValueLike = prefix . into () ; Self { id : surreal_orm :: Field :: new (format ! ("{}.{}" , prefix . build () , "id")) . with_bindings (prefix . get_bindings ()) . into () , r#in : surreal_orm :: Field :: new (format ! ("{}.{}" , prefix . build () , "in")) . with_bindings (prefix . get_bindings ()) . into () , out : surreal_orm :: Field :: new (format ! ("{}.{}" , prefix . build () , "out")) . with_bindings (prefix . get_bindings ()) . into () , ___________graph_traversal_string : prefix . build () , ___________bindings : prefix . get_bindings () , ___________errors : :: std :: vec ! [] , _____struct_marker_ident : :: std :: marker :: PhantomData , } } pub fn empty () -> Self { Self { id : "" . into () , r#in : "" . into () , out : "" . into () , ___________graph_traversal_string : "" . into () , ___________bindings : :: std :: vec ! [] , ___________errors : :: std :: vec ! [] , _____struct_marker_ident : :: std :: marker :: PhantomData , } } pub fn __________connect_node_to_graph_traversal_string (connection : impl surreal_orm :: Buildable + surreal_orm :: Parametric + surreal_orm :: Erroneous , clause : impl :: std :: convert :: Into < surreal_orm :: NodeClause > ,) -> Self { let mut schema_instance = Self :: new () ; let clause : surreal_orm :: NodeClause = clause . into () ; let bindings = [connection . get_bindings () . as_slice () , clause . get_bindings () . as_slice ()] . concat () ; let bindings = bindings . as_slice () ; schema_instance . ___________bindings = bindings . into () ; let errors = [connection . get_errors () . as_slice () , clause . get_errors () . as_slice ()] . concat () ; let errors = errors . as_slice () ; schema_instance . ___________errors = errors . into () ; let connection_str = format ! ("{}{}" , connection . build () , clause . build ()) ; schema_instance . ___________graph_traversal_string . push_str (connection_str . as_str ()) ; let ___________graph_traversal_string = & schema_instance . ___________graph_traversal_string ; schema_instance . id = schema_instance . id . set_graph_string (format ! ("{}.{}" , ___________graph_traversal_string , "id")) . ____________update_many_bindings (bindings) . into () ; schema_instance . r#in = schema_instance . r#in . set_graph_string (format ! ("{}.{}" , ___________graph_traversal_string , "in")) . ____________update_many_bindings (bindings) . into () ; schema_instance . out = schema_instance . out . set_graph_string (format ! ("{}.{}" , ___________graph_traversal_string , "out")) . ____________update_many_bindings (bindings) . into () ; schema_instance } pub fn in (& self) -> In { let clause = surreal_orm :: Clause :: from (surreal_orm :: Empty) ; let normalized_field_name_str = if self . build () . is_empty () { "in" } else { ".in" } ; In :: __________connect_node_to_graph_traversal_string (self , clause . with_field (normalized_field_name_str)) } pub fn out (& self) -> Out { let clause = surreal_orm :: Clause :: from (surreal_orm :: Empty) ; let normalized_field_name_str = if self . build () . is_empty () { "out" } else { ".out" } ; Out :: __________connect_node_to_graph_traversal_string (self , clause . with_field (normalized_field_name_str)) } } } # [allow (non_snake_case)] # [allow (unreachable_code)] fn _________test_________internal_writes_schema_static_funcs_name__________ < In , Out > () { surreal_orm :: validators :: assert_type_is_thing :: < SurrealSimpleId < Writes < In , Out > > > () ; surreal_orm :: validators :: assert_type_eq_all ! (LinkOne < In > , surreal_orm :: LinkOne < In >) ; surreal_orm :: validators :: assert_impl_one ! (In : surreal_orm :: Node) ; surreal_orm :: validators :: assert_type_eq_all ! (LinkOne < Out > , surreal_orm :: LinkOne < Out >) ; surreal_orm :: validators :: assert_impl_one ! (Out : surreal_orm :: Node) ; }

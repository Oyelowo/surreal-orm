---
source: derive_helpers/tests/table_name.rs
expression: "format!(\"{:#}\", node_token.to_token_stream())"
---
use surreal_orm :: ToRaw as _ ; use surreal_orm :: Aliasable as _ ; use :: std :: str :: FromStr as _ ; impl surreal_orm :: SchemaGetter for StudentTable { type Schema = student_table :: Schema ; fn schema () -> student_table :: Schema { student_table :: Schema :: new () } fn schema_prefixed (prefix : impl :: std :: convert :: Into < surreal_orm :: ValueLike >) -> student_table :: Schema { student_table :: Schema :: new_prefixed (prefix) } } impl surreal_orm :: PartialUpdater for StudentTable { type StructPartial = StudentTablePartial ; type PartialBuilder = StudentTablePartialBuilder ; fn partial_builder () -> Self :: PartialBuilder { StudentTablePartialBuilder :: new () } } impl surreal_orm :: Node for StudentTable { type TableNameChecker = ________internal_student_table_schema :: TableNameStaticChecker ; type Aliases = ________internal_student_table_schema :: StudentTableAliases ; fn with (clause : impl :: std :: convert :: Into < surreal_orm :: NodeClause >) -> < Self as surreal_orm :: SchemaGetter > :: Schema { let clause : surreal_orm :: NodeClause = clause . into () ; ________internal_student_table_schema :: StudentTable :: __________connect_node_to_graph_traversal_string (________internal_student_table_schema :: StudentTable :: empty () , clause . with_table ("student_table") ,) } fn aliases () -> Self :: Aliases { ________internal_student_table_schema :: StudentTableAliases :: new () } fn get_table () -> surreal_orm :: Table { "student_table" . into () } fn get_fields_relations_aliased () -> :: std :: vec :: Vec < surreal_orm :: Alias > { vec ! [] } } # [allow (non_snake_case)] # [derive (surreal_orm :: serde :: Serialize , Debug , Clone , Default)] pub struct StudentTablePartial { # [serde (skip)] _____struct_marker_ident : surreal_orm :: Maybe < :: std :: marker :: PhantomData < () > > , # [serde (skip_serializing_if = "surreal_orm::Maybe::is_none" , rename = "id")] pub id : surreal_orm :: Maybe < SurrealSimpleId < StudentTable > > } # [derive (surreal_orm :: serde :: Serialize , Debug , Clone , Default)] pub struct StudentTablePartialBuilder (StudentTablePartial) ; impl StudentTablePartialBuilder { pub fn new () -> Self { Self (StudentTablePartial { _____struct_marker_ident : surreal_orm :: Maybe :: None , id : surreal_orm :: Maybe :: None }) } pub fn id (mut self , value : SurrealSimpleId < StudentTable >) -> Self { self . 0. id = surreal_orm :: Maybe :: Some (value) ; self } pub fn build (self) -> StudentTablePartial { self . 0 } } # [allow (non_snake_case)] # [derive (surreal_orm :: serde :: Serialize , surreal_orm :: serde :: Deserialize , Debug , Clone)] pub struct StudentTableRenamedCreator { pub id : & 'static str } impl StudentTable { pub const fn __get_serializable_field_names () -> [& 'static str ; 1usize] { [stringify ! ("id" . into ())] } } impl surreal_orm :: Model for StudentTable { type Id = SurrealSimpleId < Self > ; type StructRenamedCreator = StudentTableRenamedCreator ; fn table () -> surreal_orm :: Table { "student_table" . into () } fn get_id (self) -> Self :: Id { self . id } fn get_id_as_thing (& self) -> surreal_orm :: sql :: Thing { surreal_orm :: sql :: thing (self . id . to_raw () . as_str ()) . unwrap () } fn get_serializable_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! ["id" . into ()] } fn get_linked_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [] } fn get_link_one_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [] } fn get_link_self_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [] } fn get_link_one_and_self_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [] } fn get_link_many_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [] } fn get_field_meta () -> :: std :: vec :: Vec < surreal_orm :: FieldMetadata > { return :: std :: vec ! [surreal_orm :: FieldMetadata { name : "id" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("id")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Self :: table ()])) . to_raw ()] }] } fn define_table () -> surreal_orm :: Raw { surreal_orm :: statements :: define_table (Self :: table ()) . to_raw () } fn define_fields () -> :: std :: vec :: Vec < surreal_orm :: Raw > { :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new ("id")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Self :: table ()])) . to_raw ()] } } # [allow (non_snake_case)] pub mod student_table { pub use super :: ________internal_student_table_schema :: _____schema_def :: __Schema__ as Schema ; } # [allow (non_snake_case)] mod ________internal_student_table_schema { use surreal_orm :: Parametric as _ ; use surreal_orm :: Buildable as _ ; use surreal_orm :: Erroneous as _ ; use super :: * ; pub struct TableNameStaticChecker { pub student_table : :: std :: string :: String , } pub (super) mod _____field_names { use super :: super :: * ; use surreal_orm :: Parametric as _ ; use surreal_orm :: Buildable as _ ; # [derive (Debug , Clone)] pub struct __Id__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __Id__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __Id__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __Id__ > for surreal_orm :: ValueLike { fn from (value : & __Id__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __Id__ > for surreal_orm :: ValueLike { fn from (value : __Id__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __Id__ > for surreal_orm :: Field { fn from (field_name : & __Id__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __Id__ > for surreal_orm :: Field { fn from (field_name : __Id__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __Id__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __Id__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __Id__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __Id__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __Id__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __Id__) -> Self { Self :: Field (value . into ()) } } impl surreal_orm :: SetterAssignable < SurrealSimpleId < StudentTable > > for self :: __Id__ { } } pub mod _____schema_def { use super :: _____field_names ; use super :: super :: * ; # [allow (non_snake_case)] # [derive (Debug , Clone)] pub struct __Schema__ { pub id : _____field_names :: __Id__ , pub (super) ___________graph_traversal_string : :: std :: string :: String , pub (super) ___________bindings : surreal_orm :: BindingsList , pub (super) ___________errors : :: std :: vec :: Vec < :: std :: string :: String > , pub (super) _____struct_marker_ident : :: std :: marker :: PhantomData < () > } } pub type StudentTable = _____schema_def :: __Schema__ ; # [derive (Debug , Clone)] pub struct StudentTableAliases { } impl StudentTableAliases { pub fn new () -> Self { Self { } } } impl surreal_orm :: Aliasable for StudentTable { } impl From < StudentTable > for surreal_orm :: ValueLike { fn from (node : StudentTable) -> Self { Self :: new (node) } } impl surreal_orm :: Parametric for StudentTable { fn get_bindings (& self) -> surreal_orm :: BindingsList { self . ___________bindings . to_vec () } } impl surreal_orm :: Buildable for StudentTable { fn build (& self) -> :: std :: string :: String { self . ___________graph_traversal_string . to_string () } } impl surreal_orm :: Erroneous for StudentTable { fn get_errors (& self) -> :: std :: vec :: Vec < :: std :: string :: String > { self . ___________errors . to_vec () } } impl :: std :: fmt :: Display for StudentTable { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . write_fmt (format_args ! ("{}" , self . ___________graph_traversal_string)) } } impl surreal_orm :: Aliasable for & StudentTable { } impl surreal_orm :: Parametric for & StudentTable { fn get_bindings (& self) -> surreal_orm :: BindingsList { self . ___________bindings . to_vec () } } impl surreal_orm :: Buildable for & StudentTable { fn build (& self) -> :: std :: string :: String { self . ___________graph_traversal_string . to_string () } } impl surreal_orm :: Erroneous for & StudentTable { fn get_errors (& self) -> :: std :: vec :: Vec < :: std :: string :: String > { self . ___________errors . to_vec () } } impl StudentTable { pub fn new () -> Self { Self { id : "id" . into () , ___________graph_traversal_string : "" . into () , ___________bindings : :: std :: vec ! [] , ___________errors : :: std :: vec ! [] , _____struct_marker_ident : :: std :: marker :: PhantomData , } } pub fn new_prefixed (prefix : impl :: std :: convert :: Into < surreal_orm :: ValueLike >) -> Self { let prefix : surreal_orm :: ValueLike = prefix . into () ; Self { id : surreal_orm :: Field :: new (format ! ("{}.{}" , prefix . build () , "id")) . with_bindings (prefix . get_bindings ()) . into () , ___________graph_traversal_string : prefix . build () , ___________bindings : prefix . get_bindings () , ___________errors : :: std :: vec ! [] , _____struct_marker_ident : :: std :: marker :: PhantomData , } } pub fn empty () -> Self { Self { id : "" . into () , ___________graph_traversal_string : "" . into () , ___________bindings : :: std :: vec ! [] , ___________errors : :: std :: vec ! [] , _____struct_marker_ident : :: std :: marker :: PhantomData , } } pub fn __________connect_node_to_graph_traversal_string (connection : impl surreal_orm :: Buildable + surreal_orm :: Parametric + surreal_orm :: Erroneous , clause : impl :: std :: convert :: Into < surreal_orm :: NodeClause > ,) -> Self { let mut schema_instance = Self :: new () ; let clause : surreal_orm :: NodeClause = clause . into () ; let bindings = [connection . get_bindings () . as_slice () , clause . get_bindings () . as_slice ()] . concat () ; let bindings = bindings . as_slice () ; schema_instance . ___________bindings = bindings . into () ; let errors = [connection . get_errors () . as_slice () , clause . get_errors () . as_slice ()] . concat () ; let errors = errors . as_slice () ; schema_instance . ___________errors = errors . into () ; let connection_str = format ! ("{}{}" , connection . build () , clause . build ()) ; schema_instance . ___________graph_traversal_string . push_str (connection_str . as_str ()) ; let ___________graph_traversal_string = & schema_instance . ___________graph_traversal_string ; schema_instance . id = schema_instance . id . set_graph_string (format ! ("{}.{}" , ___________graph_traversal_string , "id")) . ____________update_many_bindings (bindings) . into () ; schema_instance } } } # [allow (non_snake_case)] # [allow (unreachable_code)] fn _________test_________internal_student_table_schema_static_funcs_name__________ () { surreal_orm :: validators :: assert_type_is_thing :: < SurrealSimpleId < StudentTable > > () ; }

---
source: derive_helpers/tests/generate_test.rs
expression: "format!(\"{:#}\", node_token.to_token_stream())"
---
"use surreal_orm :: ToRaw as _ ; use :: std :: str :: FromStr as _ ; impl < In , Out > Writes < In , Out > { pub const fn __get_serializable_field_names () -> [& 'static str ; 6usize] { [stringify ! (\"id\" . into ()) , stringify ! (\"duration_of_write\" . into ()) , stringify ! (\"in\" . into ()) , stringify ! (\"out\" . into ()) , stringify ! (\"course\" . into ()) , stringify ! (\"field_nother\" . into ())] } } impl < In , Out > surreal_orm :: SchemaGetter for Writes < In , Out > { type Schema = ________internal_writes_schema :: Writes < In , Out > ; fn schema () -> Self :: Schema { writes :: Schema :: < In , Out > :: new () } fn schema_prefixed (prefix : impl :: std :: convert :: Into < surreal_orm :: ValueLike >) -> Self :: Schema { writes :: Schema :: < In , Out > :: new_prefixed (prefix) } } impl < In , Out > surreal_orm :: PartialUpdater for Writes < In , Out > { type StructPartial = WritesPartial < In , Out > ; type PartialBuilder = WritesPartialBuilder < In , Out > ; fn partial_builder () -> Self :: PartialBuilder { WritesPartialBuilder :: new () } } # [allow (non_snake_case)] impl < In , Out > surreal_orm :: Edge for Writes < In , Out > { type In = In ; type Out = Out ; type TableNameChecker = ________internal_writes_schema :: TableNameStaticChecker ; # [allow (non_snake_case)] fn get_table () -> surreal_orm :: Table { \"writes\" . into () } } # [allow (non_snake_case)] # [derive (surreal_orm :: serde :: Serialize , Debug , Clone , Default)] pub struct WritesPartial < In , Out > { # [serde (skip)] _____struct_marker_ident : surreal_orm :: Maybe < :: std :: marker :: PhantomData < (In , Out) > > , # [serde (skip_serializing_if = \"surreal_orm::Maybe::is_none\" , rename = \"id\")] pub id : surreal_orm :: Maybe < SurrealSimpleId < Writes < In , Out > > > , # [serde (skip_serializing_if = \"surreal_orm::Maybe::is_none\" , rename = \"duration_of_write\")] pub duration_of_write : surreal_orm :: Maybe < Duration > , # [serde (skip_serializing_if = \"surreal_orm::Maybe::is_none\" , rename = \"in\")] pub r#in : surreal_orm :: Maybe < LinkOne < In > > , # [serde (skip_serializing_if = \"surreal_orm::Maybe::is_none\" , rename = \"out\")] pub out : surreal_orm :: Maybe < LinkOne < Out > > , # [serde (skip_serializing_if = \"surreal_orm::Maybe::is_none\" , rename = \"course\")] pub course : surreal_orm :: Maybe < LinkOne < Book > > , # [serde (skip_serializing_if = \"surreal_orm::Maybe::is_none\" , rename = \"field_nother\")] pub field_nother : surreal_orm :: Maybe < LinkMany < Book > > } # [derive (surreal_orm :: serde :: Serialize , Debug , Clone , Default)] pub struct WritesPartialBuilder < In , Out > (WritesPartial < In , Out >) ; impl < In , Out > WritesPartialBuilder < In , Out > { pub fn new () -> Self { Self (WritesPartial { _____struct_marker_ident : surreal_orm :: Maybe :: None , id : surreal_orm :: Maybe :: None , duration_of_write : surreal_orm :: Maybe :: None , r#in : surreal_orm :: Maybe :: None , out : surreal_orm :: Maybe :: None , course : surreal_orm :: Maybe :: None , field_nother : surreal_orm :: Maybe :: None }) } pub fn id (mut self , value : SurrealSimpleId < Writes < In , Out > >) -> Self { self . 0. id = surreal_orm :: Maybe :: Some (value) ; self } pub fn duration_of_write (mut self , value : Duration) -> Self { self . 0. duration_of_write = surreal_orm :: Maybe :: Some (value) ; self } pub fn r#in (mut self , value : LinkOne < In >) -> Self { self . 0. r#in = surreal_orm :: Maybe :: Some (value) ; self } pub fn out (mut self , value : LinkOne < Out >) -> Self { self . 0. out = surreal_orm :: Maybe :: Some (value) ; self } pub fn course (mut self , value : LinkOne < Book >) -> Self { self . 0. course = surreal_orm :: Maybe :: Some (value) ; self } pub fn field_nother (mut self , value : LinkMany < Book >) -> Self { self . 0. field_nother = surreal_orm :: Maybe :: Some (value) ; self } pub fn build (self) -> WritesPartial < In , Out > { self . 0 } } # [allow (non_snake_case)] # [derive (surreal_orm :: serde :: Serialize , Debug , Clone)] pub struct WritesRenamedCreator { pub id : & 'static str , pub duration_of_write : & 'static str , pub r#in : & 'static str , pub out : & 'static str , pub course : & 'static str , pub field_nother : & 'static str } # [allow (non_snake_case)] impl < In , Out > surreal_orm :: Model for Writes < In , Out > { type Id = SurrealSimpleId < Self > ; type StructRenamedCreator = WritesRenamedCreator ; fn table () -> surreal_orm :: Table { \"writes\" . into () } fn get_id (self) -> Self :: Id { self . id } fn get_id_as_thing (& self) -> surreal_orm :: sql :: Thing { surreal_orm :: sql :: thing (self . id . to_raw () . as_str ()) . unwrap () } fn get_serializable_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [\"id\" . into () , \"duration_of_write\" . into () , \"in\" . into () , \"out\" . into () , \"course\" . into () , \"field_nother\" . into ()] } fn get_linked_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [surreal_orm :: Field :: new (\"in\") , surreal_orm :: Field :: new (\"out\") , surreal_orm :: Field :: new (\"course\") , surreal_orm :: Field :: new (\"field_nother\")] } fn get_link_one_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [surreal_orm :: Field :: new (\"in\") , surreal_orm :: Field :: new (\"out\") , surreal_orm :: Field :: new (\"course\")] } fn get_link_self_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [] } fn get_link_one_and_self_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [surreal_orm :: Field :: new (\"in\") , surreal_orm :: Field :: new (\"out\") , surreal_orm :: Field :: new (\"course\")] } fn get_link_many_fields () -> :: std :: vec :: Vec < surreal_orm :: Field > { return :: std :: vec ! [surreal_orm :: Field :: new (\"field_nother\")] } fn define_table () -> surreal_orm :: Raw { surreal_orm :: statements :: define_table (Self :: table ()) . drop () . schemafull () . permissions (perm () . to_raw ()) . to_raw () } fn define_fields () -> :: std :: vec :: Vec < surreal_orm :: Raw > { :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"id\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Self :: table ()])) . to_raw () , surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"duration_of_write\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Duration) . to_raw () , surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"in\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [])) . to_raw () , surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"out\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [])) . to_raw () , surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"course\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Book :: table ()])) . to_raw () , surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"field_nother\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Array (:: std :: boxed :: Box :: new (surreal_orm :: FieldType :: Record (:: std :: vec ! [Book :: table ()])) , :: std :: option :: Option :: None)) . to_raw ()] } fn get_field_meta () -> :: std :: vec :: Vec < surreal_orm :: FieldMetadata > { return :: std :: vec ! [surreal_orm :: FieldMetadata { name : \"id\" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"id\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Self :: table ()])) . to_raw ()] } , surreal_orm :: FieldMetadata { name : \"duration_of_write\" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"duration_of_write\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Duration) . to_raw ()] } , surreal_orm :: FieldMetadata { name : \"in\" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"in\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [])) . to_raw ()] } , surreal_orm :: FieldMetadata { name : \"out\" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"out\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [])) . to_raw ()] } , surreal_orm :: FieldMetadata { name : \"course\" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"course\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Record (:: std :: vec ! [Book :: table ()])) . to_raw ()] } , surreal_orm :: FieldMetadata { name : \"field_nother\" . into () , old_name : :: std :: option :: Option :: None , definition : :: std :: vec ! [surreal_orm :: statements :: define_field (surreal_orm :: Field :: new (\"field_nother\")) . on_table (surreal_orm :: Table :: from (Self :: table ())) . type_ (surreal_orm :: FieldType :: Array (:: std :: boxed :: Box :: new (surreal_orm :: FieldType :: Record (:: std :: vec ! [Book :: table ()])) , :: std :: option :: Option :: None)) . to_raw ()] }] } } # [allow (non_snake_case)] pub mod writes { pub use super :: ________internal_writes_schema :: _____schema_def :: __Schema__ as Schema ; } # [allow (non_snake_case)] mod ________internal_writes_schema { use surreal_orm :: Node ; use surreal_orm :: Parametric as _ ; use surreal_orm :: Buildable as _ ; use surreal_orm :: Erroneous as _ ; pub struct TableNameStaticChecker { pub writes : :: std :: string :: String , } type Book = < super :: Book as surreal_orm :: SchemaGetter > :: Schema ; pub (super) mod _____field_names { use super :: super :: * ; use surreal_orm :: Parametric as _ ; use surreal_orm :: Buildable as _ ; # [derive (Debug , Clone)] pub struct __Id__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __Id__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __Id__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __Id__ > for surreal_orm :: ValueLike { fn from (value : & __Id__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __Id__ > for surreal_orm :: ValueLike { fn from (value : __Id__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __Id__ > for surreal_orm :: Field { fn from (field_name : & __Id__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __Id__ > for surreal_orm :: Field { fn from (field_name : __Id__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __Id__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __Id__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __Id__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __Id__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __Id__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __Id__) -> Self { Self :: Field (value . into ()) } } impl < In , Out > surreal_orm :: SetterAssignable < SurrealSimpleId < Writes < In , Out > > > for self :: __Id__ { } # [derive (Debug , Clone)] pub struct __DurationOfWrite__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __DurationOfWrite__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __DurationOfWrite__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __DurationOfWrite__ > for surreal_orm :: ValueLike { fn from (value : & __DurationOfWrite__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __DurationOfWrite__ > for surreal_orm :: ValueLike { fn from (value : __DurationOfWrite__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __DurationOfWrite__ > for surreal_orm :: Field { fn from (field_name : & __DurationOfWrite__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __DurationOfWrite__ > for surreal_orm :: Field { fn from (field_name : __DurationOfWrite__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __DurationOfWrite__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __DurationOfWrite__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __DurationOfWrite__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __DurationOfWrite__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __DurationOfWrite__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __DurationOfWrite__) -> Self { Self :: Field (value . into ()) } } impl surreal_orm :: SetterAssignable < Duration > for self :: __DurationOfWrite__ { } impl surreal_orm :: Patchable < Duration > for self :: __DurationOfWrite__ { } # [derive (Debug , Clone)] pub struct __In__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __In__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __In__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __In__ > for surreal_orm :: ValueLike { fn from (value : & __In__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __In__ > for surreal_orm :: ValueLike { fn from (value : __In__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __In__ > for surreal_orm :: Field { fn from (field_name : & __In__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __In__ > for surreal_orm :: Field { fn from (field_name : __In__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __In__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __In__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __In__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __In__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __In__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __In__) -> Self { Self :: Field (value . into ()) } } impl < In > surreal_orm :: SetterAssignable < LinkOne < In > > for self :: __In__ { } impl < In > surreal_orm :: Patchable < LinkOne < In > > for self :: __In__ { } # [derive (Debug , Clone)] pub struct __Out__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __Out__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __Out__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __Out__ > for surreal_orm :: ValueLike { fn from (value : & __Out__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __Out__ > for surreal_orm :: ValueLike { fn from (value : __Out__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __Out__ > for surreal_orm :: Field { fn from (field_name : & __Out__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __Out__ > for surreal_orm :: Field { fn from (field_name : __Out__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __Out__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __Out__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __Out__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __Out__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __Out__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __Out__) -> Self { Self :: Field (value . into ()) } } impl < Out > surreal_orm :: SetterAssignable < LinkOne < Out > > for self :: __Out__ { } impl < Out > surreal_orm :: Patchable < LinkOne < Out > > for self :: __Out__ { } # [derive (Debug , Clone)] pub struct __Course__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __Course__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __Course__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __Course__ > for surreal_orm :: ValueLike { fn from (value : & __Course__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __Course__ > for surreal_orm :: ValueLike { fn from (value : __Course__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __Course__ > for surreal_orm :: Field { fn from (field_name : & __Course__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __Course__ > for surreal_orm :: Field { fn from (field_name : __Course__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __Course__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __Course__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __Course__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __Course__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __Course__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __Course__) -> Self { Self :: Field (value . into ()) } } impl surreal_orm :: SetterAssignable < LinkOne < Book > > for self :: __Course__ { } impl surreal_orm :: Patchable < LinkOne < Book > > for self :: __Course__ { } # [derive (Debug , Clone)] pub struct __FieldNother__ (pub surreal_orm :: Field) ; impl :: std :: convert :: From < & str > for __FieldNother__ { fn from (field_name : & str) -> Self { Self (surreal_orm :: Field :: new (field_name)) } } impl :: std :: convert :: From < surreal_orm :: Field > for __FieldNother__ { fn from (field_name : surreal_orm :: Field) -> Self { Self (field_name) } } impl :: std :: convert :: From < & __FieldNother__ > for surreal_orm :: ValueLike { fn from (value : & __FieldNother__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < __FieldNother__ > for surreal_orm :: ValueLike { fn from (value : __FieldNother__) -> Self { let field : surreal_orm :: Field = value . into () ; field . into () } } impl :: std :: convert :: From < & __FieldNother__ > for surreal_orm :: Field { fn from (field_name : & __FieldNother__) -> Self { field_name . 0 . clone () } } impl :: std :: convert :: From < __FieldNother__ > for surreal_orm :: Field { fn from (field_name : __FieldNother__) -> Self { field_name . 0 } } impl :: std :: ops :: Deref for __FieldNother__ { type Target = surreal_orm :: Field ; fn deref (& self) -> & Self :: Target { & self . 0 } } impl :: std :: ops :: DerefMut for __FieldNother__ { fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < self :: __FieldNother__ > for surreal_orm :: SetterArg < T > { fn from (value : self :: __FieldNother__) -> Self { Self :: Field (value . into ()) } } impl < T : surreal_orm :: serde :: Serialize > :: std :: convert :: From < & self :: __FieldNother__ > for surreal_orm :: SetterArg < T > { fn from (value : & self :: __FieldNother__) -> Self { Self :: Field (value . into ()) } } impl surreal_orm :: SetterAssignable < LinkMany < Book > > for self :: __FieldNother__ { } impl surreal_orm :: Patchable < LinkMany < Book > > for self :: __FieldNother__ { } impl surreal_orm :: SetterArray < < Book as surreal_orm :: Model > :: Id > for self :: __FieldNother__ { } } pub mod _____schema_def { use super :: _____field_names ; use super :: super :: * ; # [allow (non_snake_case)] # [derive (Debug , Clone)] pub struct __Schema__ < In , Out > { pub id : _____field_names :: __Id__ , pub duration_of_write : _____field_names :: __DurationOfWrite__ , pub r#in : _____field_names :: __In__ , pub out : _____field_names :: __Out__ , pub course : _____field_names :: __Course__ , pub field_nother : _____field_names :: __FieldNother__ , pub (super) ___________graph_traversal_string : :: std :: string :: String , pub (super) ___________bindings : surreal_orm :: BindingsList , pub (super) ___________errors : :: std :: vec :: Vec < :: std :: string :: String > , pub (super) _____struct_marker_ident : :: std :: marker :: PhantomData < (In , Out) > , } } pub type Writes < In , Out > = _____schema_def :: __Schema__ < In , Out > ; impl < In , Out > surreal_orm :: Buildable for Writes < In , Out > { fn build (& self) -> :: std :: string :: String { self . ___________graph_traversal_string . to_string () } } impl < In , Out > surreal_orm :: Parametric for Writes < In , Out > { fn get_bindings (& self) -> surreal_orm :: BindingsList { self . ___________bindings . to_vec () } } impl < In , Out > surreal_orm :: Erroneous for Writes < In , Out > { fn get_errors (& self) -> :: std :: vec :: Vec < :: std :: string :: String > { self . ___________errors . to_vec () } } impl < In , Out > surreal_orm :: Aliasable for Writes < In , Out > { } impl < In , Out > surreal_orm :: Parametric for & Writes < In , Out > { fn get_bindings (& self) -> surreal_orm :: BindingsList { self . ___________bindings . to_vec () } } impl < In , Out > surreal_orm :: Buildable for & Writes < In , Out > { fn build (& self) -> :: std :: string :: String { self . ___________graph_traversal_string . to_string () } } impl < In , Out > surreal_orm :: Erroneous for & Writes < In , Out > { fn get_errors (& self) -> :: std :: vec :: Vec < :: std :: string :: String > { self . ___________errors . to_vec () } } impl < In , Out > Writes < In , Out > { pub fn new () -> Self { Self { id : \"id\" . into () , duration_of_write : \"duration_of_write\" . into () , r#in : \"in\" . into () , out : \"out\" . into () , course : \"course\" . into () , field_nother : \"field_nother\" . into () , ___________graph_traversal_string : \"\" . into () , ___________bindings : :: std :: vec ! [] , ___________errors : :: std :: vec ! [] , _____struct_marker_ident : :: std :: marker :: PhantomData , } } pub fn new_prefixed (prefix : impl :: std :: convert :: Into < surreal_orm :: ValueLike >) -> Self { let prefix : surreal_orm :: ValueLike = prefix . into () ; Self { id : surreal_orm :: Field :: new (format ! (\"{}.{}\" , prefix . build () , \"id\")) . with_bindings (prefix . get_bindings ()) . into () , duration_of_write : surreal_orm :: Field :: new (format ! (\"{}.{}\" , prefix . build () , \"duration_of_write\")) . with_bindings (prefix . get_bindings ()) . into () , r#in : surreal_orm :: Field :: new (format ! (\"{}.{}\" , prefix . build () , \"in\")) . with_bindings (prefix . get_bindings ()) . into () , out : surreal_orm :: Field :: new (format ! (\"{}.{}\" , prefix . build () , \"out\")) . with_bindings (prefix . get_bindings ()) . into () , course : surreal_orm :: Field :: new (format ! (\"{}.{}\" , prefix . build () , \"course\")) . with_bindings (prefix . get_bindings ()) . into () , field_nother : surreal_orm :: Field :: new (format ! (\"{}.{}\" , prefix . build () , \"field_nother\")) . with_bindings (prefix . get_bindings ()) . into () , ___________graph_traversal_string : prefix . build () , ___________bindings : prefix . get_bindings () , ___________errors : :: std :: vec ! [] , _____struct_marker_ident : :: std :: marker :: PhantomData , } } pub fn empty () -> Self { Self { id : \"\" . into () , duration_of_write : \"\" . into () , r#in : \"\" . into () , out : \"\" . into () , course : \"\" . into () , field_nother : \"\" . into () , ___________graph_traversal_string : \"\" . into () , ___________bindings : :: std :: vec ! [] , ___________errors : :: std :: vec ! [] , _____struct_marker_ident : :: std :: marker :: PhantomData , } } pub fn __________connect_edge_to_graph_traversal_string (connection : impl surreal_orm :: Buildable + surreal_orm :: Parametric + surreal_orm :: Erroneous , clause : impl :: std :: convert :: Into < surreal_orm :: EdgeClause > ,) -> Self { let mut schema_instance = Self :: empty () ; let clause : surreal_orm :: EdgeClause = clause . into () ; let bindings = [connection . get_bindings () . as_slice () , clause . get_bindings () . as_slice ()] . concat () ; let bindings = bindings . as_slice () ; schema_instance . ___________bindings = bindings . into () ; let errors = [connection . get_errors () . as_slice () , clause . get_errors () . as_slice ()] . concat () ; let errors = errors . as_slice () ; schema_instance . ___________errors = errors . into () ; let schema_edge_str_with_arrow = format ! (\"{}{}\" , connection . build () , clause . build () ,) ; schema_instance . ___________graph_traversal_string . push_str (schema_edge_str_with_arrow . as_str ()) ; let ___________graph_traversal_string = & schema_instance . ___________graph_traversal_string ; schema_instance . id = schema_instance . id . set_graph_string (format ! (\"{}.{}\" , ___________graph_traversal_string , \"id\")) . ____________update_many_bindings (bindings) . into () ; schema_instance . duration_of_write = schema_instance . duration_of_write . set_graph_string (format ! (\"{}.{}\" , ___________graph_traversal_string , \"duration_of_write\")) . ____________update_many_bindings (bindings) . into () ; schema_instance . r#in = schema_instance . r#in . set_graph_string (format ! (\"{}.{}\" , ___________graph_traversal_string , \"in\")) . ____________update_many_bindings (bindings) . into () ; schema_instance . out = schema_instance . out . set_graph_string (format ! (\"{}.{}\" , ___________graph_traversal_string , \"out\")) . ____________update_many_bindings (bindings) . into () ; schema_instance . course = schema_instance . course . set_graph_string (format ! (\"{}.{}\" , ___________graph_traversal_string , \"course\")) . ____________update_many_bindings (bindings) . into () ; schema_instance . field_nother = schema_instance . field_nother . set_graph_string (format ! (\"{}.{}\" , ___________graph_traversal_string , \"field_nother\")) . ____________update_many_bindings (bindings) . into () ; schema_instance } pub fn course (& self) -> Book { let clause = surreal_orm :: Clause :: from (surreal_orm :: Empty) ; let normalized_field_name_str = if self . build () . is_empty () { \"course\" } else { \".course\" } ; Book :: __________connect_node_to_graph_traversal_string (self , clause . with_field (normalized_field_name_str)) } pub fn field_nother (& self , clause : impl :: std :: convert :: Into < surreal_orm :: NodeAliasClause >) -> Book { let clause : surreal_orm :: NodeAliasClause = clause . into () ; let clause : surreal_orm :: NodeClause = clause . into_inner () ; let db_field_name = if self . build () . is_empty () { \"field_nother\" . to_string () } else { format ! (\".{}\" , \"field_nother\") } ; Book :: __________connect_node_to_graph_traversal_string (self , clause . with_field (db_field_name)) } } } # [allow (non_snake_case)] # [allow (unreachable_code)] fn _________test_________internal_writes_schema_static_funcs_name__________ < In , Out > () { surreal_orm :: validators :: assert_type_is_thing :: < SurrealSimpleId < Writes < In , Out > > > () ; surreal_orm :: validators :: assert_type_is_duration :: < Duration > () ; surreal_orm :: validators :: assert_type_is_link_one :: < LinkOne < In > > () ; surreal_orm :: validators :: assert_type_is_link_one :: < LinkOne < Out > > () ; surreal_orm :: validators :: assert_type_eq_all ! (LinkOne < Book > , surreal_orm :: LinkOne < Book >) ; surreal_orm :: validators :: assert_impl_one ! (Book : surreal_orm :: Node) ; surreal_orm :: validators :: assert_type_eq_all ! (LinkMany < Book > , surreal_orm :: LinkMany < Book >) ; surreal_orm :: validators :: assert_impl_one ! (Book : surreal_orm :: Node) ; }"

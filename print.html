<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Surreal ORM</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Surreal ORM</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><img src="./assets/concept.svg" alt="The Rust Logo" /></p>
<p>The landscape of software development is both vast and intricate, dotted with
countless tools and frameworks that rise as answers to the ever-present
challenges faced by developers. Yet, amidst this vastness, finding a tool that
truly resonates with one's philosophies can be like searching for a needle in a
haystack. Such was the experience that led to the creation of <code>surreal_orm</code>.</p>
<p>After delving into over ten ORM solutions in Rust alone and journeying through
more than twenty across languages such as TypeScript, Python, Java, Ruby,
Elixir, and more, it became starkly evident: while many tools cater to the basic
needs, very few strike the harmonious chord of simplicity, power, and
expressiveness. This realization wasn't just a mere observation—it was the
catalyst that inspired <code>surreal_orm</code>.</p>
<p>This book is not just an introduction to an ORM library; it's a narrative of a
journey, a testament to a set of deeply-held philosophies, and an exploration of
groundbreaking innovations:</p>
<ol>
<li>
<p><strong>Expressive Yet Intuitive API</strong>: Traditional ORMs often make complex queries
convoluted and unreadable. <code>surreal_orm</code> challenges this norm. At the heart
of <code>surreal_orm</code> lies an unwavering commitment to clarity. The belief is
straightforward: if a query can be articulated in raw string format, it
should be just as elegantly expressible within the ORM. This ensures that
even as queries grow intricate, they remain legible, empowering developers to
write intuitive code without sacrificing capability.</p>
</li>
<li>
<p><strong>Compile-Time Excellence</strong>: Harnessing the full might of Rust's compile-time
error checking, surreal_orm emphasizes robustness from the onset. From model
declarations to query constructions, the goal is to catch potential pitfalls
even before the code springs to life. And in scenarios where compile-time
checks aren't feasible, surreal_orm employs meticulous runtime validations,
standing as a testament to its commitment to reliability and safety.</p>
</li>
<li>
<p><strong>Pioneering Features</strong>: <code>surreal_orm</code> introduces pioneering ideas that set
it apart. From innovative macros such as <code>block!</code>, <code>transaction</code>, <code>object!</code>,
<code>object_partial!</code>, and <code>cond!</code>, to compile-time validations of graph
structures, and advanced features like deep graph access and
auto-parametrized mathematical expressions—these are just a glimpse of the
groundbreaking capabilities you'll encounter.</p>
</li>
<li>
<p><strong>Full Specification Support</strong>: Beyond its intuitive design and innovative
features, <code>surreal_orm</code> stands tall with its comprehensive support for the
full specification. It's not just another ORM or query builder; it's a beacon
of compliance and expressiveness in the ORM landscape.</p>
</li>
</ol>
<p>As you delve deeper into these pages, you'll journey beyond the mechanics,
delving into the essence of <code>surreal_orm</code>—understanding its origins, the
problems it seeks to solve, and the philosophies that molded its creation. It's
a tale of refusing to settle, of reimagining boundaries, and of sculpting a
solution when none seemed just right.</p>
<p>Each chapter, carefully crafted by the very creator of <code>surreal_orm</code>, promises a
deep dive into its intricacies, philosophies, and innovations. So, whether
you're a seasoned Rust developer, an ORM enthusiast, or a curious soul eager to
explore the intersections of innovation and software development, this book
promises a voyage into the heart of data management with a fresh perspective in
Rust—a realm where convention meets innovation, culminating in the creation of
something truly surreal.</p>
<p>-- © Oyelowo Oyedayo, 2023.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<h1 id="surreal-orm-documentation"><a class="header" href="#surreal-orm-documentation">Surreal ORM Documentation</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Surreal ORM is an Object-Relational Mapping and query-building library for Rust
that provides a high-level API for interacting with SurrealDB, a distributed
graph database. This documentation will guide you through the usage and features
of the Surreal ORM library.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>To use Surreal ORM in your Rust project, you need to add it as a dependency in
your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
surreal_orm = "https://github.com/Oyelowo/surreal_orm"
</code></pre>
<p>After adding the dependency, you can import the necessary modules in your Rust
code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::*;
<span class="boring">}</span></code></pre></pre>
<h2 id="connecting-to-surrealdb"><a class="header" href="#connecting-to-surrealdb">Connecting to SurrealDB</a></h2>
<p>Before interacting with SurrealDB, you need to establish a connection to the
database. The following example demonstrates how to create a connection to a
local SurrealDB instance:</p>
<pre><pre class="playground"><code class="language-rust">use surrealdb::engine::local::Mem;
use surrealdb::Surreal;

#[tokio::main]
async fn main() {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
}</code></pre></pre>
<p>In this example, we create a new SurrealDB instance using the <code>Surreal::new</code>
function with the <code>local::Mem</code> engine. The <code>local::Mem</code> engine represents a
local in-memory database. You can replace it with other engine types according
to your setup.</p>
<h2 id="defining-a-model"><a class="header" href="#defining-a-model">Defining a Model</a></h2>
<p>A model in Surreal ORM represents a database table. You can define a model by
creating a Rust struct and implementing the <code>Node</code> or <code>Edge</code> trait. Here's an example of
defining a <code>SpaceShip</code> model:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::*;

#[derive(Node, Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
#[orm(table = space_ship)]
pub struct SpaceShip {
    pub id: SurrealSimpleId&lt;Self&gt;,
    pub name: String,
    pub age: u8,
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, we define a <code>SpaceShip</code> struct and annotate it with the <code>Model</code>
derive macro. The <code>table</code> attribute specifies the name of the corresponding
database table.</p>
<h2 id="querying-data"><a class="header" href="#querying-data">Querying Data</a></h2>
<p>Surreal ORM provides a fluent and expressive API for querying data from the
database. You can use the <code>select</code> function to start a select statement and
chain various methods to build the query. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::statements::{select, All};

let space_ship::Schema { name, age, .. } = SpaceShip::schema();

let statement = select(All)
    .from(space_ship)
    .where_(name.equal("Millennium Falcon"))
    .order_by(age.desc())
    .limit(10);
<span class="boring">}</span></code></pre></pre>
<p>In this example, we start a select statement using the <code>select</code> function and
pass the <code>All</code> argument to select all fields. We specify the table name using
the <code>from</code> method and add a condition using the <code>where_</code> method. We can also use
the <code>order_by</code> method to specify the sorting order and the <code>limit</code> method to
limit the number of results.</p>
<h2 id="inserting-data"><a class="header" href="#inserting-data">Inserting Data</a></h2>
<p>To insert data into the database, you can use the <code>insert</code> function and provide
the data as a vector of structs. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::statements::insert;

let spaceships = vec![
    SpaceShip {
        id: "1".to_string(),
        name: "Millennium Falcon".to_string(),
        age: 79,
    },
    SpaceShip {
        id: "2".to_string(),
        name: "Starship Enterprise".to_string(),
        age: 15,
    },
];

insert(spaceships).return_many(db.clone()).await?;
<span class="boring">}</span></code></pre></pre>
<p>In this example, we define a vector of <code>SpaceShip</code> structs and pass it to the
<code>insert</code> function. We then call the <code>run</code> method to execute the insertion
operation.</p>
<h2 id="updating-data"><a class="header" href="#updating-data">Updating Data</a></h2>
<p>To update data in the database, you can use the <code>update</code> function and provide
the updated data as a struct. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::statements::update;

let spaceship = SpaceShip {
    id: "1".to_string(),
    name: "Millennium Falcon".to_string(),
    age: 60
};

update(spaceship).run(db.clone()).await?;
<span class="boring">}</span></code></pre></pre>
<p>In this example, we define a <code>SpaceShip</code> struct with the updated data and pass
it to the <code>update</code> function. We then call the <code>run</code> method to execute the update
operation.</p>
<h2 id="deleting-data"><a class="header" href="#deleting-data">Deleting Data</a></h2>
<p>To delete data from the database, you can use the <code>delete</code> function and provide
the condition for deletion. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::statements::{delete, Field};

let space_ship::Schema { name, age, .. } = SpaceShip::schema();
let condition = name.eq("Millennium Falcon");

delete(space_ship)
    .where_(cond(name.equal("Millennium Falcon")).and(age.less_then(50)))
    .run(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>In this example, we use the <code>delete</code> function and specify the table name as a
string. We add a condition using the <code>where_</code> method, and then call the <code>run</code>
method to execute the deletion operation.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This concludes the basic usage and features of the Surreal ORM library. You can
explore more advanced features and methods in the API documentation. If you have
any further questions or need assistance, feel free to reach out.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparision"><a class="header" href="#comparision">Comparision</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="date-model"><a class="header" href="#date-model">Date Model</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<h1 id="data-model-in-surreal_orm"><a class="header" href="#data-model-in-surreal_orm">Data Model in <code>surreal_orm</code></a></h1>
<p>In the <code>surreal_orm</code>, developers are provided with a comprehensive data model
that mirrors the specifications laid out by the SurrealDB documentation. This
ensures seamless integration with SurrealDB while also extending the
capabilities to cater to more advanced use cases, such as supporting diverse
value types in one unified representation.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="data_models/data_types.html#overview">Overview</a></li>
<li><a href="data_models/data_types.html#record-ids">Record IDs</a></li>
<li><a href="data_models/data_types.html#basic-types">Basic Types</a>
<ul>
<li><a href="data_models/data_types.html#strings">Strings</a></li>
<li><a href="data_models/data_types.html#numbers">Numbers</a></li>
<li><a href="data_models/data_types.html#datetimes">Datetimes</a></li>
<li><a href="data_models/data_types.html#objects">Objects</a></li>
<li><a href="data_models/data_types.html#arrays">Arrays</a></li>
<li><a href="data_models/data_types.html#geometries">Geometries</a></li>
</ul>
</li>
<li><a href="data_models/data_types.html#record-links">Record Links</a></li>
</ol>
<hr />
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The data model in <code>surreal_orm</code> allows for a flexible representation of
different data types. By utilizing structures such as <code>ValueType</code>, the ORM can
represent a wide array of types from basic values, fields, parameters, to
complex operations and statements.</p>
<h2 id="record-ids"><a class="header" href="#record-ids">Record IDs</a></h2>
<p>While the official SurrealDB documentation might detail how unique identifiers
are managed for records, the ORM's handling of this might be implicit or handled
in a way that abstracts the details away from the developer. You can read more
on a dedicated chapter to <code>Surreal Id</code> where an abstraction is created to make
it a easier, more intuitive and consistent to work with record ids in surrealdb.</p>
<h2 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h2>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>In <code>surreal_orm</code>, strings are represented using the <code>StrandLike</code> structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct StrandLike(..);
<span class="boring">}</span></code></pre></pre>
<p>This struct can be used to represent a string value, field, or parameter,
allowing it to be seamlessly integrated into various parts of a query.</p>
<h3 id="numbers"><a class="header" href="#numbers">Numbers</a></h3>
<p>Numbers are represented using the <code>NumberLike</code> structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NumberLike(..);
<span class="boring">}</span></code></pre></pre>
<p>Like <code>StrandLike</code>, it can be used to represent a numeric value, field, or
parameter in a query.</p>
<h3 id="datetimes"><a class="header" href="#datetimes">Datetimes</a></h3>
<p>Datetimes are encapsulated using the <code>DatetimeLike</code> structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DatetimeLike(..);
<span class="boring">}</span></code></pre></pre>
<p>This allows for a clear representation of date and time values within the ORM.</p>
<h3 id="objects"><a class="header" href="#objects">Objects</a></h3>
<p>Objects are complex data types that encapsulate key-value pairs. They are
represented in <code>surreal_orm</code> using the <code>ObjectLike</code> structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ObjectLike(..);
<span class="boring">}</span></code></pre></pre>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>Arrays, which can contain multiple items of the same type, are represented using
the <code>ArrayLike</code> structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ArrayLike(..);
<span class="boring">}</span></code></pre></pre>
<p>And for function arguments, the <code>ArgsList</code> structure is used:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ArgsList(..);
<span class="boring">}</span></code></pre></pre>
<h3 id="geometries"><a class="header" href="#geometries">Geometries</a></h3>
<p>Geometries, which might represent spatial data, are encapsulated in the
<code>GeometryLike</code> structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GeometryLike(..);
<span class="boring">}</span></code></pre></pre>
<h2 id="record-links"><a class="header" href="#record-links">Record Links</a></h2>
<p>While the provided code does not show explicit handling for record links, it can
be inferred that such links could be represented using <code>SurrealId</code> types.</p>
<hr />
<p>This is a foundational overview of the data model in <code>surreal_orm</code>, with the aim
of mirroring the SurrealDB specifications. The ORM extends the basic data types
to provide a richer experience, supporting various operations and query
constructs seamlessly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future"><a class="header" href="#future">Future</a></h1>
<p>In <code>surrealdb</code>, futures provide a powerful mechanism to compute dynamic values
when data is selected and returned to the client. Essentially, a future is a
type of cast function that enables values to be dynamically evaluated upon
retrieval.</p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<ol>
<li><a href="data_models/future.html#introduction-to-futures">Introduction to Futures</a></li>
<li><a href="data_models/future.html#simple-futures">Simple Futures</a></li>
<li><a href="data_models/future.html#futures-depending-on-other-fields">Futures Depending on Other Fields</a></li>
<li><a href="data_models/future.html#advanced-usage-of-futures">Advanced Usage of Futures</a></li>
</ol>
<hr />
<h2 id="introduction-to-futures"><a class="header" href="#introduction-to-futures">Introduction to Futures</a></h2>
<p>Futures are a unique feature of SurrealDB that allows for dynamic computation of
values. Instead of storing a static value within a record, futures compute the
value dynamically whenever the record is accessed. This ensures that you always
get the most recent and relevant data.</p>
<h2 id="simple-futures"><a class="header" href="#simple-futures">Simple Futures</a></h2>
<p>Any value or expression can be wrapped inside a future, ensuring it's evaluated
upon every access.</p>
<p>** Example **</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = create().set(object!(Person {
    accessed_date: future(time::now!())
});
assert_eq!(result.build(), "CREATE person SET accessed_date = &lt;future&gt; { time::now() }");
<span class="boring">}</span></code></pre></pre>
<h2 id="futures-depending-on-other-fields"><a class="header" href="#futures-depending-on-other-fields">Futures Depending on Other Fields</a></h2>
<p>Futures can also compute values based on other fields in the record. This allows
for dynamic calculations that reflect the latest state of the record.</p>
<p>** Example **</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let birthday = Person::schema().birthday;
let eighteen_years = Duration::from_secs(60 * 60 * 24 * 7 * 365 * 18);
let date_of_birth = chrono::Date::MIN_UTC;

let can_drive = future("time::now() &gt; birthday + 18y");
let result = create().set(object!(Person {
    birthday: date_of_birth,
    can_drive: future(time::now!().gt(birthday).plus(eighteen_years))
}));
assert_eq!(result.build(), "CREATE person SET birthday = 2007-06-22, can_drive = &lt;future&gt; { time::now() &gt; birthday + 18y }");
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-usage-of-futures"><a class="header" href="#advanced-usage-of-futures">Advanced Usage of Futures</a></h2>
<p>Futures offer much more than just simple dynamic calculations. They can
dynamically access remote records, execute subqueries, and even traverse graphs.</p>
<p>** Example **</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let friends = Person::schema().friends;
let id1 = Person::create_id("dayo");
let id2 = Person::create_id("yelow");
let friends = Person::schema().friends;

let result = create().set(object!(Person {
    name: String::from("Oyelowo"),
    friends: vec![id1, id2],
    adult_friends: future(friends(cond(age.gt(18))).name),
}));
assert_eq!(result.build(), "CREATE person SET name = 'Oyelowo', friends = [person:dayo, person:yelow], adult_friends = &lt;future&gt; { friends[WHERE age &gt; 18].name }");
<span class="boring">}</span></code></pre></pre>
<hr />
<p>Utilizing futures in <code>surreal_orm</code> provides a dynamic layer to your data,
ensuring that you always receive the most up-to-date calculations and
evaluations when querying your records. Whether you're calculating age, fetching
related records, or even performing complex graph operations, futures have got
you covered.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="casting"><a class="header" href="#casting">Casting</a></h1>
<p>Casting is an indispensable tool in data management, allowing developers to
convert values from one type to another. This chapter provides an in-depth look
into the casting functionality provided by <code>surreal_orm</code>, illuminating its
power, elegance, and strict adherence to the SurrealDB specifications.</p>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<ol>
<li><a href="data_models/casting.html#introduction-to-casting">Introduction to Casting</a></li>
<li><a href="data_models/casting.html#the-cast-structure-in-surreal_orm">The <code>Cast</code> Structure in <code>surreal_orm</code></a></li>
<li><a href="data_models/casting.html#cast-functions">Cast Functions</a>
<ul>
<li><a href="data_models/casting.html#casting-to-boolean">Casting to Boolean</a></li>
<li><a href="data_models/casting.html#casting-to-integer">Casting to Integer</a></li>
<li><a href="data_models/casting.html#casting-to-float">Casting to Float</a></li>
<li><a href="data_models/casting.html#casting-to-string">Casting to String</a></li>
<li><a href="data_models/casting.html#casting-to-number">Casting to Number</a></li>
<li><a href="data_models/casting.html#casting-to-decimal">Casting to Decimal</a></li>
<li><a href="data_models/casting.html#casting-to-datetime">Casting to DateTime</a></li>
<li><a href="data_models/casting.html#casting-to-duration">Casting to Duration</a></li>
</ul>
</li>
<li><a href="data_models/casting.html#conclusion">Conclusion</a></li>
</ol>
<hr />
<h2 id="introduction-to-casting"><a class="header" href="#introduction-to-casting">Introduction to Casting</a></h2>
<p>In programming, casting is the practice of converting variables from one type to
another, enabling more flexible data manipulation. Whether receiving input from
a user, reading data from a file, or interfacing with databases, casting becomes
a pivotal component.</p>
<h3 id="casting-to-boolean"><a class="header" href="#casting-to-boolean">Casting to Boolean</a></h3>
<p>This function converts a value into a boolean. In raw queries, it's represented
as <code>&lt;bool&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = bool("true");
assert_eq!(result.build(), "&lt;bool&gt; true");
<span class="boring">}</span></code></pre></pre>
<h3 id="casting-to-integer"><a class="header" href="#casting-to-integer">Casting to Integer</a></h3>
<p>Convert a value into an integer. In raw queries, it's represented by <code>&lt;int&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = int(13.572948467293847293841093845679289);
assert_eq!(result.build(), "&lt;int&gt; 13");
<span class="boring">}</span></code></pre></pre>
<h3 id="casting-to-float"><a class="header" href="#casting-to-float">Casting to Float</a></h3>
<p>Convert a value into a floating point number. In raw queries, it's represented
by <code>&lt;float&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = float(13.572948467293847293841093845679289);
assert_eq!(result.build(), "&lt;float&gt; 13.572948467293847");
<span class="boring">}</span></code></pre></pre>
<h3 id="casting-to-string"><a class="header" href="#casting-to-string">Casting to String</a></h3>
<p>Convert a value into a string. In raw queries, it's represented by <code>&lt;string&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = string(true);
assert_eq!(result.build(), "&lt;string&gt; true");
<span class="boring">}</span></code></pre></pre>
<h3 id="casting-to-number"><a class="header" href="#casting-to-number">Casting to Number</a></h3>
<p>Convert a value into an infinite precision decimal number. In raw queries, it's
represented by <code>&lt;number&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = number(13.572948467293847293841093845679289);
assert_eq!(result.build(), "&lt;number&gt; 13.572948467293847293841093845679289");
<span class="boring">}</span></code></pre></pre>
<h3 id="casting-to-decimal"><a class="header" href="#casting-to-decimal">Casting to Decimal</a></h3>
<p>Convert a value into an infinite precision decimal number. In raw queries, it's
represented by <code>&lt;decimal&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = decimal(13.572948467293847293841093845679289);
assert_eq!(result.build(), "&lt;decimal&gt; 13.572948467293847293841093845679289");
<span class="boring">}</span></code></pre></pre>
<h3 id="casting-to-datetime"><a class="header" href="#casting-to-datetime">Casting to DateTime</a></h3>
<p>Convert a value into a datetime. In raw queries, it's represented by
<code>&lt;datetime&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = datetime("2022-06-07 will be parsed");
assert_eq!(result.build(), "&lt;datetime&gt; 2022-06-07");
<span class="boring">}</span></code></pre></pre>
<h3 id="casting-to-duration"><a class="header" href="#casting-to-duration">Casting to Duration</a></h3>
<p>Convert a value into a duration. In raw queries, it's represented by
<code>&lt;duration&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = duration("1h30m will be parsed");
assert_eq!(result.build(), "&lt;duration&gt; 1h30m");
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>Surreal Orm presents a powerful and user-friendly approach to casting, adhering
closely to SurrealDB standards. Whether you're an experienced Rust developer or
just starting, surreal_orm provides the tools for precise and effortless data
manipulation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model"><a class="header" href="#model">Model</a></h1>
<p>In Surreal, a Model represents a blueprint of your data model consisting of
various Nodes and Edges. A Model is a collection of various Nodes (entities) and
their relationships (Edges), providing a comprehensive view of your data.</p>
<p>The Object struct is used to define a Model, and it has its own set of struct
and field attributes. For instance, the <code>rename_all</code> struct attribute lets you
define a case convention for all the fields in the Model. And the <code>rename</code> field
attribute allows you to specify a different name for a field.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node"><a class="header" href="#node">Node</a></h1>
<p>In Surreal, your database is represented using Nodes, Edges, and Objects:</p>
<ul>
<li>
<p>Nodes: These correspond to database tables, defined as Rust structs
implementing the <code>Node</code> trait. Nodes can link to other Nodes and incorporate
Objects for complex nested data structures.</p>
</li>
<li>
<p>Edges: Edges represent relationships between Nodes and are used for modeling
many-to-many relationships or storing additional information about the
relationship itself.</p>
</li>
<li>
<p>Objects: These are complex nested data structures embedded within Nodes. While
they don't represent standalone tables, they facilitate complex data modeling
within a Node.</p>
</li>
</ul>
<p>Nodes are the heart of your database model in Surreal. They're Rust structs
decorated with <code>Node</code> attributes for overall configuration and field-specific
attributes for property definition. There are three types of links that you can
use to define relationships between Nodes: <code>LinkSelf</code>, <code>LinkOne</code>, and
<code>LinkMany</code>.</p>
<ul>
<li>
<p><code>LinkSelf</code>: This is a self-referential link within the same Node (table). For
example, if an <code>Alien</code> can be friends with other aliens, you would use
<code>LinkSelf</code>.</p>
</li>
<li>
<p><code>LinkOne</code>: This creates a one-to-one relationship between two different Nodes.
If every <code>Alien</code> has exactly one <code>Weapon</code>, you would use <code>LinkOne</code>.</p>
</li>
<li>
<p><code>LinkMany</code>: This creates a one-to-many relationship between two Nodes. If an
<code>Alien</code> can have multiple <code>SpaceShip</code>s, you would use <code>LinkMany</code>.</p>
</li>
</ul>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use surreal_orm::{LinkMany, LinkOne, LinkSelf, SurrealSimpleId, Node};

#[derive(Node, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
#[orm(table = "alien")]
pub struct Alien {
    pub id: SurrealSimpleId&lt;Self&gt;,

    #[orm(link_self = "Alien")]
    pub friend: LinkSelf&lt;Alien&gt;,

    #[orm(link_one = "Weapon")]
    pub weapon: LinkOne&lt;Weapon&gt;,

    #[orm(link_many = "SpaceShip")]
    pub space_ships: LinkMany&lt;SpaceShip&gt;,
}

#[derive(Node, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
#[orm(table = "weapon")]
pub struct Weapon {
    pub id: SurrealSimpleId&lt;Self&gt;,
    pub name: String,
    pub strength: u64,
}

#[derive(Node, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[orm(table = "space_ship")]
pub struct SpaceShip {
    pub id: SurrealId&lt;Self, String&gt;,
    pub name: String,
    pub created: DateTime&lt;Utc&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>In this <code>Alien</code> Node, an alien can have an friend (another alien), a weapon
(one-to-one relationship with <code>Weapon</code> Node), and multiple spaceships
(one-to-many relationship with <code>SpaceShip</code> Node).</p>
<p>In summary, Nodes in Surreal provide a powerful way to model your database
schema directly in Rust, with type safety, automatic
serialization/deserialization, and the ability to define complex relationships
between different tables.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-attributes-on-struct"><a class="header" href="#node-attributes-on-struct">Node Attributes on Struct</a></h1>
<p>In Surreal ORM, node attributes provide a convenient mechanism to dictate the
behavior and structure of database tables and their associated fields. These
attributes are not only powerful tools for developers but also help in
maintaining a consistent and clear database schema. This chapter will delve into
the intricacies of node attributes, their application, and best practices for
their usage.</p>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of Contents</a></h2>
<ol>
<li><a href="concepts/node_struct_attributes.html#introduction-to-node-attributes">Introduction to Node Attributes</a></li>
<li><a href="concepts/node_struct_attributes.html#working-with-node-attributes">Working with Node Attributes</a>
<ul>
<li><a href="concepts/node_struct_attributes.html#supported-table-attributes">Supported Table Attributes</a></li>
</ul>
</li>
<li><a href="concepts/node_struct_attributes.html#node-attributes-examples">Node Attributes: Examples</a>
<ul>
<li><a href="concepts/node_struct_attributes.html#auto-inferred-table-name">Auto-Inferred Table Name</a></li>
<li><a href="concepts/node_struct_attributes.html#explicit-table-name">Explicit Table Name</a></li>
<li><a href="concepts/node_struct_attributes.html#using-define-for-inline-table-definition">Using <code>define</code> for Inline Table Definition</a></li>
<li><a href="concepts/node_struct_attributes.html#using-define_fn-for-external-function-definition">Using <code>define_fn</code> for External Function Definition</a></li>
<li><a href="concepts/node_struct_attributes.html#specifying-permissions">Specifying Permissions</a></li>
</ul>
</li>
<li><a href="concepts/node_struct_attributes.html#ensuring-valid-usage-of-node-attributes">Ensuring Valid Usage of Node Attributes</a>
<ul>
<li><a href="concepts/node_struct_attributes.html#conflicting-definitions">Conflicting Definitions</a></li>
<li><a href="concepts/node_struct_attributes.html#avoid-excessive-attributes-with-define-or-define_fn">Avoid Excessive Attributes with <code>define</code> or <code>define_fn</code></a></li>
<li><a href="concepts/node_struct_attributes.html#consistent-table-naming">Consistent Table Naming</a></li>
<li><a href="concepts/node_struct_attributes.html#using-functions-for-attributes">Using Functions for Attributes</a></li>
</ul>
</li>
<li><a href="concepts/node_struct_attributes.html#conclusion">Conclusion</a></li>
</ol>
<hr />
<h2 id="introduction-to-node-attributes"><a class="header" href="#introduction-to-node-attributes">Introduction to Node Attributes</a></h2>
<p>Node attributes in Surreal ORM allow developers to:</p>
<ul>
<li>Rename fields of a struct according to a naming convention.</li>
<li>Explicitly set or infer the table name.</li>
<li>Enforce schema structures.</li>
<li>Handle table drops and recreations.</li>
<li>Create table projections or views.</li>
<li>Set granular permissions for CRUD operations on tables.</li>
<li>Define the table structure either inline or through external functions.</li>
</ul>
<h2 id="working-with-node-attributes"><a class="header" href="#working-with-node-attributes">Working with Node Attributes</a></h2>
<h3 id="supported-table-attributes"><a class="header" href="#supported-table-attributes">Supported table attributes</a></h3>
<h2 id="struct-attributes"><a class="header" href="#struct-attributes">Struct Attributes</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Description</th><th>Type</th><th>Optional</th></tr></thead><tbody>
<tr><td>rename_all</td><td>Renames all the struct's fields according to the given case convention. The possible values are "lowercase", "UPPERCASE", "PascalCase", "camelCase", "snake_case", "SCREAMING_SNAKE_CASE".</td><td>string</td><td>Y</td></tr>
<tr><td>table</td><td>Explicitly define the table name. By default, it must correspond with the struct name in snake_case. Use <code>relax_table</code> if you want to opt out of this but not encouraged.</td><td>Option<String></td><td>Y</td></tr>
<tr><td>relax_table</td><td>Determines whether the struct's name is matched to the table name as the snake case by default. This is not encouraged. Using your struct 1:1 to your database tables helps to ensure uniquness and prevent confusion.</td><td>Option<bool></td><td>Y</td></tr>
<tr><td>schemafull</td><td>Make the table enforce a schema struct.</td><td>Option<bool></td><td>Y</td></tr>
<tr><td>drop</td><td>Drop the table if it exists and create a new one with the same name.</td><td>Option<bool></td><td>Y</td></tr>
<tr><td>as</td><td>Inline statement e.g <code>select(All).from(user)</code> for creating a projection using the DEFINE TABLE statement. This is useful for copying data from an existing table in the new table definition. This is similar to making a view in a RDBMS.</td><td>A select statement</td><td>Y</td></tr>
<tr><td>as_fn</td><td>Same as above <code>as</code> but defined as external function from the struct e.g <code>select_reading_from_user</code> for creating a projection using the DEFINE TABLE statement. This is useful for copying data from an existing table in the new table definition. This is similar to making a view in a RDBMS.</td><td>A function name</td><td>Y</td></tr>
<tr><td>permissions</td><td>Specify permissions that apply to the table using the <code>for</code> statement.</td><td>ForStatement</td><td>Y</td></tr>
<tr><td>permissions_fn</td><td>Same as <code>permission</code> but as an external function from the struct. Specify permissions that apply to the table using the <code>for</code> statement.</td><td>ForStatement</td><td>Y</td></tr>
<tr><td>define</td><td>Generates a <code>DEFINE TABLE</code> statement for the table. This overrides other specific definitions to prevent confusion and collision. You can also invoke an external function directly rather than inlining the function e.g <code>define = "define_student()"</code></td><td>inline code string</td><td>Y</td></tr>
<tr><td>define_fn</td><td>Generates a <code>DEFINE TABLE</code> statement for the table. This overrides other specific definitions to prevent confusion and collision. Same as <code>define</code> attribute but expects the function name instead rather than invocation i.e <code>define_student</code> instead of <code>define_student()</code>. You can also invoke an external function directly rather than inlining the function e.g `define = "def</td><td></td><td></td></tr>
</tbody></table>
</div>
<h2 id="node-attributes-examples"><a class="header" href="#node-attributes-examples">Node Attributes: Examples</a></h2>
<h3 id="auto-inferred-table-name"><a class="header" href="#auto-inferred-table-name">Auto-Inferred Table Name</a></h3>
<p>By default, the ORM auto-infers the table name from the struct's name. For a
struct named <code>Alien</code>, the table name would be inferred as <code>alien</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Node, Serialize, Deserialize)]
pub struct Alien {
    id: SurrealSimpleId&lt;Self&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The corresponding table definition would be:</p>
<pre><code>DEFINE TABLE alien;
</code></pre>
<h3 id="explicit-table-name"><a class="header" href="#explicit-table-name">Explicit Table Name</a></h3>
<p>You can explicitly set the table name using the <code>table</code> attribute. By
default, the table name should be the snake case of the struct name. This is to
ensure consistency and uniqueness of table model struct. If you want a name
other than the snake case version, you need to add the attribute -
<code>relax_table</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Node, Serialize, Deserialize)]
#[orm(table = "student_test")]
pub struct StudentTest {
    id: SurrealSimpleId&lt;Self&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The corresponding table definition would be:</p>
<pre><code>DEFINE TABLE student_test;
</code></pre>
<h3 id="using-define-for-inline-table-definition"><a class="header" href="#using-define-for-inline-table-definition">Using <code>define</code> for Inline Table Definition</a></h3>
<p>The <code>define</code> attribute allows for inline table definitions, either through an
inline expression or an invoked external function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Node, Serialize, Deserialize)]
#[orm(table = "student_test_4", as_ = "select(All).from(Student::table())", define = "define_student()")]
pub struct StudentTest4 {
    id: SurrealSimpleId&lt;Self&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-define_fn-for-external-function-definition"><a class="header" href="#using-define_fn-for-external-function-definition">Using <code>define_fn</code> for External Function Definition</a></h3>
<p>Alternatively, the <code>define_fn</code> attribute points to an external function to
define the table:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Node, Serialize, Deserialize)]
#[orm(table = "student_test_7", define_fn = "define_student")]
pub struct StudentTest7 {
    id: SurrealSimpleId&lt;Self&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="specifying-permissions"><a class="header" href="#specifying-permissions">Specifying Permissions</a></h3>
<p>The <code>permissions</code> attribute allows you to set granular permissions for CRUD
operations. This takes <code>Permissions</code> struct. Therefore, if you are using an
external function, it has to return <code>Permissions</code> which is then invoked and
passed in:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Node, Serialize, Deserialize)]
#[orm(table = "student_test_5", permissions = "student_permissions()")]
pub struct StudentTest5 {
    id: SurrealSimpleId&lt;Self&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>student_permissions()</code> function would define
permissions using the <code>for</code> statement from Surreal orm. <code>for</code> returns
<code>Permissions</code>.</p>
<h2 id="ensuring-valid-usage-of-node-attributes"><a class="header" href="#ensuring-valid-usage-of-node-attributes">Ensuring Valid Usage of Node Attributes</a></h2>
<p>While node attributes are powerful and flexible, their misuse can lead to
unexpected behaviors. Thankfully, the ORM actively checks for invalid usages and
ensures that developers don't misuse these attributes. Here are some guidelines
and checks enforced by the ORM to avoid pitfalls:</p>
<h3 id="conflicting-definitions"><a class="header" href="#conflicting-definitions"><strong>Conflicting Definitions</strong>:</a></h3>
<ul>
<li><strong><code>define</code> vs <code>define_fn</code></strong>: Using both <code>define</code> and <code>define_fn</code> attributes on
the same struct is not allowed . Only one should be present to define the
table.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Node, Serialize, Deserialize)]
#[orm(table = "student_test_6", define_fn = "define_student", define = "define_student()")]
pub struct StudentTest6 {
    id: SurrealSimpleId&lt;Self&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The ORM will raise an error for such definitions, ensuring clarity and
preventing conflicts.</p>
<hr />
<ul>
<li>
<p><strong><code>as</code> vs <code>as_fn</code></strong>: Only one of these should be used to define projections or
views.</p>
</li>
<li>
<p><strong><code>permissions</code> vs <code>permissions_fn</code></strong>: These attributes shouldn't coexist on
the same struct, choose one based on your need.</p>
</li>
<li>
<p><strong><code>value</code> vs <code>value_fn</code></strong> and <strong><code>assert</code> vs <code>assert_fn</code></strong>: Similar to the
above, only one of these pairs should be present on a struct.</p>
</li>
</ul>
<h3 id="avoid-excessive-attributes-with-define-or-define_fn"><a class="header" href="#avoid-excessive-attributes-with-define-or-define_fn"><strong>Avoid Excessive Attributes with <code>define</code> or <code>define_fn</code></strong>:</a></h3>
<p>When using <code>define</code> or <code>define_fn</code>, ensure no other attributes are present
except <code>table</code> and <code>relax_table</code>.</p>
<h3 id="consistent-table-naming"><a class="header" href="#consistent-table-naming"><strong>Consistent Table Naming</strong>:</a></h3>
<p>By default, the table name should be the snake case of the struct name. This is
to ensure consistency and uniqueness of table model struct. If you want a name
other than the snake case version, you need to add the attribute -
<code>relax_table</code>.</p>
<h3 id="using-functions-for-attributes"><a class="header" href="#using-functions-for-attributes"><strong>Using Functions for Attributes</strong>:</a></h3>
<p>When using attributes that invoke functions, such as
<code>define = "define_student()"</code>, ensure that the invoked function returns the
appropriate type. For instance, <code>define_student()</code> should return a
<code>DefineStatement</code> struct, and <code>student_permissions()</code> should return
<code>Permissions</code>.</p>
<h3 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h3>
<p>By following these guidelines and the checks enforced by the ORM, developers can
ensure a smooth and error-free database definition process. Remember, while the
ORM provides these checks, it's always a good practice for developers to
validate and review their implementations to guarantee best practices and avoid
potential pitfalls.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-node-field-attributes"><a class="header" href="#chapter-node-field-attributes">Chapter: Node Field Attributes</a></h1>
<h2 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of Contents</a></h2>
<ol>
<li><a href="concepts/node_field_attributes.html#introduction">Introduction</a>
<ul>
<li><a href="concepts/node_field_attributes.html#attributes-table">Attributes Table</a></li>
</ul>
</li>
<li><a href="concepts/node_field_attributes.html#basic-annotations">Basic Annotations</a></li>
<li><a href="concepts/node_field_attributes.html#granular-attributes">Granular Attributes</a></li>
<li><a href="concepts/node_field_attributes.html#defining-attributes-with-functions">Defining Attributes with Functions</a></li>
<li><a href="concepts/node_field_attributes.html#field-definitions">Field Definitions</a></li>
<li><a href="concepts/node_field_attributes.html#links-and-relationships">Links and Relationships</a></li>
<li><a href="concepts/node_field_attributes.html#customizing-behavior-with-inline-expressions">Customizing Behavior with Inline Expressions</a></li>
<li><a href="concepts/node_field_attributes.html#invalid-usages">Invalid Usages</a></li>
<li><a href="concepts/node_field_attributes.html#summary-and-conclusion">Summary and Conclusion</a></li>
</ol>
<hr />
<h2 id="1-introduction"><a class="header" href="#1-introduction">1. Introduction <a name="introduction"></a></a></h2>
<p>Field attributes in Surreal orm allow developers to fine-tune the behavior and
characteristics of each field within a database node. As you've already seen in
the table of attributes, each attribute serves a specific purpose. In this
chapter, we'll delve deeper into each attribute, providing examples and
clarifying common misconceptions.</p>
<hr />
<h3 id="attributes-table"><a class="header" href="#attributes-table">Attributes Table <a name="attributes-table"></a></a></h3>
<h2 id="field-attributes"><a class="header" href="#field-attributes">Field Attributes</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Description</th><th>Type</th><th>Optional</th></tr></thead><tbody>
<tr><td>rename</td><td>Renames the field.</td><td><code>string</code></td><td>Y</td></tr>
<tr><td>link_one</td><td>Specifies a relationship to a singular record in another node table in the database.</td><td><code>model=NodeEdgeNode, connection -&gt;edge-&gt;node</code></td><td>Y</td></tr>
<tr><td>link_self</td><td>Specifies a relationship to a singular record in the same node table in the database.</td><td><code>Node</code></td><td>Y</td></tr>
<tr><td>link_many</td><td>Specifies a relationship to multiple records in another node table in the database.</td><td>`Vec&lt;S</td><td></td></tr>
<tr><td>relate</td><td>Generates the relation helpers for the Current Node struct to an edge and destination node. The corresponding field name is merely used as an alias in code generation and is read only and not serializable. e.g <code>student:1-&gt;writes-&gt;book:2</code></td><td></td><td></td></tr>
<tr><td>type</td><td>Specify the valid surrealdb field's type. One of any, array, bool, datetime, decimal, duration, float, int, number, object, string, record.</td><td>surrealdb field type</td><td>Y</td></tr>
<tr><td>assert</td><td>Assert the field's value meets a certain criteria using the an filter using <code>value()</code> function as an operation (e.g <code>value().is_not(NONE)</code>) or in <code>cond</code> helper function for more complex filter assertion. e.g <code>cond(value().is_not(NONE)).and(value().like("@codebreather"))</code>.</td><td>inline code string</td><td>Y</td></tr>
<tr><td>assert_fn</td><td>Provide a function to assert the field's value meets a certain criteria. This is similar to <code>assert</code> but is intended for an already created external function which is useful when reusing an assertion e.g <code>is_email</code>.</td><td>function name string</td><td>Y</td></tr>
<tr><td>item_type</td><td>Only when for nested array. Specifies the type of the items of the array.</td><td><code>Option&lt;FieldTypeWrapper&gt;</code></td><td>Y</td></tr>
<tr><td>item_assert</td><td>Only used for nested array. Asserts a condition on the content.</td><td><code>Option&lt;syn::LitStr&gt;</code></td><td>Y</td></tr>
<tr><td>item_assert_fn</td><td>Only used for nested array. Specifies the function to assert a condition on the content.</td><td><code>Option&lt;syn::Path&gt;</code></td><td>Y</td></tr>
<tr><td>define</td><td>Generates a <code>DEFINE FIELD</code> statement for the table. This overrides other specific definitions to prevent confusion and collision. You can also invoke an external function directly rather than inlining the function e.g <code>define = "define_age()"</code></td><td>inline code string</td><td>Y</td></tr>
<tr><td>define_fn</td><td>Generates a <code>DEFINE FIELD</code> statement for the table. This overrides other specific definitions to prevent confusion and collision. Same as <code>define</code> attribute but expects the function name instead rather than invocation i.e <code>define_age</code> instead of <code>define_age()</code>. You can also invoke an external function directly rather than inlining the function e.g `define = "def</td><td></td><td></td></tr>
<tr><td>skip_serializing</td><td>When true, this field will be omitted when serializing the struct.</td><td>bool</td><td>Y</td></tr>
</tbody></table>
</div>
<h2 id="2-basic-annotations"><a class="header" href="#2-basic-annotations">2. Basic Annotations <a name="basic-annotations"></a></a></h2>
<p>Let's begin with a basic example. The <code>Student</code> struct below uses minimal
annotations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(table = "student")]
pub struct Student {
    id: SurrealId&lt;Student, String&gt;,
    first_name: String,
    last_name: String,
    age: u8,
}
<span class="boring">}</span></code></pre></pre>
<p>Here:</p>
<ul>
<li><code>table</code> determines the name of the table in the database that corresponds
to this struct.</li>
</ul>
<hr />
<h2 id="3-granular-attributes"><a class="header" href="#3-granular-attributes">3. Granular Attributes <a name="granular-attributes"></a></a></h2>
<p>For a more detailed configuration of a field, you can use granular attributes.
The <code>Student</code> struct provides various usages:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(
    table = "student",
    permissions = "student_permissions()",
)]
pub struct Student {
    id: SurrealId&lt;Student, String&gt;,
    first_name: String,
    last_name: String,
    #[orm(
        type_ = "int",
        value = "18",
        assert = "cond(value().is_not(NONE)).and(value().gte(18))",
        permissions = "age_permissions()"
    )]
    age_inline_expr: u8,
    // ... other fields ...
}
<span class="boring">}</span></code></pre></pre>
<p>Here:</p>
<ul>
<li><code>type</code> specifies the data type of the field in the database.</li>
<li><code>value</code> sets a default value for the field.</li>
<li><code>assert</code> provides a condition that the field value must satisfy.</li>
<li><code>permissions</code> specifies what operations can be performed on the field and
under what conditions.</li>
</ul>
<hr />
<h2 id="4-defining-attributes-with-functions"><a class="header" href="#4-defining-attributes-with-functions">4. Defining Attributes with Functions <a name="defining-attributes-with-functions"></a></a></h2>
<p>You can externalize the logic for defining attributes by using external
functions. This aids in reusability and cleaner code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(
    table = "student_with_define_fn_attr",
    define_fn = "define_student_with_define_attr"
)]
pub struct StudentWithDefineFnAttr {
    // ... fields ...
    #[orm(type_ = "int", define_fn = "age_define_external_fn_path")]
    age_define_external_fn_path: u8,
}
<span class="boring">}</span></code></pre></pre>
<p>Here:</p>
<ul>
<li><code>define_fn</code> allows you to specify an external function that returns the
definition of the table or field.</li>
</ul>
<hr />
<h2 id="5-field-definitions"><a class="header" href="#5-field-definitions">5. Field Definitions <a name="field-definitions"></a></a></h2>
<p>Fields can be defined in multiple ways using <code>surreal_orm</code>:</p>
<h3 id="inline-definitions"><a class="header" href="#inline-definitions">Inline Definitions:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(type_ = "int", value = "18")]
age: u8,
<span class="boring">}</span></code></pre></pre>
<h3 id="external-function-invoked"><a class="header" href="#external-function-invoked">External Function Invoked:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(type_ = "int", value = "get_age_default_value()")]
age_default_external_function_invoked_expr: u8,
<span class="boring">}</span></code></pre></pre>
<h3 id="using-external-function-attributes"><a class="header" href="#using-external-function-attributes">Using External Function Attributes:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(type_ = "int", value_fn = "get_age_default_value")]
age_external_fn_attrs: u8,
<span class="boring">}</span></code></pre></pre>
<h3 id="mixing-and-matching"><a class="header" href="#mixing-and-matching">Mixing and Matching:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(type_ = "int", value = "get_age_default_value()", assert_fn = "get_age_assertion")]
age_mix_and_match_external_fn_inline_attrs: u8,
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="6-links-and-relationships"><a class="header" href="#6-links-and-relationships">6. Links and Relationships <a name="links-and-relationships"></a></a></h2>
<p>You can define relationships between different structs (representing tables in
the database). Relationships can be <code>one-to-one</code>, <code>one-to-many</code>, or
<code>many-to-many</code>.</p>
<p>For instance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(link_one = "Book")]
fav_book: LinkOne&lt;Book&gt;,
<span class="boring">}</span></code></pre></pre>
<p>This indicates a one-to-one relationship between a student and a book.</p>
<hr />
<h2 id="7-customizing-behavior-with-inline-expressions"><a class="header" href="#7-customizing-behavior-with-inline-expressions">7. Customizing Behavior with Inline Expressions <a name="customizing-behavior-with-inline-expressions"></a></a></h2>
<p>In <code>surreal_orm</code>, you can use inline expressions to add custom behavior:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(
    type_ = "int",
    value = "get_age_by_group_default_value(AgeGroup::Teen)",
    assert = "get_age_assertion()",
)]
age_teen_external_function_invoked_expr: u8,
<span class="boring">}</span></code></pre></pre>
<p>Here, the default value of <code>age_teen_external_function_invoked_expr</code> is
determined by the <code>get_age_by_group_default_value</code> function with
<code>AgeGroup::Teen</code> as a parameter.</p>
<hr />
<h2 id="8-invalid-usages"><a class="header" href="#8-invalid-usages">8. Invalid Usages <a name="invalid-usages"></a></a></h2>
<p>When using <code>surreal_orm</code>, it's essential to be cautious about the attributes you
combine. Certain combinations are considered invalid and will result in
compilation errors.</p>
<h3 id="1-mixing-value-and-value_fn"><a class="header" href="#1-mixing-value-and-value_fn">1. Mixing <code>value</code> and <code>value_fn</code>:</a></h3>
<p>These two attributes are mutually exclusive. You can't define a default value
using both a direct expression and a function at the same time.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(
    type_ = "int",
    value = "get_age_default_value()",
    value_fn = "get_age_default_value"
)]
age: u8,
<span class="boring">}</span></code></pre></pre>
<h3 id="2-mixing-assert-and-assert_fn"><a class="header" href="#2-mixing-assert-and-assert_fn">2. Mixing <code>assert</code> and <code>assert_fn</code>:</a></h3>
<p>Similarly, you can't use both an inline assertion and an external function for
the same purpose.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(
    type_ = "int",
    assert = "get_age_assertion()",
    assert_fn = "get_age_assertion"
)]
age: u8,
<span class="boring">}</span></code></pre></pre>
<h3 id="3-mixing-permissions-and-permissions_fn"><a class="header" href="#3-mixing-permissions-and-permissions_fn">3. Mixing <code>permissions</code> and <code>permissions_fn</code>:</a></h3>
<p>Permissions should be defined either inline or through an external function, but
not both.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(
    type_ = "int",
    permissions = "age_permissions()",
    permissions_fn = "age_permissions"
)]
age: u8,
<span class="boring">}</span></code></pre></pre>
<h3 id="4-combining-define-and-define_fn"><a class="header" href="#4-combining-define-and-define_fn">4. Combining <code>define</code> and <code>define_fn</code>:</a></h3>
<p>These attributes are also mutually exclusive. When specifying a custom
definition, you should use either an inline expression or an external function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(
    type_ = "int",
    define = "define_age()",
    define_fn = "define_age"
)]
age: u8,
<span class="boring">}</span></code></pre></pre>
<h3 id="5-using-other-attributes-with-define-or-define_fn"><a class="header" href="#5-using-other-attributes-with-define-or-define_fn">5. Using other attributes with <code>define</code> or <code>define_fn</code>:</a></h3>
<p>When you use either the <code>define</code> or <code>define_fn</code> attribute, you cannot use any
other attributes (except for <code>type</code>). This is because the definition provided
should be comprehensive and not require additional modifiers.</p>
<p>For example, the following combinations are invalid:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(
    type_ = "int",
    value = "18",
    define = "define_age()"
)]
age: u8,
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(
    type_ = "int",
    assert = "cond(value().is_not(NONE)).and(value().gte(18))",
    define = "define_age()"
)]
age: u8,
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[orm(
    type_ = "int",
    permissions = "for_permission([CrudType::Create, CrudType::Delete]).where_(StudentTest3::schema().firstName.is(\"Oyelowo\"))",
    define = "define_age()"
)]
age: u8,
<span class="boring">}</span></code></pre></pre>
<p>By being aware of these restrictions and avoiding the invalid combinations, you
can ensure that your code remains consistent, clear, and free from compilation
errors.</p>
<hr />
<h2 id="9-summary-and-conclusion"><a class="header" href="#9-summary-and-conclusion">9. Summary and Conclusion</a></h2>
<p>With <code>surreal_orm</code>, you can easily map Rust structs to database tables,
customize field properties, define relationships, and more. This provides a
powerful way to interact with databases in a type-safe manner while keeping the
codebase clean and maintainable.</p>
<p>For a hands-on illustration, consider the following code snippet which provides
a comprehensive overview of the various annotations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Node, TypedBuilder, Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
#[orm(
    table = "student_with_granular_attributes",
    drop,
    schemafull,
    as_ = "select(All).from(Student::table())",
    permissions = "student_permissions()",
)]
pub struct StudentWithGranularAttributes {
    id: SurrealId&lt;StudentWithGranularAttributes, String&gt;,
    first_name: String,
    last_name: String,
    #[orm(
        type_ = "int",
        value = "18",
        assert = "cond(value().is_not(NONE)).and(value().gte(18))",
        permissions = "for_permission([CrudType::Create, CrudType::Delete]).where_(StudentWithGranularAttributes::schema().firstName.is(\"Oyelowo\"))"
    )]
    age_inline_expr: u8,
    // ... other fields ...
}
<span class="boring">}</span></code></pre></pre>
<p>This chapter is a starting point to dive deeper into <code>surreal_orm</code>. With this
foundation, you can explore more advanced features and best practices to make
the most of this powerful ORM crate in Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="edge"><a class="header" href="#edge">Edge</a></h1>
<p>Edges in Surreal represent relationships between Nodes. They are useful when you
want to model many-to-many relationships or when you want to store additional
information about the relationship itself. Edges can be seen as "relationship
tables" in a relational database context, holding metadata about the
relationship between two entities. Edges are defined by a Rust struct that
implements the <code>Edge</code> trait.</p>
<p>Here's a detailed example:</p>
<pre><code class="language-rust  ignore">#[derive(Node, Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
#[orm(table = "alien")]
pub struct Alien {
    pub id: SurrealSimpleId&lt;Self&gt;,
    pub name: String,

    // This is a read-only field
    #[orm(relate(model = "AlienVisitsPlanet", connection = "-&gt;visits-&gt;planet"))]
    #[serde(skip_serializing, default)]
    pub planets_to_visit: Relate&lt;Planet&gt;,
}

#[derive(Node, Serialize, Deserialize, Debug, Clone, Default)]
#[serde(rename_all = "camelCase")]
#[orm(table = "planet")]
pub struct Planet {
    pub id: SurrealSimpleId&lt;Self&gt;,
    pub population: u64,
}

// Visits
#[derive(Edge, Serialize, Deserialize, Debug, Clone, Default)]
#[serde(rename_all = "camelCase")]
#[orm(table = "visits")]
pub struct Visits&lt;In: Node, Out: Node&gt; {
    pub id: SurrealSimpleId&lt;Self&gt;,
    #[serde(rename = "in")]
    pub in_: LinkOne&lt;In&gt;,
    pub out: LinkOne&lt;Out&gt;,
    pub time_visited: Duration,
}

// Connects Alien to Planet via Visits
pub type AlienVisitsPlanet = Visits&lt;Alien, Planet&gt;;</code></pre>
<p>The <code>Alien</code> Node has a field <code>planets_to_visit</code> which is of type
<code>Relate&lt;Planet&gt;</code>. This field doesn't represent a direct link from <code>Alien</code> to
<code>Planet</code>. Instead, it represents an indirect relationship via the <code>Visits</code> Edge.
This indirect relationship is defined by the <code>Relate</code> annotation on the
<code>planets_to_visit</code> field in the <code>Alien</code> Node.</p>
<p>The
<code>#[orm(relate(model = "AlienVisitsPlanet", connection = "-&gt;visits-&gt;planet"))]</code>
attribute on the <code>planets_to_visit</code> field in the <code>Alien</code> Node tells Surreal that
this field represents the <code>Planet</code> Nodes that are connected to the <code>Alien</code> Node
via the <code>AlienVisitsPlanet</code> Edge. The <code>connection = "-&gt;visits-&gt;planet"</code> part
defines the path of the relationship from the <code>Alien</code> Node, through the <code>Visits</code>
Edge (represented by "visits"), and finally to the <code>Planet</code> Node.</p>
<p>The <code>Visits</code> Edge struct defines the structure of this relationship. It
implements <code>Edge</code> and specifies two type parameters: <code>In</code> and <code>Out</code> which
represent the source and target Node types of the relationship, respectively. In
this example, <code>Alien</code> is the source and <code>Planet</code> is the target. The <code>Visits</code>
Edge also has a <code>time_visited</code> field, which can store additional information
about each visit.</p>
<p>In summary, Surreal Edges provide a flexible way to model complex relationships
between Nodes, such as when an <code>Alien</code> visits a <code>Planet</code>. They allow for
relationships to be modeled with additional information (like the <code>time_visited</code>
field in the <code>Visits</code> Edge) and can represent both direct and indirect
connections between Nodes.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="struct-attributes-1"><a class="header" href="#struct-attributes-1">Struct Attributes</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Description</th><th>Type</th><th>Optional</th></tr></thead><tbody>
<tr><td>rename_all</td><td>Renames all the struct's fields according to the given case convention. The possible values are "lowercase", "UPPERCASE", "PascalCase", "camelCase", "snake_case", "SCREAMING_SNAKE_CASE".</td><td>string</td><td>Y</td></tr>
<tr><td>table</td><td>Explicitly define the table name. By default, it must correspond with the struct name in snake_case. Use <code>relax_table</code> if you want to opt out of this but not encouraged.</td><td>Option<String></td><td>Y</td></tr>
<tr><td>relax_table</td><td>Determines whether the struct's name is matched to the table name as the snake case by default. This is not encouraged. Using your struct 1:1 to your database tables helps to ensure uniquness and prevent confusion.</td><td>Option<bool></td><td>Y</td></tr>
<tr><td>schemafull</td><td>Make the table enforce a schema struct.</td><td>Option<bool></td><td>Y</td></tr>
<tr><td>drop</td><td>Drop the table if it exists and create a new one with the same name.</td><td>Option<bool></td><td>Y</td></tr>
<tr><td>as</td><td>Inline statement e.g <code>select(All).from(user)</code> for creating a projection using the DEFINE TABLE statement. This is useful for copying data from an existing table in the new table definition. This is similar to making a view in a RDBMS.</td><td>A select statement</td><td>Y</td></tr>
<tr><td>as_fn</td><td>Same as above <code>as</code> but defined as external function from the struct e.g <code>select_reading_from_user</code> for creating a projection using the DEFINE TABLE statement. This is useful for copying data from an existing table in the new table definition. This is similar to making a view in a RDBMS.</td><td>A function name</td><td>Y</td></tr>
<tr><td>permissions</td><td>Specify permissions that apply to the table using the <code>for</code> statement.</td><td>ForStatement</td><td>Y</td></tr>
<tr><td>permissions_fn</td><td>Same as <code>permission</code> but as an external function from the struct. Specify permissions that apply to the table using the <code>for</code> statement.</td><td>ForStatement</td><td>Y</td></tr>
<tr><td>define</td><td>Generates a <code>DEFINE TABLE</code> statement for the table. This overrides other specific definitions to prevent confusion and collision. You can also invoke an external function directly rather than inlining the function e.g <code>define = "define_student()"</code></td><td>inline code string</td><td>Y</td></tr>
<tr><td>define_fn</td><td>Generates a <code>DEFINE TABLE</code> statement for the table. This overrides other specific definitions to prevent confusion and collision. Same as <code>define</code> attribute but expects the function name instead rather than invocation i.e <code>define_student</code> instead of <code>define_student()</code>. You can also invoke an external function directly rather than inlining the function e.g `define = "def</td><td></td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="field-attributes-1"><a class="header" href="#field-attributes-1">Field Attributes</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Description</th><th>Type</th><th>Optional</th></tr></thead><tbody>
<tr><td>rename</td><td>Renames the field.</td><td><code>string</code></td><td>Y</td></tr>
<tr><td>link_one</td><td>Specifies a relationship to a singular record in another node table in the database.</td><td><code>model=NodeEdgeNode, connection -&gt;edge-&gt;node</code></td><td>Y</td></tr>
<tr><td>link_self</td><td>Specifies a relationship to a singular record in the same node table in the database.</td><td><code>Node</code></td><td>Y</td></tr>
<tr><td>link_many</td><td>Specifies a relationship to multiple records in another node table in the database.</td><td>`Vec&lt;S</td><td></td></tr>
<tr><td>type</td><td>Specify the valid surrealdb field's type. One of any, array, bool, datetime, decimal, duration, float, int, number, object, string, record.</td><td>surrealdb field type</td><td>Y</td></tr>
<tr><td>assert</td><td>Assert the field's value meets a certain criteria using the an filter using <code>value()</code> function as an operation (e.g <code>value().is_not(NONE)</code>) or in <code>cond</code> helper function for more complex filter assertion. e.g <code>cond(value().is_not(NONE)).and(value().like("@codebreather"))</code>.</td><td>inline code string</td><td>Y</td></tr>
<tr><td>assert_fn</td><td>Provide a function to assert the field's value meets a certain criteria. This is similar to <code>assert</code> but is intended for an already created external function which is useful when reusing an assertion e.g <code>is_email</code>.</td><td>function name string</td><td>Y</td></tr>
<tr><td>item_type</td><td>Only when for nested array. Specifies the type of the items of the array.</td><td><code>Option&lt;FieldTypeWrapper&gt;</code></td><td>Y</td></tr>
<tr><td>item_assert</td><td>Only used for nested array. Asserts a condition on the content.</td><td><code>Option&lt;syn::LitStr&gt;</code></td><td>Y</td></tr>
<tr><td>item_assert_fn</td><td>Only used for nested array. Specifies the function to assert a condition on the content.</td><td><code>Option&lt;syn::Path&gt;</code></td><td>Y</td></tr>
<tr><td>define</td><td>Generates a <code>DEFINE FIELD</code> statement for the table. This overrides other specific definitions to prevent confusion and collision. You can also invoke an external function directly rather than inlining the function e.g <code>define = "define_age()"</code></td><td>inline code string</td><td>Y</td></tr>
<tr><td>define_fn</td><td>Generates a <code>DEFINE FIELD</code> statement for the table. This overrides other specific definitions to prevent confusion and collision. Same as <code>define</code> attribute but expects the function name instead rather than invocation i.e <code>define_age</code> instead of <code>define_age()</code>. You can also invoke an external function directly rather than inlining the function e.g `define = "def</td><td></td><td></td></tr>
<tr><td>skip_serializing</td><td>When true, this field will be omitted when serializing the struct.</td><td>bool</td><td>Y</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="object"><a class="header" href="#object">Object</a></h1>
<p>In Surreal, an Object is a complex nested data structure that can be embedded
within Nodes, modeled by the <code>Object</code> trait in Rust. Unlike Nodes, which
represent database tables, Objects do not represent tables on their own.
However, they are crucial in modeling more complex data within a Node. They can
be used directly as a field type or as an element within an array, enabling you
to encapsulate and manage more intricate data structures within your database
models.</p>
<p>Here's an example of a node named Alien that has a nested Rocket object and an
array of Rocket objects:</p>
<pre><pre class="playground"><code class="language-rust  editable"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};
use surreal_orm::{SurrealSimpleId, Node};

#[derive(Node, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[orm(table = "alien")]
pub struct Alien {
    pub id: SurrealSimpleId&lt;Self&gt;,

    #[orm(nest_object = "Rocket")]
    pub favorite_rocket: Rocket,

    #[orm(nest_array = "Rocket")]
    pub strong_rockets: Vec&lt;Rocket&gt;,
}

#[derive(Object, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Rocket {
    pub name: String,
    pub strength: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Objects in Surreal can be used in two ways: as nested objects (<code>nest_object</code>)
and as arrays of nested objects (<code>nest_array</code>). For instance, in an Alien Node,
a Rocket Object can be a single favorite rocket (<code>nest_object</code>) or a collection
of strong rockets (<code>nest_array</code>). This powerful feature allows for more complex
nested data to be directly embedded in your models, thus offering a more nuanced
representation of real-world entities in your database.</p>
<p>Notably, the use of <code>nest_object</code> or <code>nest_array</code> is validated at compile time.
This ensures that <code>nest_object</code> is used correctly for the specific Object and
<code>nest_array</code> corresponds to a vector of that Object, providing a guarantee of
the validity of your data structures before your program runs.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="struct-attributes-2"><a class="header" href="#struct-attributes-2">Struct Attributes</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Description</th><th>Type</th><th>Optional</th></tr></thead><tbody>
<tr><td>rename_all</td><td>Renames all the struct's fields according to the given case convention. The possible values are "lowercase", "UPPERCASE", "PascalCase", "camelCase", "snake_case", "SCREAMING_SNAKE_CASE".</td><td>string</td><td>Y</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h2 id="field-attributes-2"><a class="header" href="#field-attributes-2">Field Attributes</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Description</th><th>Type</th><th>Optional</th></tr></thead><tbody>
<tr><td>rename</td><td>Renames the field.</td><td><code>string</code></td><td>Y</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="record-ids-1"><a class="header" href="#record-ids-1">Record Ids</a></h1>
<p>The <code>SurrealId</code> is a wrapper struct that extends the capabilities of
<code>surrealdb::sql::Thing</code> and provides a more ergonomic interface. It's a static
type representing the id of a model in the Surreal ORM and is a combination of
the model's table name and the id, where the id can be anything that can be
converted into a <code>surrealdb::sql::Id</code>.</p>
<p>Let's explore how to utilize these ID types both implicitly (through
auto-generation via the Default trait) and explicitly (by creating them
manually).</p>
<ol>
<li><strong>SurrealSimpleId<Self>:</strong></li>
</ol>
<p>This ID type auto-generates a unique identifier when a new instance of the
struct is created, thanks to the implementation of the Default trait. But you
can also manually generate it using the <code>create_simple_id()</code> function directly
on the struct.</p>
<p>Example struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Node, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
#[orm(table = "alien")]
pub struct Alien {
    pub id: SurrealSimpleId&lt;Self&gt;,
    // other fields
}
<span class="boring">}</span></code></pre></pre>
<p>Creating an instance of Alien with an auto-generated ID (implicit):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let alien = Alien {
    // other fields
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<p>Creating an instance of Alien with a manually generated ID (explicit):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let alien = Alien {
    id: Alien::create_simple_id(),
    // other fields
};
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>SurrealUuid<Self>:</strong></li>
</ol>
<p><code>SurrealUuid&lt;Self&gt;</code> auto-generates a UUID when a new instance of the struct is
created. You can also manually generate it using the <code>create_uuid()</code> function on
the struct.</p>
<p>Example struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Node, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
#[orm(table = "account")]
pub struct Account {
    pub id: SurrealUuid&lt;Self&gt;,
    // other fields
}
<span class="boring">}</span></code></pre></pre>
<p>Creating an instance of Account with an auto-generated UUID (implicit):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let account = Account {
    // other fields
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<p>Creating an instance of Account with a manually generated UUID (explicit):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let account = Account {
    id: Account::create_uuid(),
    // other fields
};
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li><strong>SurrealUlid<Self>:</strong></li>
</ol>
<p><code>SurrealUlid&lt;Self&gt;</code> auto-generates a ULID when a new instance of the struct is
created. You can also manually generate it using the <code>create_ulid()</code> function on
the struct.</p>
<p>Example struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Node, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
#[orm(table = "spaceship")]
pub struct SpaceShip {
    pub id: SurrealUlid&lt;Self&gt;,
    // other fields
}
<span class="boring">}</span></code></pre></pre>
<p>Creating an instance of SpaceShip with an auto-generated ULID (implicit):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let spaceship = SpaceShip {
    // other fields
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<p>Creating an instance of SpaceShip with a manually generated ULID (explicit):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let spaceship = SpaceShip {
    id: SpaceShip::create_ulid(),
    // other fields
};
<span class="boring">}</span></code></pre></pre>
<ol start="4">
<li><strong>SurrealId&lt;Self, T&gt;:</strong></li>
</ol>
<p>This is the most flexible ID type, allowing for any arbitrary serializable type
<code>T</code> as the ID. However, it doesn't implement the Default trait, which means you
must manually create instances of this type using the <code>create_id()</code> function.</p>
<p>Example struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Node, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[orm(table = "weapon")]
pub struct Weapon {
    pub id: SurrealId&lt;Self, String&gt;,
    // other fields
}
<span class="boring">}</span></code></pre></pre>
<p>Creating an</p>
<p>instance of Weapon with a manually created ID (explicit):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let weapon = Weapon {
    id: Weapon::create_id("sword".into()),
    // other fields
};
<span class="boring">}</span></code></pre></pre>
<p>These ID types provide various options for users to meet the needs of different
scenarios when working with entities in SurrealDB. Whether you want
auto-generated identifiers or prefer to create them manually, there's an ID type
to suit your requirements.</p>
<p>The SurrealID types in SurrealDB are designed to be flexible and accommodating
to various needs for entity identification and linking within the database.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model-schema"><a class="header" href="#model-schema">Model Schema</a></h1>
<p>This guide covers the <code>SchemaGetter</code> trait in SurrealDB, a Rust crate, and
provides examples on how to use it.</p>
<h3 id="the-schemagetter-trait"><a class="header" href="#the-schemagetter-trait">The SchemaGetter Trait</a></h3>
<p>This trait is defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait SchemaGetter {
    type Schema;
    fn schema() -&gt; Self::Schema;
    fn schema_prefixed(prefix: impl Into&lt;ValueLike&gt;) -&gt; Self::Schema;
}
<span class="boring">}</span></code></pre></pre>
<p>This trait is used for defining schemas for different entities in your database.
It contains two associated functions:</p>
<ol>
<li><code>schema()</code>: Returns a schema for an entity. This is used for defining the
structure and constraints of the entity.</li>
<li><code>schema_prefixed(prefix: impl Into&lt;ValueLike&gt;)</code>: This is similar to
<code>schema()</code>, but it allows the schema to be prefixed with a custom value. This
can be useful when working with entities that may share similar fields but
have different schemas.</li>
</ol>
<p>The <code>SchemaGetter</code> trait's primary use is to allow types to be used as a
'Schema' - a representation of the structure of the data you're storing or
retrieving from the database. It's particularly useful in constructing complex
queries with strong type safety.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>The examples below demonstrate the different methods you can utilize in
SurrealDB, leveraging the SchemaGetter trait:</p>
<h4 id="creating-and-retrieving-entities"><a class="header" href="#creating-and-retrieving-entities">Creating and Retrieving Entities:</a></h4>
<p>This piece of code uses the <code>schema()</code> function of <code>SchemaGetter</code> to create and
retrieve entities in the database:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _simple_relation = Student::schema()
    .writes__(Empty)
    .book(Book::schema().id.equal(Thing::from(("book", "blaze"))))
    .title;
<span class="boring">}</span></code></pre></pre>
<p>This creates a relation between the <code>Student</code> and <code>Book</code> entities. It uses the
<code>writes__</code> method to create a relation indicating the <code>Student</code> writes a <code>Book</code>.
The <code>book</code> call then specifies that the book's id equals a specific <code>Thing</code>
entity.</p>
<h4 id="pattern-selection"><a class="header" href="#pattern-selection">Pattern Selection:</a></h4>
<p>SurrealDB also allows the pattern-like selection of entities:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let student_id = Student::create_id("oyelowo");
let book_id = Book::create_id("2");
let likes = StudentLiksBook::table();
let writes = StudentWritesBook::table();
let writes::Schema { timeWritten, .. } = StudentWritesBook::schema();

let aliased_connection = Student::with(student_id)
    .writes__(Empty)
    .writes__(Empty)
    .writes__(any_other_edges(&amp;[writes, likes]).where_(timeWritten.less_than_or_equal(50)))
    .book(book_id)
    .__as__(Student::aliases().writtenBooks);
<span class="boring">}</span></code></pre></pre>
<p>In this case, we are selecting all the books that a specific student wrote where
the <code>timeWritten</code> is less than or equal to 50. This query is an example of how
you can combine different methods and concepts provided by SurrealDB to form
complex, yet understandable, queries.</p>
<h4 id="modifying-and-updating-entities"><a class="header" href="#modifying-and-updating-entities">Modifying and Updating Entities:</a></h4>
<p>The following example illustrates how to modify and update entities:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ref id = created_weapon.clone().id;
let weapon::Schema { strength, .. } = Weapon::schema();

update::&lt;Weapon&gt;(id)
    .set(strength.increment_by(5u64))
    .run(db.clone())
    .await?;

let updated = update::&lt;Weapon&gt;(id)
    .set(strength.decrement_by(2u64))
    .return_one(db.clone())
    .await?;

let selected: Option&lt;Weapon&gt; = select(All)
    .from(Weapon::table())
    .return_one(db.clone())
    .await?;
assert_eq!(updated.unwrap().strength, 8);
assert_eq!(selected.unwrap().strength, 8);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="links-nestings-and-relations"><a class="header" href="#links-nestings-and-relations">Links, Nestings and Relations</a></h1>
<ul>
<li><code>link_one</code>: It is an attribute used to define a one-to-one relationship
between two Nodes. For example, consider the <code>Alien</code> struct with the field
<code>weapon</code>:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{Serialize, Deserialize,LinkOne, SurrealSimpleId, Node};

#[derive(Node, Serialize, Deserialize, Debug)]
#[orm(table = "alien")]
pub struct Alien {
    pub id: SurrealSimpleId&lt;Self&gt;,

    // #[orm(link_one = "Weapon", type_ = "record(weapon)")]
    #[orm(link_one = "Weapon")]
    pub best_weapon: LinkOne&lt;Weapon&gt;,
}


#[derive(Node, Serialize, Deserialize, Debug)]
#[orm(table = "weapon")]
pub struct Weapon {
    pub id: SurrealSimpleId&lt;Self&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>This attribute indicates that an <code>Alien</code> can have a single best <code>Weapon</code>. The
relationship is represented by a foreign key in the database table, and the
<code>type</code> attribute specifies the database type for the relationship.</p>
<ul>
<li><code>link_many</code>: It is an attribute used to define a one-to-many relationship
between two Nodes. For instance, in the <code>Alien</code> struct, we have the
<code>space_ships</code> field:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{Serialize, Deserialize, LinkMany, SurrealSimpleId, Node};

#[derive(Node, Serialize, Deserialize, Debug)]
#[orm(table = "alien")]
pub struct Alien {
    pub id: SurrealSimpleId&lt;Self&gt;,
    // #[orm(link_many = "SpaceShip", type_ = "array", item_type = "record(space_ship)")]
    #[orm(link_many = "SpaceShip")]
    pub space_ships: LinkMany&lt;SpaceShip&gt;,
}

#[derive(Node, Serialize, Deserialize, Debug)]
#[orm(table = "space_ship")]
pub struct SpaceShip {
    pub id: SurrealSimpleId&lt;Self&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>This attribute indicates that an <code>Alien</code> can have multiple <code>SpaceShip</code> instances
associated with it. The relationship is represented by a foreign key or a join
table in the database, and the <code>type</code> attribute specifies the database type for
the relationship.</p>
<ul>
<li><code>nest_object</code>: It is an attribute used to embed a single Object within a Node.
In the <code>Alien</code> struct, we have the <code>weapon</code> field:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{Serialize, Deserialize,SurrealSimpleId, Node, Object};

#[derive(Node, Serialize, Deserialize, Debug)]
#[orm(table = "alien")]
pub struct Alien {
    pub id: SurrealSimpleId&lt;Self&gt;,
    #[orm(nest_object = "Rocket")]
    pub favorite_rocket: Rocket,
}

#[derive(Object, Serialize, Deserialize, Debug)]
#[orm(table = "rocket")]
pub struct Rocket {
}
<span class="boring">}</span></code></pre></pre>
<p>This attribute specifies that an <code>Alien2</code> has a nested <code>Rocket</code> object
representing its weapon. The <code>Rocket</code> object is stored as part of the <code>Alien2</code>
Node in the database.</p>
<ul>
<li><code>nest_array</code>: It is an attribute used to embed multiple Objects within a Node.
Although not explicitly used in the provided code examples, it would be
similar to <code>NestObject</code>, but with a collection type field (e.g.,
<code>Vec&lt;Rocket&gt;</code>).</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{Serialize, Deserialize,SurrealSimpleId, Node, Object};

#[derive(Node, Serialize, Deserialize, Debug)]
#[orm(table = "alien")]
pub struct Alien {
    pub id: SurrealSimpleId&lt;Self&gt;,

    #[orm(nest_array = "Rocket")]
    pub big_rockets: Vec&lt;Rocket&gt;,
}

#[derive(Node, Serialize, Deserialize, Debug)]
#[orm(table = "rocket")]
pub struct Rocket {
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>relate</code>: It is an attribute used to define a read-only relationship between
two Nodes. In the <code>Alien</code> struct, we have the <code>planets_to_visit</code> field:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{Serialize, Deserialize, SurrealSimpleId, Node, Edge, Relate};

#[derive(Node, Serialize, Deserialize, Debug)]
#[orm(table = "alien")]
pub struct Alien {
    pub id: SurrealSimpleId&lt;Self&gt;,

    #[orm(relate(model = "AlienVisitsPlanet", connection = "-&gt;visits-&gt;planet"))]
    #[serde(skip_serializing, default)]
    pub planets_to_visit: Relate&lt;Planet&gt;,
}

#[derive(Node, Serialize, Deserialize, Debug, Clone, Default)]
#[serde(rename_all = "camelCase")]
#[orm(table = "planet")]
pub struct Planet {
    pub id: SurrealSimpleId&lt;Self&gt;,
    pub population: u64,
}

// Visits
#[derive(Edge, Serialize, Deserialize, Debug, Clone, Default)]
#[serde(rename_all = "camelCase")]
#[orm(table = "visits")]
pub struct Visits&lt;In: Node, Out: Node&gt; {
    pub id: SurrealSimpleId&lt;Self&gt;,
    #[serde(rename = "in")]
    pub in_: LinkOne&lt;In&gt;,
    pub out: LinkOne&lt;Out&gt;,
    pub time_visited: Duration,
}

// Connects Alien to Planet via Visits
pub type AlienVisitsPlanet = Visits&lt;Alien, Planet&gt;;
<span class="boring">}</span></code></pre></pre>
<p>This attribute specifies that an <code>Alien</code> has a read-only relationship with
<code>Planet</code> through the <code>AlienVisitsPlanet</code> model. The <code>connection</code> attribute
describes the relationship path between the Nodes. The relationship is read-only
because the <code>serde(skip_serializing)</code> attribute is used to prevent it from being
serialized.</p>
<p>These attributes provide additional information to Surreal for modeling
relationships and embedding Objects within Nodes, allowing for more complex and
flexible database schema designs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-traversal"><a class="header" href="#field-traversal">Field Traversal</a></h1>
<p>The <code>surreal_orm</code> library equips developers with powerful field traversal
capabilities, allowing for seamless querying and navigation through the
<code>surrealdb</code> graph database. This chapter provides an in-depth exploration into
the different traversal methods available and how to harness them effectively.</p>
<h2 id="basics-of-field-traversal"><a class="header" href="#basics-of-field-traversal">Basics of Field Traversal</a></h2>
<p>Field traversal is the mechanism used to navigate through a data structure,
pinpointing specific fields or relationships. The design of the <code>surreal_orm</code>
makes traversal not only intuitive but also direct, offering methods to navigate
fields, relationships, and even to apply specific conditions.</p>
<p>To get started, let's set up our environment:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pretty_assertions::assert_eq;
use surreal_models::{student, Student};
use surreal_orm::{index, this, where_, All, Buildable, Operatable, SchemaGetter, ToRaw, E};
<span class="boring">}</span></code></pre></pre>
<h2 id="root-object-the-starting-point"><a class="header" href="#root-object-the-starting-point">Root Object: The Starting Point</a></h2>
<p>Every traversal starts with the root object. The <code>this()</code> function is your
gateway, representing the current node or object you're working on.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn basic() {
</span>let param_with_path = this();
assert_eq!(param_with_path.to_raw().build(), "$this");
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>In the code snippet above, the <code>this()</code> function signifies a reference to the
root object or the primary context of the traversal. When executed, this will
produce <code>"$this"</code>.</p>
<h2 id="traversing-the-path"><a class="header" href="#traversing-the-path">Traversing the Path</a></h2>
<p>Navigating relationships between nodes is where the real power of a graph
database shines. The <code>with_path::&lt;T&gt;(index_or_clause)</code> method allows you to
specify this path. Here <code>T</code> is the type of node you're targeting, while
<code>index_or_clause</code> can either be an index or a clause, such as <code>WHERE age &gt; 18</code>
or <code>E</code> (an alias for <code>Empty</code>).</p>
<p>For instance, to get the <code>firstName</code> of a <code>Student</code> at index <code>2</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let param_with_path = this().with_path::&lt;Student&gt;([2]).firstName;
<span class="boring">}</span></code></pre></pre>
<p>This traversal, when executed, will output <code>"$this[2].firstName"</code>.</p>
<h3 id="direct-field-access-within-an-object"><a class="header" href="#direct-field-access-within-an-object">Direct Field Access within an Object</a></h3>
<p>Sometimes, all you want is to directly access a field within an object. Here's
how you can achieve that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn test_param_simple_clause() {
</span>let param_with_path = this().with_path::&lt;Student&gt;(E).lastName;
assert_eq!(param_with_path.to_raw().build(), "$this.lastName");
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>In this example, the alias <code>E</code> (standing for <code>Empty</code>) is employed to directly
traverse to the <code>lastName</code> field of the <code>Student</code> object.</p>
<h3 id="direct-field-access-within-an-array"><a class="header" href="#direct-field-access-within-an-array">Direct Field Access within an Array</a></h3>
<p>At other times, you might want to directly access a field within an array:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn test_param_with_path_simple() {
</span>let param_with_path = this().with_path::&lt;Student&gt;([2]).firstName;
assert_eq!(param_with_path.to_raw().build(), "$this[2].firstName");
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Here, the code fetches the <code>firstName</code> of the <code>Student</code> located at index <code>2</code>.</p>
<h3 id="deep-relationship-traversal"><a class="header" href="#deep-relationship-traversal">Deep Relationship Traversal</a></h3>
<p>The true essence of a graph database is revealed when traversing deep
relationships. Consider this test:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn test_param_with_path() {
</span>let param_with_path = this()
    .with_path::&lt;Student&gt;([2])
    .bestFriend()
    .bestFriend()
    .course()
    .title;
assert_eq!(param_with_path.to_raw().build(), "$this[2].bestFriend.bestFriend.course.title");
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>This test showcases how to navigate through a <code>Student</code>'s best friend's best
friend's course title.</p>
<h3 id="index-function-for-indexing"><a class="header" href="#index-function-for-indexing">Index function for Indexing</a></h3>
<p>An alternate to square bracket notation <code>[2]</code> is the <code>index</code> helper function
e.g(<code>index(2)</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn test_param_with_path_with_index_square_bracket_variation() {
</span>let param_with_path = this()
    .with_path::&lt;Student&gt;(index(2))
    .bestFriend()
    .bestFriend()
    .course()
    .title;
assert_eq!(param_with_path.to_raw().build(), "$this[2].bestFriend.bestFriend.course.title");
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h3 id="traversal-with-conditional-clauses"><a class="header" href="#traversal-with-conditional-clauses">Traversal with Conditional Clauses</a></h3>
<p>You can also traverse paths with conditions, allowing for more refined querying:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn test_param_with_path_with_clause() {
</span>let student::Schema { age, .. } = Student::schema();
let param_with_path = this()
    .with_path::&lt;Student&gt;(where_(age.greater_than(18)))
    .bestFriend()
    .allSemesterCourses([5])
    .title;
assert_eq!(param_with_path.to_raw().build(), "$this[WHERE age &gt; 18].bestFriend.allSemesterCourses[5].title");
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>This traversal fetches the title of the fifth semester course of the best
friends of students older than 18.</p>
<h3 id="using-the-all-wildcard"><a class="header" href="#using-the-all-wildcard">Using the All Wildcard</a></h3>
<p>For scenarios where you want to traverse all items or elements of a certain
relationship or field, the <code>All</code> wildcard is invaluable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn test_param_with_path_with_all_wildcard() {
</span>let param_with_path = this()
    .with_path::&lt;Student&gt;(All)
    .bestFriend()
    .allSemesterCourses([5])
    .title;
assert_eq!(param_with_path.to_raw().build(), "$this[*].bestFriend.allSemesterCourses[5].title");
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>In the traversal above, <code>All</code> is a wildcard that represents every instance of
the <code>Student</code> type. The traversal then specifies the fifth course title of all
students' best friends.</p>
<h3 id="multiple-indexes-in-path"><a class="header" href="#multiple-indexes-in-path">Multiple Indexes in Path</a></h3>
<p>There are scenarios where traversing multiple indexed fields or relationships
becomes necessary:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn test_param_with_path_multiple_indexes() {
</span>let param_with_path = this()
    .with_path::&lt;Student&gt;([2])
    .bestFriend()
    .allSemesterCourses([5])
    .title;
assert_eq!(param_with_path.to_raw().build(), "$this[2].bestFriend.allSemesterCourses[5].title");
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Here, the traversal first targets the <code>Student</code> at index 2 and then fetches the
title of the fifth semester course of that student's best friend.</p>
<hr />
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>Field traversal in <code>surreal_orm</code> equips developers with a versatile and powerful
toolset, enabling effective navigation and querying within</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loaders"><a class="header" href="#loaders">Loaders</a></h1>
<p>Loaders in the Surreal ORM are functions that fetch different kinds of related
records (links) from the database. These loaders provide different ways of
handling these related records, based on their type and their existence in the
database. Here, we discuss some of the "load" types that are part of the
<code>ReturnableStandard</code> trait.</p>
<h2 id="load_links"><a class="header" href="#load_links"><code>load_links</code></a></h2>
<p>The <code>load_links</code> function sets the return type to projections and fetches all
record links. It defaults values to null for referenced records that do not
exist.</p>
<p>For instance, if you have a <code>User</code> model that has a <code>Posts</code> link (i.e., each
User can have multiple Posts), you can use <code>load_links</code> to fetch all the <code>Posts</code>
linked to a <code>User</code>. If a <code>Post</code> does not exist, the function defaults its value
to null.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = User::find(1).load_links(vec!["posts"]).unwrap();
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    #[derive(Node, Serialize, Deserialize, Debug, Clone)]
    #[serde(rename_all = "camelCase")]
    #[orm(table = "alien")]
    pub struct Alien {
        pub id: SurrealSimpleId&lt;Self&gt;,

        #[orm(link_self = "Alien")]
        pub ally: LinkSelf&lt;Alien&gt;,

        #[orm(link_one = "Weapon")]
        pub weapon: LinkOne&lt;Weapon&gt;,

        // Again, we dont have to provide the type attribute, it can auto detect
        #[orm(link_many = "SpaceShip")]
        pub space_ships: LinkMany&lt;SpaceShip&gt;,

        // This is a read only field
        #[orm(relate(model = "AlienVisitsPlanet", connection = "-&gt;visits-&gt;planet"))]
        #[serde(skip_serializing, default)]
        pub planets_to_visit: Relate&lt;Planet&gt;,
    }

    #[derive(Node, Serialize, Deserialize, Debug, Clone, Default)]
    #[serde(rename_all = "camelCase")]
    #[orm(table = "weapon")]
    pub struct Weapon {
        pub id: SurrealSimpleId&lt;Self&gt;,
        pub name: String,
        // pub strength: u64,
        #[orm(type_ = "int")]
        pub strength: Strength,
        pub created: DateTime&lt;Utc&gt;,
        #[orm(nest_object = "Rocket")]
        pub rocket: Rocket,
    }
    type Strength = u64;


    #[derive(Node, Serialize, Deserialize, Debug, Clone)]
    #[serde(rename_all = "camelCase")]
    #[orm(table = "space_ship")]
    pub struct SpaceShip {
        pub id: SurrealId&lt;Self, String&gt;,
        pub name: String,
        pub created: DateTime&lt;Utc&gt;,
    }

    let weapon = || Weapon {
        name: "Laser".to_string(),
        created: Utc::now(),
        ..Default::default()
    };
    let weapon1 = weapon();
    let weapon2 = weapon();

    let space_ship = SpaceShip {
        id: SpaceShip::create_id("gbanda".into()),
        name: "SpaceShip1".to_string(),
        created: Utc::now(),
    };

    let space_ship2 = SpaceShip {
        id: SpaceShip::create_id("halifax".into()),
        name: "SpaceShip2".to_string(),
        created: Utc::now(),
    };

    let space_ship3 = SpaceShip {
        id: SpaceShip::create_id("alberta".into()),
        name: "Oyelowo".to_string(),
        created: Utc::now(),
    };

    assert_eq!(weapon1.clone().id.to_thing().tb, "weapon");

    // create first record to weapon table
    let created_weapon = create()
        .content(weapon1.clone())
        .get_one(db.clone())
        .await?;
    assert_eq!(created_weapon.id.to_thing(), weapon1.id.to_thing());

    let select1: Vec&lt;Weapon&gt; = select(All)
        .from(Weapon::table())
        .return_many(db.clone())
        .await?;
    // weapon table should have one record
    assert_eq!(select1.len(), 1);

    //  Create second record
    let created_weapon = create()
        .content(weapon2.clone())
        .return_one(db.clone())
        .await?;

    let select2: Vec&lt;Weapon&gt; = select(All)
        .from(Weapon::table())
        .return_many(db.clone())
        .await?;
    // weapon table should have two records after second creation
    assert_eq!(select2.len(), 2);

    let created_spaceship1 = create()
        .content(space_ship.clone())
        .get_one(db.clone())
        .await?;
    let created_spaceship2 = create()
        .content(space_ship2.clone())
        .get_one(db.clone())
        .await?;
    let created_spaceship3 = create()
        .content(space_ship3.clone())
        .get_one(db.clone())
        .await?;

    let point = point! {
        x: 40.02f64,
        y: 116.34,
    };

    let territory = line_string![(x: 40.02, y: 116.34), (x: 40.02, y: 116.35), (x: 40.03, y: 116.35), (x: 40.03, y: 116.34), (x: 40.02, y: 116.34)];
    let polygon = polygon![(x: 40.02, y: 116.34), (x: 40.02, y: 116.35), (x: 40.03, y: 116.35), (x: 40.03, y: 116.34), (x: 40.02, y: 116.34)];
    let unsaved_alien = Alien {
        id: Alien::create_simple_id(),
        ally: LinkSelf::null(),
        weapon: LinkOne::from(created_weapon.unwrap()),
        space_ships: LinkMany::from(vec![
            created_spaceship1.clone(),
            created_spaceship2.clone(),
            created_spaceship3.clone(),
        ]),
        planets_to_visit: Relate::null(),
    };

    assert!(unsaved_alien.weapon.get_id().is_some());
    assert!(unsaved_alien.weapon.value().is_none());

    // Check fields value fetching
    let alien::Schema { weapon, .. } = Alien::schema();
    let created_alien = create()
        .content(unsaved_alien.clone())
        .load_links(vec![weapon])?
        .get_one(db.clone())
        .await?;

    let ref created_alien = created_alien.clone();
    // id is none  because ally field is not created.
    assert!(created_alien.ally.get_id().is_none());
    // .value() is None because ally is not created.
    assert!(created_alien.ally.value().is_none());

    // Weapon is created at weapon field and also loaded.
    // get_id  is None because weapon is loaded.
    assert!(created_alien.weapon.get_id().is_none());
    // .value() is Some because weapon is loaded.
    assert!(created_alien.weapon.value().is_some());

    // Spaceships created at weapon field and also loaded.
    assert_eq!(created_alien.space_ships.is_empty(), false);

    assert_eq!(created_alien.space_ships.len(), 3);
    assert_eq!(
        created_alien
            .space_ships
            .iter()
            .map(|x| x.get_id().unwrap().to_string())
            .collect::&lt;Vec&lt;_&gt;&gt;(),
        vec![
            created_spaceship1.id.to_string(),
            created_spaceship2.id.to_string(),
            created_spaceship3.id.to_string(),
        ]
    );



    let created_alien_with_fetched_links = create()
        .content(unsaved_alien.clone())
        .load_link_manys()?
        .return_one(db.clone())
        .await?;

    let ref created_alien_with_fetched_links = created_alien_with_fetched_links.unwrap();
    let alien_spaceships = created_alien_with_fetched_links.space_ships.values();

    assert_eq!(created_alien_with_fetched_links.space_ships.keys().len(), 3);
    assert_eq!(
        created_alien_with_fetched_links
            .space_ships
            .keys_truthy()
            .len(),
        0
    );
<span class="boring">}</span></code></pre></pre>
<h2 id="load_all_links"><a class="header" href="#load_all_links"><code>load_all_links</code></a></h2>
<p>The <code>load_all_links</code> function sets the return type to projections and fetches
all record link values. For <code>link_one</code> and <code>link_self</code> types, it returns null if
the link is null or if the reference does not exist. For <code>link_many</code> type, it
returns <code>None</code> for items that are null or the references that do not exist.</p>
<p>Assume you have a <code>User</code> model with <code>link_one</code> type <code>Profile</code>, <code>link_self</code> type
<code>Friends</code>, and <code>link_many</code> type <code>Posts</code>. You can use <code>load_all_links</code> to fetch
all these linked records.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = User::find(1).load_all_links().unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="load_link_manys"><a class="header" href="#load_link_manys"><code>load_link_manys</code></a></h2>
<p>The <code>load_link_manys</code> function sets the return type to projections and fetches
all record link values for <code>link_many</code> fields, including the null record links.
So, if a <code>User</code> has multiple <code>Posts</code>, this function fetches all <code>Posts</code>
including the ones that are null.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = User::find(1).load_link_manys().unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="load_link_ones"><a class="header" href="#load_link_ones"><code>load_link_ones</code></a></h2>
<p>The <code>load_link_ones</code> function sets the return type to projections and fetches
all record link values for <code>link_one</code> fields. It defaults to null if the
reference does not exist.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = User::find(1).load_link_ones().unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="load_link_selfs"><a class="header" href="#load_link_selfs"><code>load_link_selfs</code></a></h2>
<p>The <code>load_line_selfs</code> function sets the return type to projections and fetches
all record link values for <code>link_self</code> fields. It defaults to null if the
reference does not exist.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = User::find(1).load_line_selfs().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>In conclusion, loaders provide a flexible way to handle linked records in your
database. Whether you want to fetch all links, fetch links of a specific type,
or handle null references in a certain way, loaders have got you covered. They
are a powerful tool in the Surreal ORM, simplifying complex database operations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return-types"><a class="header" href="#return-types">Return Types</a></h1>
<p>Return types in the Surreal ORM define how database operations result in
returned data. They allow the specification of the format and structure of the
data returned after running a database operation. In this chapter, we will
discuss some of the "return" types that are part of the <code>ReturnableStandard</code>
trait.</p>
<h2 id="return_one"><a class="header" href="#return_one"><code>return_one</code></a></h2>
<p>The <code>return_one</code> function runs a statement against the database and returns a
single result. If the result contains more than one record, it throws an error.</p>
<p>Consider a scenario where you want to fetch a single user from your database.
You can use <code>return_one</code> to get the <code>User</code> record:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = User::find(1).return_one(db).await.unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="return_many"><a class="header" href="#return_many"><code>return_many</code></a></h2>
<p>The <code>return_many</code> function runs a statement against the database and returns
multiple results.</p>
<p>For instance, if you want to fetch all users from your database, you can use
<code>return_many</code> to get the <code>User</code> records:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let users = User::all().return_many(db).await.unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="return_none"><a class="header" href="#return_none"><code>return_none</code></a></h2>
<p>The <code>return_none</code> function runs a statement against the database and returns no
result.</p>
<p>This is particularly useful when you perform operations that don't require a
return value. For example, deleting a user:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>User::delete(1).return_none(db).await.unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="return_first"><a class="header" href="#return_first"><code>return_first</code></a></h2>
<p>The <code>return_first</code> function runs a statement against the database and returns
the first result.</p>
<p>For example, to get the first user in the database:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = User::all().return_first(db).await.unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="return_many_before"><a class="header" href="#return_many_before"><code>return_many_before</code></a></h2>
<p>The <code>return_many_before</code> function runs a statement against the database and
returns the many results before the change.</p>
<p>This is useful when you want to compare the state of the records before and
after a database operation. For instance, updating a user's profile:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let users_before_update = User::all().return_many_before(db).await.unwrap();
User::update(1, new_profile_data).return_none(db).await.unwrap();
<span class="boring">}</span></code></pre></pre>
<p>In conclusion, return types provide a way to control the data returned by
database operations. Whether you want a single record, multiple records, the
first record, or no record at all, return types allow you to specify the
outcome.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="helper-methods-in-surreal_orm"><a class="header" href="#helper-methods-in-surreal_orm">Helper Methods in <code>surreal_orm</code></a></h1>
<p>The <code>surreal_orm</code> library offers a set of utility functions encapsulated in the
<code>SurrealCrud</code> and <code>SurrealCrudNode</code> traits. These methods provide a high-level
abstraction over raw database statements, simplifying CRUD operations.</p>
<h2 id="preparations"><a class="header" href="#preparations">Preparations</a></h2>
<p>Before we dive into the helper methods, let's set up our environment:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_models::{space_ship, weapon, SpaceShip, Weapon};
use surreal_orm::{
    statements::{insert, select, select_value},
    *,
};
use surrealdb::{
    engine::local::{Db, Mem},
    Surreal,
};

async fn create_test_data(db: Surreal&lt;Db&gt;) {
    let space_ships = (0..1000)
        .map(|i| Weapon {
            name: format!("weapon-{}", i),
            strength: i,
            ..Default::default()
        })
        .collect::&lt;Vec&lt;Weapon&gt;&gt;();
    insert(space_ships).run(db.clone()).await.unwrap();
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="1-save-method"><a class="header" href="#1-save-method">1. <code>save</code> Method</a></h2>
<p>The <code>save</code> method can either create a new record or update an existing one in
the database. You can think of it as an upsert method.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_save() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let ss_id = SpaceShip::create_id("num-1".into());
    let spaceship = SpaceShip {
        id: ss_id.clone(),
        name: "spaceship-1".into(),
        created: chrono::Utc::now(),
    };

    let spaceship = spaceship.save().get_one(db.clone()).await?;

    let saved_spaceship = SpaceShip::find_by_id(ss_id.clone())
        .get_one(db.clone())
        .await?;

    assert_eq!(spaceship.id.to_thing(), saved_spaceship.id.to_thing());
    assert_eq!(spaceship.name, saved_spaceship.name);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="2-find_by_id-method"><a class="header" href="#2-find_by_id-method">2. <code>find_by_id</code> Method</a></h2>
<p>Retrieve a record by its ID:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_find_by_id() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let spaceship = SpaceShip {
        id: SpaceShip::create_id("num-1".into()),
        name: "spaceship-1".into(),
        created: chrono::Utc::now(),
    };

    spaceship.clone().save().run(db.clone()).await?;

    let found_spaceship = SpaceShip::find_by_id(spaceship.id.clone())
        .get_one(db.clone())
        .await?;

    assert_eq!(spaceship.id.to_thing(), found_spaceship.id.to_thing());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="3-find_where-method"><a class="header" href="#3-find_where-method">3. <code>find_where</code> Method</a></h2>
<p>Retrieve records based on specific conditions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_find_where() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let spaceship = SpaceShip {
        id: SpaceShip::create_id("num-1".into()),
        name: "spaceship-1".into(),
        created: chrono::Utc::now(),
    };
    let _spaceship2 = SpaceShip {
        id: SpaceShip::create_id("num-2".into()),
        name: "spaceship-2".into(),
        created: chrono::Utc::now(),
    }
    .save()
    .run(db.clone())
    .await?;

    let _spaceschip = spaceship.clone().save().get_one(db.clone()).await?;
    let space_ship::Schema { name, id, .. } = SpaceShip::schema();

    let found_spaceships = SpaceShip::find_where(id.is_not(NULL))
        .return_many(db.clone())
        .await?;
    assert_eq!(found_spaceships.len(), 2);

    let found_spaceships = SpaceShip::find_where(name.equal("spaceship-1"))
        .return_many(db.clone())
        .await?;

    assert_eq!(found_spaceships.len(), 1);
    assert_eq!(found_spaceships[0].id.to_thing(), spaceship.id.to_thing());

    let found_spaceship = SpaceShip::find_where(name.equal("spaceship-1"))
        .get_one(db.clone())
        .await?;

    assert_eq!(found_spaceship.id.to_thing(), spaceship.id.to_thing());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="4-count_where-method"><a class="header" href="#4-count_where-method">4. <code>count_where</code> Method</a></h2>
<p>Count records based on specific conditions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_count_where() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    create_test_data(db.clone()).await;
    let weapon::Schema { strength, .. } = &amp;Weapon::schema();

    let weapons_query = Weapon::count_where(strength.gte(500));
    let weapons_count = weapons_query.get(db.clone()).await?;

    assert_eq!(
        weapons_query.to_raw().build(),
        "SELECT VALUE count FROM (SELECT count(strength &gt;= 500) FROM weapon GROUP ALL);"
    );

    assert_eq!(weapons_count, 500);

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="5-count_all-method"><a class="header" href="#5-count_all-method">5. <code>count_all</code> Method</a></h2>
<p>Count all records:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_count_all() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    create_test_data(db.clone()).await;

    let weapons_query = Weapon::count_all();
    let weapons_count = weapons_query.get(db.clone()).await?;

    assert_eq!(
        weapons_query.to_raw().build(),
        "SELECT VALUE count FROM (SELECT count() FROM weapon GROUP ALL);"
    );

    assert_eq!(weapons_count, 1000);

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="6-delete-method"><a class="header" href="#6-delete-method">6. <code>delete</code> Method</a></h2>
<p>This method deletes the current record instance from the database.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_delete() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let spaceship = SpaceShip {
        id: SpaceShip::create_id("num-1".into()),
        name: "spaceship-1".into(),
        created: chrono::Utc::now(),
    };

    let spaceship = spaceship.save().get_one(db.clone()).await?;

    let found_spaceship = SpaceShip::find_by_id(spaceship.id.clone())
        .return_many(db.clone())
        .await?;
    assert_eq!(found_spaceship.len(), 1);

    spaceship.clone().delete().run(db.clone()).await?;

    let found_spaceship = SpaceShip::find_by_id(spaceship.id.clone())
        .return_many(db.clone())
        .await?;

    assert!(found_spaceship.is_empty());
    assert_eq!(found_spaceship.len(), 0);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="7-delete_by_id-method"><a class="header" href="#7-delete_by_id-method">7. <code>delete_by_id</code> Method</a></h2>
<p>This method deletes a record by its ID.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_delete_by_id() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let spaceship = SpaceShip {
        id: SpaceShip::create_id("num-1".into()),
        name: "spaceship-1".into(),
        created: chrono::Utc::now(),
    };

    let spaceship = spaceship.save().get_one(db.clone()).await?;
    let found_spaceships = SpaceShip::find_by_id(spaceship.id.clone())
        .return_many(db.clone())
        .await?;
    assert_eq!(found_spaceships.len(), 1);

    SpaceShip::delete_by_id(spaceship.id.clone())
        .run(db.clone())
        .await?;

    let found_spaceships = SpaceShip::find_by_id(spaceship.id.clone())
        .return_many(db.clone())
        .await?;
    assert_eq!(found_spaceships.len(), 0);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="8-delete_where-method"><a class="header" href="#8-delete_where-method">8. <code>delete_where</code> Method</a></h2>
<p>This method deletes records based on a specific condition.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_delete_where() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let spaceship = SpaceShip {
        id: SpaceShip::create_id("num-1".into()),
        name: "spaceship-1".into(),
        created: chrono::Utc::now(),
    };

    spaceship.save().run(db.clone()).await.unwrap();
    let space_ship::Schema { name, .. } = SpaceShip::schema();

    let found_spaceships = SpaceShip::find_where(name.like("spaceship-1"))
        .return_many(db.clone())
        .await?;
    assert_eq!(found_spaceships.len(), 1);

    SpaceShip::delete_where(name.like("spaceship"))
        .run(db.clone())
        .await?;

    let found_spaceships = SpaceShip::find_where(name.like("spaceship-1"))
        .return_many(db.clone())
        .await?;
    assert_eq!(found_spaceships.len(), 0);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="9-create-method"><a class="header" href="#9-create-method">9. <code>create</code> Method</a></h2>
<p>This method creates a new record in the database. It's specifically for nodes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_create() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let ss_id = SpaceShip::create_id(format!("num-{}", 1));
    let spaceship = SpaceShip {
        id: ss_id.clone(),
        name: format!("spaceship-{}", 1),
        created: chrono::Utc::now(),
    };

    let spaceship = spaceship.create().get_one(db.clone()).await?;
    // Second attempt should fail since it will be duplicate.
    spaceship
        .clone()
        .create()
        .get_one(db.clone())
        .await
        .expect_err("should fail");

    let saved_spaceship = SpaceShip::find_by_id(ss_id.clone())
        .get_one(db.clone())
        .await?;

    assert_eq!(spaceship.id.to_thing(), saved_spaceship.id.to_thing());
    assert_eq!(spaceship.name, saved_spaceship.name);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<p>This wraps up the explanations and demonstrations for all the helper methods in
surreal_orm.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-utility-functions"><a class="header" href="#introduction-to-utility-functions">Introduction to Utility Functions</a></h1>
<p>In surreal_orm, utility functions are designed to simplify complex database
operations by abstracting them into easy-to-use methods. They help streamline
CRUD operations, reducing the need for verbose database statements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read-methods"><a class="header" href="#read-methods">Read Methods</a></h1>
<p>Read methods allow for the retrieval of data from the database. They cater to
various use cases, from fetching a single record using its unique identifier to
obtaining multiple records based on specific conditions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="find_by_id"><a class="header" href="#find_by_id">find_by_id</a></h1>
<h2 id="2-find_by_id-method-1"><a class="header" href="#2-find_by_id-method-1">2. <code>find_by_id</code> Method</a></h2>
<p>The find_by_id method provides a straightforward way to fetch a record from the
database using its unique ID.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_find_by_id() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let spaceship = SpaceShip {
        id: SpaceShip::create_id("num-1".into()),
        name: "spaceship-1".into(),
        created: chrono::Utc::now(),
    };

    spaceship.clone().save().run(db.clone()).await?;

    let found_spaceship = SpaceShip::find_by_id(spaceship.id.clone())
        .get_one(db.clone())
        .await?;

    assert_eq!(spaceship.id.to_thing(), found_spaceship.id.to_thing());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="find_where"><a class="header" href="#find_where">find_where</a></h1>
<h2 id="3-find_where-method-1"><a class="header" href="#3-find_where-method-1">3. <code>find_where</code> Method</a></h2>
<p>For more complex data retrieval needs, the find_where method allows you to
specify conditions to determine which records to fetch.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_find_where() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let spaceship = SpaceShip {
        id: SpaceShip::create_id("num-1".into()),
        name: "spaceship-1".into(),
        created: chrono::Utc::now(),
    };
    let _spaceship2 = SpaceShip {
        id: SpaceShip::create_id("num-2".into()),
        name: "spaceship-2".into(),
        created: chrono::Utc::now(),
    }
    .save()
    .run(db.clone())
    .await?;

    let _spaceschip = spaceship.clone().save().get_one(db.clone()).await?;
    let space_ship::Schema { name, id, .. } = SpaceShip::schema();

    let found_spaceships = SpaceShip::find_where(id.is_not(NULL))
        .return_many(db.clone())
        .await?;
    assert_eq!(found_spaceships.len(), 2);

    let found_spaceships = SpaceShip::find_where(name.equal("spaceship-1"))
        .return_many(db.clone())
        .await?;

    assert_eq!(found_spaceships.len(), 1);
    assert_eq!(found_spaceships[0].id.to_thing(), spaceship.id.to_thing());

    let found_spaceship = SpaceShip::find_where(name.equal("spaceship-1"))
        .get_one(db.clone())
        .await?;

    assert_eq!(found_spaceship.id.to_thing(), spaceship.id.to_thing());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-update-methods"><a class="header" href="#create-update-methods">Create, Update Methods</a></h1>
<p>Creating and updating records are fundamental operations in any database.
surreal_orm provides methods to easily handle both these tasks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="save"><a class="header" href="#save">save</a></h1>
<h2 id="1-save-method-1"><a class="header" href="#1-save-method-1">1. <code>save</code> Method</a></h2>
<p>The save method is versatile—it can either create a new record or update an
existing one, making it an "upsert" function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_save() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let ss_id = SpaceShip::create_id("num-1".into());
    let spaceship = SpaceShip {
        id: ss_id.clone(),
        name: "spaceship-1".into(),
        created: chrono::Utc::now(),
    };

    let spaceship = spaceship.save().get_one(db.clone()).await?;

    let saved_spaceship = SpaceShip::find_by_id(ss_id.clone())
        .get_one(db.clone())
        .await?;

    assert_eq!(spaceship.id.to_thing(), saved_spaceship.id.to_thing());
    assert_eq!(spaceship.name, saved_spaceship.name);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create"><a class="header" href="#create">create</a></h1>
<h2 id="9-create-method-1"><a class="header" href="#9-create-method-1">9. <code>create</code> Method</a></h2>
<p>While the save method is versatile, the create method is specialized for
creating new records. It's specifically for nodes. Unlike the <code>save</code> method,
rather than updating the existing record by its <code>id</code>, it throws and error when a
record already exists.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_create() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let ss_id = SpaceShip::create_id(format!("num-{}", 1));
    let spaceship = SpaceShip {
        id: ss_id.clone(),
        name: format!("spaceship-{}", 1),
        created: chrono::Utc::now(),
    };

    let spaceship = spaceship.create().get_one(db.clone()).await?;
    // Second attempt should fail since it will be duplicate.
    spaceship
        .clone()
        .create()
        .get_one(db.clone())
        .await
        .expect_err("should fail");

    let saved_spaceship = SpaceShip::find_by_id(ss_id.clone())
        .get_one(db.clone())
        .await?;

    assert_eq!(spaceship.id.to_thing(), saved_spaceship.id.to_thing());
    assert_eq!(spaceship.name, saved_spaceship.name);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delete-methods"><a class="header" href="#delete-methods">Delete Methods</a></h1>
<p>Deletion is another crucial CRUD operation, and surreal_orm offers methods to
delete records in various ways.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delete"><a class="header" href="#delete">delete</a></h1>
<p>This method facilitates the deletion of a specific record instance</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_delete() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let spaceship = SpaceShip {
        id: SpaceShip::create_id("num-1".into()),
        name: "spaceship-1".into(),
        created: chrono::Utc::now(),
    };

    let spaceship = spaceship.save().get_one(db.clone()).await?;

    let found_spaceship = SpaceShip::find_by_id(spaceship.id.clone())
        .return_many(db.clone())
        .await?;
    assert_eq!(found_spaceship.len(), 1);

    spaceship.clone().delete().run(db.clone()).await?;

    let found_spaceship = SpaceShip::find_by_id(spaceship.id.clone())
        .return_many(db.clone())
        .await?;

    assert!(found_spaceship.is_empty());
    assert_eq!(found_spaceship.len(), 0);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delete_by_id"><a class="header" href="#delete_by_id">delete_by_id</a></h1>
<h2 id="7-delete_by_id-method-1"><a class="header" href="#7-delete_by_id-method-1">7. <code>delete_by_id</code> Method</a></h2>
<p>If you know the ID of a record you wish to delete, the delete_by_id method makes
the task straightforward.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_delete_by_id() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let spaceship = SpaceShip {
        id: SpaceShip::create_id("num-1".into()),
        name: "spaceship-1".into(),
        created: chrono::Utc::now(),
    };

    let spaceship = spaceship.save().get_one(db.clone()).await?;
    let found_spaceships = SpaceShip::find_by_id(spaceship.id.clone())
        .return_many(db.clone())
        .await?;
    assert_eq!(found_spaceships.len(), 1);

    SpaceShip::delete_by_id(spaceship.id.clone())
        .run(db.clone())
        .await?;

    let found_spaceships = SpaceShip::find_by_id(spaceship.id.clone())
        .return_many(db.clone())
        .await?;
    assert_eq!(found_spaceships.len(), 0);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delete_where"><a class="header" href="#delete_where">delete_where</a></h1>
<h2 id="8-delete_where-method-1"><a class="header" href="#8-delete_where-method-1">8. <code>delete_where</code> Method</a></h2>
<p>For scenarios where you need to delete multiple records based on a condition,
the delete_where method comes in handy.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_delete_where() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let spaceship = SpaceShip {
        id: SpaceShip::create_id("num-1".into()),
        name: "spaceship-1".into(),
        created: chrono::Utc::now(),
    };

    spaceship.save().run(db.clone()).await.unwrap();
    let space_ship::Schema { name, .. } = SpaceShip::schema();

    let found_spaceships = SpaceShip::find_where(name.like("spaceship-1"))
        .return_many(db.clone())
        .await?;
    assert_eq!(found_spaceships.len(), 1);

    SpaceShip::delete_where(name.like("spaceship"))
        .run(db.clone())
        .await?;

    let found_spaceships = SpaceShip::find_where(name.like("spaceship-1"))
        .return_many(db.clone())
        .await?;
    assert_eq!(found_spaceships.len(), 0);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="count-and-aggregation-methods"><a class="header" href="#count-and-aggregation-methods">Count and Aggregation Methods</a></h1>
<p>Counting records and performing aggregate operations are common tasks when
working with databases. surreal_orm provides methods to make these tasks
efficient and easy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="count_where"><a class="header" href="#count_where">count_where</a></h1>
<h2 id="4-count_where-method-1"><a class="header" href="#4-count_where-method-1">4. <code>count_where</code> Method</a></h2>
<p>To count records based on a condition, you can use the count_where method.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_count_where() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    create_test_data(db.clone()).await;
    let weapon::Schema { strength, .. } = &amp;Weapon::schema();

    let weapons_query = Weapon::count_where(strength.gte(500));
    let weapons_count = weapons_query.get(db.clone()).await?;

    assert_eq!(
        weapons_query.to_raw().build(),
        "SELECT VALUE count FROM (SELECT count(strength &gt;= 500) FROM weapon GROUP ALL);"
    );

    assert_eq!(weapons_count, 500);

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="count_all"><a class="header" href="#count_all">count_all</a></h1>
<h2 id="5-count_all-method-1"><a class="header" href="#5-count_all-method-1">5. <code>count_all</code> Method</a></h2>
<p>When you need a count of all records in a table, the count_all method is your
go-to.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_count_all() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    create_test_data(db.clone()).await;

    let weapons_query = Weapon::count_all();
    let weapons_count = weapons_query.get(db.clone()).await?;

    assert_eq!(
        weapons_query.to_raw().build(),
        "SELECT VALUE count FROM (SELECT count() FROM weapon GROUP ALL);"
    );

    assert_eq!(weapons_count, 1000);

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statements"><a class="header" href="#statements">Statements</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-statement"><a class="header" href="#use-statement">Use Statement</a></h1>
<p>The <code>use</code> statement in Surreal ORM is used to switch the active namespace and
database. This documentation provides an overview of the <code>use</code> statement and its
usage.</p>
<h2 id="table-of-contents-5"><a class="header" href="#table-of-contents-5">Table of Contents</a></h2>
<ul>
<li><a href="statements/use.html#introduction">Introduction</a></li>
<li><a href="statements/use.html#syntax">Syntax</a></li>
<li><a href="statements/use.html#examples">Examples</a>
<ul>
<li><a href="statements/use.html#using-the-use-statement-with-namespace">Using the <code>use</code> Statement with Namespace</a></li>
<li><a href="statements/use.html#using-the-use-statement-with-database">Using the <code>use</code> Statement with Database</a></li>
<li><a href="statements/use.html#using-the-use-statement-with-namespace-and-database">Using the <code>use</code> Statement with Namespace and Database</a></li>
</ul>
</li>
</ul>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>The <code>use</code> statement in Surreal ORM allows you to switch the active namespace and
database. By specifying the desired namespace and/or database, you can focus
your queries and operations on specific areas of your database.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>The basic syntax of the <code>use</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use_()
    .namespace(namespace)
    .database(database);
<span class="boring">}</span></code></pre></pre>
<p>The <code>use</code> statement supports the following methods:</p>
<ul>
<li><code>.namespace(namespace)</code>: Specifies the namespace to use.</li>
<li><code>.database(database)</code>: Specifies the database to use.</li>
<li><code>.build()</code>: Builds the <code>use</code> statement.</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="using-the-use-statement-with-namespace"><a class="header" href="#using-the-use-statement-with-namespace">Using the <code>use</code> Statement with Namespace</a></h3>
<p>To switch the active namespace using the <code>use</code> statement, you can use the
following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::statements::use_;
use surreal_orm::models::Namespace;

let use_statement = use_()
    .namespace(Namespace::from("mars".to_string()));

assert_eq!(use_statement, "USE NS mars;");
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the <code>use</code> statement is used to switch the active namespace
to "mars". The resulting use statement is "USE NS mars;".</p>
<h3 id="using-the-use-statement-with-database"><a class="header" href="#using-the-use-statement-with-database">Using the <code>use</code> Statement with Database</a></h3>
<p>To switch the active database using the <code>use</code> statement, you can use the
following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::statements::use_;
use surreal_orm::models::Database;

let use_statement = use_()
    .database(Database::from("root".to_string()));

assert_eq!(use_statement, "USE DB root;");
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the <code>use</code> statement is used to switch the active database
to "root". The resulting use statement is "USE DB root;".</p>
<h3 id="using-the-use-statement-with-namespace-and-database"><a class="header" href="#using-the-use-statement-with-namespace-and-database">Using the <code>use</code> Statement with Namespace and Database</a></h3>
<p>You can also switch both the active namespace and database using the <code>use</code>
statement. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::statements::use_;
use surreal_orm::models::{Namespace, Database};

let use_statement = use_()
    .namespace(Namespace::from("mars".to_string()))
    .database(Database::from("root".to_string()));

assert_eq!(use_statement, "USE DB root NS mars;");
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the <code>use</code> statement is used to switch the active namespace
to "mars" and the active database to "root". The resulting use statement is "USE
DB root NS mars;".</p>
<p>You have now learned how to use the <code>use</code> statement in Surreal ORM to switch the
active namespace and database. This allows you to focus your queries and
operations on specific areas of your database.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-statement"><a class="header" href="#let-statement">Let Statement</a></h1>
<p>The <code>let</code> statement in Surreal ORM allows you to bind variables within a code
block. It simplifies complex queries and enables parameter handling.</p>
<h2 id="table-of-contents-6"><a class="header" href="#table-of-contents-6">Table of Contents</a></h2>
<ul>
<li><a href="statements/let.html#recommended-approach">Recommended Approach</a>
<ul>
<li><a href="statements/let.html#using-let-or-let-statement-within-block-macro">Using <code>let</code> or <code>LET</code> Statement/keyword within <code>block!</code> Macro</a></li>
</ul>
</li>
<li><a href="statements/let.html#less-recommended-approach">Less Recommended Approach</a>
<ul>
<li><a href="statements/let.html#using-let-macro">Using <code>let_!</code> Macro</a></li>
</ul>
</li>
<li><a href="statements/let.html#least-recommended-approach">Least Recommended Approach</a>
<ul>
<li><a href="statements/let.html#using-let-statements-with-let-function">Using <code>let</code> Statements with <code>let_</code> Function</a></li>
</ul>
</li>
</ul>
<h2 id="recommended-approach"><a class="header" href="#recommended-approach">Recommended Approach</a></h2>
<p>In the recommended approach, you can use the <code>let</code> statement within the <code>block!</code>
macro. This approach provides a natural syntax that handles variable bindings
and parameter references automatically.</p>
<h3 id="using-let-or-let-statement-within-block-macro"><a class="header" href="#using-let-or-let-statement-within-block-macro">Using <code>let</code> or <code>LET</code> Statement within <code>block!</code> Macro</a></h3>
<p>To define variables and bind them within a code block, you can use the <code>let</code>
statement (or <code>LET</code> statement) within the <code>block!</code> macro. This approach offers
simplicity and automation in handling variable bindings and parameter
references. Let's take a look at an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let alien = Table::new("alien");
let metrics = Table::new("metrics");
let strength = Field::new("strength");

let code_block = block! {
    let strengths = select_value(strength).from(alien);
    let total = math::sum!(strengths);
    let count = count!(strengths);
    let name = "Oyelowo";
};

// This is equivalent to the above. Note: This is not to be confused with actual Rust's native `let` keyword.

let code_block = block! {
    LET strengths = select_value(strength).from(alien);
    LET total = math::sum!(strengths);
    LET count = count!(strengths);
    LET name = "Oyelowo";
};
<span class="boring">}</span></code></pre></pre>
<p>In the code snippet above, the <code>let</code> (or <code>LET</code>) statements bind the variables
<code>strengths</code>, <code>total</code>, <code>count</code>, and <code>name</code> within the code block. These variables
are automatically handled by the ORM, simplifying the query construction
process.</p>
<p>The generated SQL query for this code block would look like:</p>
<pre><code class="language-sql">LET $strengths = (SELECT VALUE strength FROM alien);

LET $total = math::sum($strengths);

LET $count = count($strengths);

LET $name = 'Oyelowo';
</code></pre>
<p>The recommended approach using the <code>let</code> statement (or <code>LET</code> statement) within
the <code>block!</code> macro is preferred because it provides a clean and concise syntax,
handles variable bindings and parameter referencing automatically, and promotes
code readability.</p>
<h2 id="less-recommended-approach"><a class="header" href="#less-recommended-approach">Less Recommended Approach</a></h2>
<p>The less recommended approach involves using the <code>let_!</code> macro to bind variables
manually within a code block. Although it provides flexibility, it requires more
manual handling of parameters and can be error-prone.</p>
<p><a name="using-let-macro"></a></p>
<h3 id="using-let_-macro"><a class="header" href="#using-let_-macro">Using <code>let_!</code> Macro</a></h3>
<p>Here's an example of using the <code>let_!</code> macro to define variables within a code
block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let_!(strengths = select_value(strength).from(alien));
let_!(total = math::sum!(strengths));
let_!(count = count!(strengths));
let_!(name = "Oyelowo");
chain(strengths).chain(total).chain(count).chain(name)
<span class="boring">}</span></code></pre></pre>
<p>In the code snippet above, the <code>let_!</code>macro is used to bind
variables<code>strengths</code>, <code>total</code>, <code>count</code>, and <code>name</code>within the code block. The
variables are manually defined and then chained together using the<code>chain</code>
function.</p>
<p>The generated SQL query for this code block would look like:</p>
<pre><code class="language-sql">LET $strengths = (SELECT VALUE strength FROM alien);

LET $total = math::sum($strengths);

LET $count = count($strengths);

LET $name = 'Oyelowo';
</code></pre>
<p>The less recommended approach using the <code>let_!</code> macro requires explicit
definition and chaining of variables, making the code more complex and
error-prone compared to the recommended approach.</p>
<h2 id="least-recommended-approach"><a class="header" href="#least-recommended-approach">Least Recommended Approach</a></h2>
<p>The least recommended approach involves using the <code>let</code> statements with the
<code>let_</code> function to bind variables manually within a code block. This approach
requires even more manual handling of parameters and is prone to errors.</p>
<p><a name="using-let-statements-with-let-function"></a></p>
<h3 id="using-let-statements-with-let_-function"><a class="header" href="#using-let-statements-with-let_-function">Using <code>let</code> Statements with <code>let_</code> Function</a></h3>
<p>Here's another example of using the <code>let</code> statements with the <code>let_</code> function to
bind variables within a code block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let strengths = let_("strengths").equal_to(select_value(strength).from(alien));
let total = let_("total").equal_to(math::sum!(strengths));
let count = let_("count").equal_to(count!(strengths));
let name = let_("name").equal_to("Oyelowo");
chain(strengths).chain(total).chain(count).chain(name);
<span class="boring">}</span></code></pre></pre>
<p>In this example, the <code>let_</code> function is used to define variables <code>strengths</code>,
<code>total</code>, <code>count</code>, and <code>name</code> within the code block. The variables are manually
defined and then chained together using the <code>chain</code> function.</p>
<p>The generated SQL query for this code block would look like:</p>
<pre><code class="language-sql">LET $strengths = (SELECT VALUE strength FROM alien);

LET $total = math::sum($strengths);

LET $count = count($strengths);

LET $name = 'Oyelowo';
</code></pre>
<p>Similar to the previous approach, the use of <code>let</code> statements with the <code>let_</code>
function in the least recommended approach requires explicit variable definition
and chaining, making the code more complex and error-prone.</p>
<p>It is generally recommended to use the recommended approach with the <code>let</code>
statement (or <code>LET</code> statement) within the <code>block!</code> macro for better readability,
automation of variable bindings, and parameter handling.</p>
<p>That concludes the documentation for the <code>let</code> statement in Surreal ORM. Use the
recommended approach to simplify complex queries and handle variable bindings
effortlessly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="begin"><a class="header" href="#begin">Begin</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cancel-statement"><a class="header" href="#cancel-statement">Cancel Statement</a></h1>
<p>The <code>cancel</code> statement in Surreal ORM is used to cancel and rollback a
transaction, discarding any changes made within the transaction. It ensures that
the database remains unaffected by the transaction.</p>
<h2 id="table-of-contents-7"><a class="header" href="#table-of-contents-7">Table of Contents</a></h2>
<ul>
<li><a href="statements/cancel.html#recommended-approaches">Recommended Approaches</a>
<ul>
<li><a href="statements/cancel.html#using-block-macro-with-cancel-statement-also-within-block-for-chaining-multiple-statements">Using <code>block!</code> Macro with Cancel Statement also Within Block for Chaining Multiple Statements</a></li>
<li><a href="statements/cancel.html#using-block-macro-for-chaining-multiple-statements">Using <code>block!</code> Macro for Chaining Multiple Statements</a></li>
</ul>
</li>
<li><a href="statements/cancel.html#less-recommended-approach">Less Recommended Approach</a>
<ul>
<li><a href="statements/cancel.html#chaining-multiple-statements-directly">Chaining Multiple Statements Directly</a></li>
</ul>
</li>
</ul>
<h2 id="recommended-approaches"><a class="header" href="#recommended-approaches">Recommended Approaches</a></h2>
<h3 id="using-block-macro-with-cancel-statement-also-within-block-for-chaining-multiple-statements"><a class="header" href="#using-block-macro-with-cancel-statement-also-within-block-for-chaining-multiple-statements">Using <code>block!</code> Macro with Cancel Statement also Within Block for Chaining Multiple Statements</a></h3>
<p>To perform a transaction and cancel it, discarding any changes made within the
transaction, you can use the <code>block!</code> macro to chain multiple statements
together. The <code>cancel_transaction</code> statement is used within the <code>block!</code> macro
to explicitly indicate the cancellation of the transaction. Let's take a look at
an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
db.use_ns("test").use_db("test").await.unwrap();

let ref id1 = Account::create_id("one".into());
let ref id2 = Account::create_id("two".into());
let acc = Account::schema();

let amount_to_transfer = 300.00;

block! {
    BEGIN TRANSACTION;

    LET acc1 = create().content(Account {
        id: id1.clone(),
        balance: 135_605.16,
    });
    LET acc2 = create().content(Account {
        id: id2.clone(),
        balance: 91_031.31,
    });

    LET updated1 = update::&lt;Account&gt;(id1).set(acc.balance.increment_by(amount_to_transfer));
    LET update2 = update::&lt;Account&gt;(id2).set(acc.balance.decrement_by(amount_to_transfer));

    CANCEL TRANSACTION;
};

Ok(())
<span class="boring">}</span></code></pre></pre>
<p>In the code snippet above, the <code>block!</code> macro is used to define a transaction
with multiple statements. The <code>LET</code> statement is used to bind variables <code>acc1</code>,
<code>acc2</code>, <code>updated1</code>, and <code>update2</code> to the respective statements. The
<code>BEGIN TRANSACTION</code> statement marks the start of the transaction, and the
<code>CANCEL TRANSACTION</code> statement explicitly cancels the transaction.</p>
<p>The generated SQL query for this code block would look like:</p>
<pre><code class="language-sql">BEGIN TRANSACTION;

LET acc1 = CREATE account CONTENT { balance: 135605.16, id: account:one };
LET acc2 = CREATE account CONTENT { balance: 91031.31, id: account:two };
LET updated1 = UPDATE account:one SET balance += 300.0;
LET update2 = UPDATE account:two SET balance -= 300.0;

CANCEL TRANSACTION;
</code></pre>
<p>Using the <code>block!</code> macro with the <code>cancel_transaction</code> statement within the
block provides a clear and concise way to define a transaction and cancel it.</p>
<h3 id="using-block-macro-for-chaining-multiple-statements"><a class="header" href="#using-block-macro-for-chaining-multiple-statements">Using <code>block!</code> Macro for Chaining Multiple Statements</a></h3>
<p>Another recommended approach is to use the <code>block!</code> macro to chain multiple
statements together within a transaction. The <code>cancel_transaction</code> statement is
called separately after the <code>block!</code> macro to explicitly cancel the transaction.
Let's see an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
db.use_ns("test").use_db

("test").await.unwrap();

let ref id1 = Account::create_id("one".into());
let ref id2 = Account::create_id("two".into());
let acc = Account::schema();

let amount_to_transfer = 300.00;

let transaction_query = begin_transaction()
    .query(block! {
        LET acc1 = create().content(Account {
            id: id1.clone(),
            balance: 135_605.16,
        });
        LET acc2 = create().content(Account {
            id: id2.clone(),
            balance: 91_031.31,
        });

        LET updated1 = update::&lt;Account&gt;(id1).set(acc.balance.increment_by(amount_to_transfer));
        LET update2 = update::&lt;Account&gt;(id2).set(acc.balance.decrement_by(amount_to_transfer));
    })
    .cancel_transaction();

transaction_query.run(db.clone()).await?;

// Assertions and other code...

Ok(())
<span class="boring">}</span></code></pre></pre>
<p>In this approach, the <code>block!</code> macro is used to define a transaction with
multiple statements. The <code>LET</code> statement is used to bind variables to the
statements within the block. After the <code>block!</code> macro, the <code>cancel_transaction</code>
statement is called separately to cancel the transaction.</p>
<p>The generated SQL query for this code block would be the same as the previous
approach.</p>
<p>Using the <code>block!</code> macro for chaining multiple statements and explicitly
canceling the transaction provides a structured and organized way to handle
complex transactions.</p>
<h2 id="less-recommended-approach-1"><a class="header" href="#less-recommended-approach-1">Less Recommended Approach</a></h2>
<p>The less recommended approach involves chaining multiple statements directly
without using the <code>block!</code> macro. Although functional, this approach may feel
less ergonomic, especially when there is a need to bind and share variables
within the statements.</p>
<h3 id="chaining-multiple-statements-directly"><a class="header" href="#chaining-multiple-statements-directly">Chaining Multiple Statements Directly</a></h3>
<p>Here's an example of chaining multiple statements directly without using the
<code>block!</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_transaction_cancel_increment_and_decrement_update() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let ref id1 = Account::create_id("one".into());
    let ref id2 = Account::create_id("two".into());
    let amount_to_transfer = 300.00;

    let acc = Account::schema();

    begin_transaction()
        .query(create().content(Account {
            id: id1.clone(),
            balance: 135_605.16,
        }))
        .query(create().content(Account {
            id: id2.clone(),
            balance: 91_031.31,
        }))
        .query(update::&lt;Account&gt;(id1).set(acc.balance.increment_by(amount_to_transfer)))
        .query(update::&lt;Account&gt;(id2).set(acc.balance.decrement_by(amount_to_transfer)))
        .cancel_transaction()
        .run(db.clone())
        .await?;

    // Assertions and other code...

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>In this approach, multiple statements are chained directly within the
transaction. The <code>create</code> and <code>update</code> statements are used to perform operations
on the <code>Account</code> table.</p>
<p>The generated SQL query for this code block would be the same as the previous
approaches.</p>
<p>The less recommended approach of chaining multiple statements directly can be
less ergonomic, especially when dealing with complex transactions that require
variable bindings and subqueries.</p>
<p>It is generally recommended to use the recommended approaches with the <code>block!</code>
macro for better readability, automation of variable bindings, and subquery
handling.</p>
<p>That concludes the documentation for the <code>cancel</code> statement in Surreal ORM. Use
the recommended approaches to perform transaction cancellation effectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commit-statement"><a class="header" href="#commit-statement">Commit Statement</a></h1>
<p>The <code>commit</code> statement in Surreal ORM is used to commit a transaction and save
the changes made within the transaction. It ensures that the changes are durable
and permanent in the database.</p>
<h2 id="table-of-contents-8"><a class="header" href="#table-of-contents-8">Table of Contents</a></h2>
<ul>
<li><a href="statements/commit.html#recommended-approaches">Recommended Approaches</a>
<ul>
<li><a href="statements/commit.html#using-block-macro-with-commit-statement-also-within-block-for-chaining-multiple-statements">Using <code>block!</code> Macro with Commit Statement also Within Block for Chaining Multiple Statements</a></li>
<li><a href="statements/commit.html#using-block-macro-for-chaining-multiple-statements">Using <code>block!</code> Macro for Chaining Multiple Statements</a></li>
</ul>
</li>
<li><a href="statements/commit.html#less-recommended-approach">Less Recommended Approach</a>
<ul>
<li><a href="statements/commit.html#chaining-multiple-statements-directly">Chaining Multiple Statements Directly</a></li>
</ul>
</li>
</ul>
<h2 id="recommended-approaches-1"><a class="header" href="#recommended-approaches-1">Recommended Approaches</a></h2>
<h3 id="using-block-macro-with-commit-statement-also-within-block-for-chaining-multiple-statements"><a class="header" href="#using-block-macro-with-commit-statement-also-within-block-for-chaining-multiple-statements">Using <code>block!</code> Macro with Commit Statement also Within Block for Chaining Multiple Statements</a></h3>
<p>To perform a transaction and commit the changes, you can use the <code>block!</code> macro
to chain multiple statements together. The <code>commit_transaction</code> statement is
used within the <code>block!</code> macro to explicitly indicate the commitment of the
transaction. Let's take a look at an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
db.use_ns("test").use_db("test").await.unwrap();

let ref id1 = Account::create_id("one".into());
let ref id2 = Account::create_id("two".into());
let acc = Account::schema();

let amount_to_transfer = 300.00;

block! {
    BEGIN TRANSACTION;

    LET acc1 = create().content(Account {
        id: id1.clone(),
        balance: 135_605.16,
    });
    LET acc2 = create().content(Account {
        id: id2.clone(),
        balance: 91_031.31,
    });

    LET updated1 = update::&lt;Account&gt;(id1).set(acc.balance.increment_by(amount_to_transfer));
    LET update2 = update::&lt;Account&gt;(id2).set(acc.balance.decrement_by(amount_to_transfer));

    COMMIT TRANSACTION;
};

Ok(())
<span class="boring">}</span></code></pre></pre>
<p>In the code snippet above, the <code>block!</code> macro is used to define a transaction
with multiple statements. The <code>LET</code> statement is used to bind variables <code>acc1</code>,
<code>acc2</code>, <code>updated1</code>, and <code>update2</code> to the respective statements. The
<code>BEGIN TRANSACTION</code> statement marks the start of the transaction, and the
<code>COMMIT TRANSACTION</code> statement explicitly commits the transaction.</p>
<p>The generated SQL query for this code block would look like:</p>
<pre><code class="language-sql">BEGIN TRANSACTION;

LET acc1 = CREATE account CONTENT { balance: 135605.16, id: account:one };
LET acc2 = CREATE account CONTENT { balance: 91031.31, id: account:two };
LET updated1 = UPDATE account:one SET balance += 300.0;
LET update2 = UPDATE account:two SET balance -= 300.0;

COMMIT TRANSACTION;
</code></pre>
<p>Using the <code>block!</code> macro with the <code>commit_transaction</code> statement within the
block provides a clear and concise way to define a transaction and commit the
changes.</p>
<h3 id="using-block-macro-for-chaining-multiple-statements-1"><a class="header" href="#using-block-macro-for-chaining-multiple-statements-1">Using <code>block!</code> Macro for Chaining Multiple Statements</a></h3>
<p>Another recommended approach is to use the <code>block!</code> macro to chain multiple
statements together within a transaction. The <code>commit_transaction</code> statement is
called separately after the <code>block!</code> macro to explicitly commit the transaction.
Let's see an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
db.use_ns("test").use_db("test").await.unwrap();

let ref id1 = Account

::create_id("one".into());
let ref id2 = Account::create_id("two".into());
let acc = Account::schema();

let amount_to_transfer = 300.00;

let transaction_query = begin_transaction()
    .query(block! {
        LET acc1 = create().content(Account {
            id: id1.clone(),
            balance: 135_605.16,
        });
        LET acc2 = create().content(Account {
            id: id2.clone(),
            balance: 91_031.31,
        });

        LET updated1 = update::&lt;Account&gt;(id1).set(acc.balance.increment_by(amount_to_transfer));
        LET update2 = update::&lt;Account&gt;(id2).set(acc.balance.decrement_by(amount_to_transfer));
    })
    .commit_transaction();

transaction_query.run(db.clone()).await?;

Ok(())
<span class="boring">}</span></code></pre></pre>
<p>In this approach, the <code>block!</code> macro is used to define a transaction block that
includes multiple statements. The <code>BEGIN TRANSACTION</code> and <code>COMMIT TRANSACTION</code>
statements mark the start and end of the transaction, respectively. The <code>LET</code>
statement is used to bind variables to the statements within the block.</p>
<p>The generated SQL query for this code block would be the same as the previous
approach.</p>
<p>Using the <code>block!</code> macro for chaining multiple statements and explicitly
committing the transaction provides a more structured and organized way to
handle complex transactions.</p>
<h2 id="less-recommended-approach-2"><a class="header" href="#less-recommended-approach-2">Less Recommended Approach</a></h2>
<p>The less recommended approach involves chaining multiple statements directly
without using the <code>block!</code> macro. Although functional, this approach may feel
less ergonomic, especially when there is a need to bind and share variables
within the statements.</p>
<h3 id="chaining-multiple-statements-directly-1"><a class="header" href="#chaining-multiple-statements-directly-1">Chaining Multiple Statements Directly</a></h3>
<p>Here's an example of chaining multiple statements directly without using the
<code>block!</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_transaction_commit_increment_and_decrement_update() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let ref id1 = Account::create_id("one".into());
    let ref id2 = Account::create_id("two".into());
    let amount_to_transfer = 300.00;

    let acc = Account::schema();

    begin_transaction()
        .query(create().content(Account {
            id: id1.clone(),
            balance: 135_605.16,
        }))
        .query(create().content(Account {
            id: id2.clone(),
            balance: 91_031.31,
        }))
        .query(update::&lt;Account&gt;(id1).set(acc.balance.increment_by(amount_to_transfer)))
        .query(update::&lt;Account&gt;(id2).set(acc.balance.decrement_by(amount_to_transfer)))
        .commit_transaction()
        .run(db.clone())
        .await?;

    // Assertions and other code...

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>In this approach, multiple statements are chained directly within the
transaction. The <code>create</code> and <code>update</code> statements are used to perform operations
on the <code>Account</code> table.</p>
<p>The generated SQL query for this code block would be the same as the previous
approaches.</p>
<p>The less recommended approach of chaining multiple statements directly can be
less ergonomic, especially when dealing with complex transactions that require
variable bindings and subqueries.</p>
<p>It is generally recommended to use the recommended approaches with the <code>block!</code>
macro for better readability, automation of variable bindings, and subquery
handling.</p>
<p>That concludes the documentation for the <code>commit</code> statement in Surreal ORM. Use
the recommended approaches to perform transactions and commit changes
effectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ifelse-statement"><a class="header" href="#ifelse-statement">IfElse Statement</a></h1>
<p>The <code>ifelse</code> statement is used to create conditional branching in SurrealDB. It allows you to execute different expressions or statements based on specified conditions. Here are some examples and usage scenarios for the <code>ifelse</code> statement.</p>
<h2 id="table-of-contents-9"><a class="header" href="#table-of-contents-9">Table of Contents</a></h2>
<ul>
<li><a href="statements/if_else.html#statement-syntax">Statement Syntax</a></li>
<li><a href="statements/if_else.html#creating-an-if-statement">Creating an If Statement</a></li>
<li><a href="statements/if_else.html#adding-else-if-statements">Adding Else If Statements</a></li>
<li><a href="statements/if_else.html#adding-an-else-statement">Adding an Else Statement</a></li>
<li><a href="statements/if_else.html#nested-if-else-statements">Nested If Else Statements</a></li>
<li><a href="statements/if_else.html#using-subqueries-in-if-else-statements">Using Subqueries in If Else Statements</a></li>
</ul>
<h2 id="statement-syntax"><a class="header" href="#statement-syntax">Statement Syntax</a></h2>
<p>The syntax for the <code>ifelse</code> statement is as follows:</p>
<pre><code class="language-rust  ignore">if_(condition)
    .then(expression)
    .else_if(condition)
    .then(expression)
    .else_if(condition)
    .then(expression)
    .else_(expression)
    .end();</code></pre>
<h2 id="creating-an-if-statement"><a class="header" href="#creating-an-if-statement">Creating an If Statement</a></h2>
<p>You can create a simple <code>if</code> statement using the <code>if_</code> function. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::*;

let age = Field::new("age");

let if_statement = if_(age.greater_than_or_equal(18))
    .then("Valid".to_string())
    .end();
<span class="boring">}</span></code></pre></pre>
<h2 id="adding-else-if-statements"><a class="header" href="#adding-else-if-statements">Adding Else If Statements</a></h2>
<p>You can add multiple <code>else if</code> statements to the <code>ifelse</code> statement. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = Field::new("name");
let age = Field::new("age");

let if_statement = if_(age.greater_than_or_equal(18))
    .then("Valid")
    .else_if(name.like("Oyelowo Oyedayo"))
    .then("The Alien!")
    .end();
<span class="boring">}</span></code></pre></pre>
<h2 id="adding-an-else-statement"><a class="header" href="#adding-an-else-statement">Adding an Else Statement</a></h2>
<p>You can add an <code>else</code> statement to the <code>ifelse</code> statement to handle cases when none of the previous conditions are met. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let age = Field::new("age");

let if_statement = if_(age.greater_than_or_equal(18))
    .then("Valid")
    .else_("Invalid")
    .end();
<span class="boring">}</span></code></pre></pre>
<h2 id="nested-if-else-statements"><a class="header" href="#nested-if-else-statements">Nested If Else Statements</a></h2>
<p>You can nest <code>ifelse</code> statements within each other to create complex conditional logic. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = Field::new("name");
let age = Field::new("age");
let country = Field::new("country");

let if_statement = if_(age.greater_than_or_equal(18))
    .then("Valid")
    .else_if(name.like("Oyelowo Oyedayo"))
    .then("The Alien!")
    .else_if(cond(country.is("Canada")).or(country.is("Norway")))
    .then("Cold")
    .else_("Hot")
    .end();
<span class="boring">}</span></code></pre></pre>
<h2 id="using-subqueries-in-if-else-statements"><a class="header" href="#using-subqueries-in-if-else-statements">Using Subqueries in If Else Statements</a></h2>
<p>You can use subqueries in the <code>ifelse</code> statement to execute more complex expressions or statements. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = Field::new("name");
let age = Field::new("age");
let country = Field::new("country");
let city = Field::new("city");
let fake_id = sql::Thing::from(("user".to_string(), "oyelowo".to_string()));
let fake_id2 = sql::Thing::from(("user".to_string(), "oyedayo".to_string()));

let statement1 = select(All)
    .from(fake_id)
    .where_(
        cond(city.is("Prince Edward Island"))
            .and(city.is("NewFoundland"))
            .or(city.like("Toronto")),
    )
    .order_by(order(&amp;age).numeric())
    .limit(153)
    .start(10)
    .parallel();

let statement2 = select(All)
    .from(fake_id2)
    .where_(country.is("INDONESIA"))
    .order_by(order(&amp;age).numeric())
    .limit(20)
    .start(5);

let if_statement = if_(age.greater_than_or_equal(18).less_than_or_equal(120))
    .then(statement1)
    .else_if(name.like("Oyelowo Oyedayo"))
    .then(statement2)
    .else_if(cond(country.is("Canada"))
            .or(country.is("Norway")))
    .then("Cold")
    .else_("Hot")
    .end();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="surreal-orm-documentation-1"><a class="header" href="#surreal-orm-documentation-1">Surreal ORM Documentation</a></h1>
<h2 id="table-of-contents-10"><a class="header" href="#table-of-contents-10">Table of Contents</a></h2>
<ol>
<li><a href="statements/select.html#introduction">Introduction</a></li>
<li><a href="statements/select.html#defining-data">Defining Your Data</a></li>
<li><a href="statements/select.html#advanced-schema">Advanced Schema Definitions</a></li>
<li><a href="statements/select.html#select-statements">Select Statements</a>
<ul>
<li><a href="statements/select.html#using-the-cond-macro">Using the cond! Macro</a></li>
</ul>
</li>
<li><a href="statements/select.html#advanced-select-queries">Advanced Select Queries</a></li>
<li><a href="statements/select.html#select-value-statements">Select Value Statements</a></li>
<li><a href="statements/select.html#advanced-select-value-queries">Advanced Select Value Queries</a></li>
<li><a href="statements/select.html#running-select-statements">Running Select Statements</a></li>
<li><a href="statements/select.html#running-and-returning-from-a-select-statement">Running and Returning from a Select Statement</a></li>
</ol>
<p><a name="introduction"></a></p>
<h2 id="1-introduction-1"><a class="header" href="#1-introduction-1">1. Introduction</a></h2>
<p>This document focuses on defining models and using <code>select</code> and <code>select_value</code>
statements for data retrieval.</p>
<p><a name="defining-data"></a></p>
<h2 id="2-defining-your-data"><a class="header" href="#2-defining-your-data">2. Defining Your Data</a></h2>
<p>Start by defining a <code>User</code> struct representing a user in your application.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate surreal_orm;
use surreal_orm::*;

#[derive(Node, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
#[orm(table = "user")]
pub struct User {
    pub id: SurrealSimpleId&lt;Self&gt;,
    pub account: String,
    pub friend: String,
}
<span class="boring">}</span></code></pre></pre>
<p><a name="advanced-schema"></a></p>
<h2 id="3-advanced-schema-definitions"><a class="header" href="#3-advanced-schema-definitions">3. Advanced Schema Definitions</a></h2>
<p>Surreal ORM supports more complex data types including links between different
models. Here's a detailed example using a <code>Student</code> and a <code>Book</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Node, Serialize, Deserialize)]
#[orm(table = "student")]
pub struct Student {
    id: SurrealSimpleId&lt;Self&gt;,
    first_name: String,
    last_name: String,
    age: u8,

    #[orm(link_self = "Student")]
    best_friend: LinkSelf&lt;Student&gt;,

    #[orm(link_one = "Book")]
    fav_book: LinkOne&lt;Book&gt;,

    #[orm(link_one = "Book")]
    course: LinkOne&lt;Book&gt;,

    #[orm(link_many = "Book")]
    sem_courses: LinkMany&lt;Book&gt;,
}

#[derive(Node, Serialize, Deserialize)]
#[orm(table = "book")]
pub struct Book {
    id: SurrealSimpleId&lt;Self&gt;,
    content: String,
}
<span class="boring">}</span></code></pre></pre>
<p><a name="select-statements"></a></p>
<h2 id="4-select-statements"><a class="header" href="#4-select-statements">4. Select Statements</a></h2>
<p><code>select</code> allows you to construct a SELECT statement to fetch records.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, statements::{order, select}};

let student::Schema {
    id,
    first_name,
    last_name,
    best_friend,
    uno_book,
    course,
    sem_courses,
    ref age,
    ..
} = &amp;Student::schema();

let book::Schema { ref content, .. } = Book::schema();

let mut statement = select(arr![age, last_name, content])
    .from(Book::table())
    .where_(
        cond(content.like("lowo"))
            .and(age.greater_than_or_equal(600))
            .or(first_name.equal("Oyelowo"))
            .and(last_name.equal("Oyedayo")),
    )
    .order_by(last_name.desc()
    .limit(50)
    .start(20)
    .timeout(Duration::from_secs(9))
    .parallel();

let is_lowo = true;
if is_lowo {
    statement = statement.limit(55).order_by(age.desc());
}
<span class="boring">}</span></code></pre></pre>
<p><a name="using-the-cond-macro"></a></p>
<h3 id="using-the-cond-macro"><a class="header" href="#using-the-cond-macro">Using the cond! Macro</a></h3>
<p>In Surreal ORM, while the <code>cond</code> function provides an elegant way to construct
filters, there's also a macro alternative called <code>cond!</code>. This macro can offer
more concise and readable representations, especially for complex conditions.</p>
<p>The <code>cond!</code> macro provides a convenient syntax for constructing filters, similar
to standard Rust conditional expressions. It can handle various operations like
equalities, inequalities, and logical combinations.</p>
<p>Here's a simple example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_query_builder as surreal_orm;
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let age = Field::new("age");
</span><span class="boring">let name = Field::new("name");
</span><span class="boring">let title = Field::new("title");
</span>
let filter_simple = cond!(age &gt; 18);
let filter_compound = cond!((age &gt; 18) AND (name ~ "%Oyelowo%") OR (title == "Professor"));
let filter_mixed = cond!((age.or(4).or(545).or(232)) OR (title = "Professor") AND (age &lt; 100));
<span class="boring">}</span></code></pre></pre>
<p>This macro provides a more intuitive way of writing conditions, especially when
compared to chaining methods. The full definition and capabilities of the
<code>cond!</code> macro are documented within the Surreal ORM codebase.</p>
<p><a name="advanced-select-queries"></a></p>
<h2 id="5-advanced-select-queries"><a class="header" href="#5-advanced-select-queries">5. Advanced Select Queries</a></h2>
<p>You can perform complex queries including nested select statements and
conditional query generation. Here is an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, statements::{order, select}};

let student::Schema {
    id,
    firstName,
    lastName,
    bestFriend,
    unoBook,
    course,
    semCoures,
    ref age,
    ..
} = &amp;Student::schema();

let book::Schema { ref content, .. } = Book::schema();
let ref student_table = Student::get_table();
let ref book_table = Book::get_table();
let ref book_id = thing("book:1").unwrap();

let mut query1 = select(arr![age, lastName, content])
    .from(Book::get_table())
    .where_(
        cond(content.like("lowo"))
            .and(age.greater_than_or_equal(600))
            .or(firstName.equal("Oyelowo"))
            .and(lastName.equal("Oyedayo")),
    )
    .order_by(lastName.desc())
    .limit(50)
    .start(20)
    .timeout(Duration::from_secs(9))
    .parallel();

let statement = select(All)
    .from(student_table)
    // .from(&amp;[student_table, book_table])
    // .from(book_id)
    // .from(query1)
    .where_(
        cond(
            (((age + 5) - 6) * 10).greater_then(5) // You can even use raw mathematical operators directly.
        )
        .and(bestFriend.exactly_equal("Oyelowo"))
        .or(firstName.equal("Oyedayo"))
        .and(age.greater_than_or_equal(150)),
    )
    .order_by(firstName.rand().desc())
    // .order_by(lastName.collate().asc())
    // .order_by(id.numeric().desc())
    // .group_by(course)
    // .group_by(firstName)
    // .group_by(arr![lastName, unoBook])
    .start(5)
    .limit(400)
    .fetch(firstName)
    // .fetch(lastName)
    // .fetch(arr![age, unoBook])
    .split(lastName)
    // .split(firstName)
    // .split(arr![firstName, semCoures])
    .timeout(Duration::from_secs(8))
    .parallel();

let is_oyelowo = true;
if is_oyelowo {
    query = query.group_by(arr![age, bestFriend, &amp;Field::new("dayo")]);
}
<span class="boring">}</span></code></pre></pre>
<p><a name="select-value-statements"></a></p>
<h2 id="6-select-value-statements"><a class="header" href="#6-select-value-statements">6. Select Value Statements</a></h2>
<p><code>select_value</code> is similar to <code>select</code> but it only returns the first column from
the result. Here is a basic usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let statement = select_value(account)
    .from(user)
    .where_(account.is("abc"));
<span class="boring">}</span></code></pre></pre>
<p><a name="advanced-select-value-queries"></a></p>
<h2 id="7-advanced-select-value-queries"><a class="header" href="#7-advanced-select-value-queries">7. Advanced Select Value Queries</a></h2>
<p>You can perform complex value queries as well. Here is an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let statement = select_value(account)
    .from(user)
    .where_(
        and(
            account.is("abc"),
            or(
                friend.is("xyz"),
                friend.is("lmn"),
            ),
        ),
    );

let statement = select_value(account)
    .from(user)
    .where_(
        not(account.is("def")),
    );
<span class="boring">}</span></code></pre></pre>
<p><a name="running-select-statements"></a></p>
<h2 id="8-running-select-statements"><a class="header" href="#8-running-select-statements">8. Running Select Statements</a></h2>
<p>Executing a select statement is straightforward. Here's an example that uses
<code>return_many</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate surreal_orm;
use surreal_orm::{*, statements::{select, insert}};

#[derive(Node, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
#[orm(table = "weapon")]
pub struct Weapon {
    pub name: String,
    pub strength: i32,
    pub created: chrono::DateTime&lt;chrono::Utc&gt;,
}

let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
db.use_ns("test").use_db("test").await.unwrap();

let generated_weapons = (1..=10)
    .map(|i| Weapon {
        name: format!("Weapon {}", i),
        strength: i * 10,
        created: chrono::Utc::now(),
        ..Default::default()
    })
    .collect::&lt;Vec&lt;_&gt;&gt;();
insert(generated_weapons.clone()).run(db.clone()).await?;

let ref weapon = Weapon::table();
let weapon::Schema { ref strength, .. } = &amp;Weapon::schema();

let statement = select(All)
    .from(weapon)
    .where_(
        strength.inside(
            select_value(strength)
                .from(weapon)
                .order_by(strength.asc())
                .limit(6),
        ),
    )
    .order_by(strength.desc())
    .start(2)
    .limit(10);

assert_eq!(
    statement.to_raw().build(),
    "SELECT * FROM weapon WHERE strength INSIDE \
        (SELECT VALUE strength FROM weapon ORDER BY strength LIMIT 6) \
        ORDER BY strength DESC LIMIT 10 START AT 2;"
);
let result = statement.return_many::&lt;Weapon&gt;(db.clone()).await?;

assert_eq!(&amp;result[0].name, "Weapon 4");
assert_eq!(&amp;result[1].name, "Weapon 3");
assert_eq!(&amp;result[2].name, "Weapon 2");
assert_eq!(&amp;result[3].name, "Weapon 1");

assert_eq!(result.len(), 4);
assert!(result[0].id.to_string().starts_with("weapon:"));
Ok(())
<span class="boring">}</span></code></pre></pre>
<p>This example first inserts generated weapon data into the database. Then it
constructs a <code>select</code> statement and retrieves the weapons whose <code>strength</code> is in
the top 6, ordered by <code>strength</code> in descending order, and returns the results
from the third entry. The <code>return_many</code> function is used to run the statement
and get the result.</p>
<p><a name="running-and-returning-from-a-select-statement"></a></p>
<h2 id="9-running-and-returning-from-a-select-statement"><a class="header" href="#9-running-and-returning-from-a-select-statement">9. Running and Returning from a Select Statement</a></h2>
<p>The Surreal ORM package provides the <code>ReturnableSelect</code> trait that defines
several functions to run a select statement and return results in different
ways. These functions include <code>return_none</code>, <code>return_first</code>, <code>return_one</code>,
<code>return_one_unchecked</code>, and <code>return_many</code>.</p>
<p>All these functions run the statement against the SurrealDB database and return
results:</p>
<ul>
<li><code>return_none</code>: Returns no result.</li>
<li><code>return_first</code>: Returns the first result.</li>
<li><code>return_one</code>: Returns one result.</li>
<li><code>return_one_unchecked</code>: Returns one result without checking if it's
successful.</li>
<li><code>return_many</code>: Returns many results.</li>
<li><code>run</code>: Runs the query and provide more flexible deserialization just like
surrealdb native drive e.g <code>.run(db).take::&lt;T&gt;(0)</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="surreal-orm---insertion-operations"><a class="header" href="#surreal-orm---insertion-operations">Surreal ORM - Insertion Operations</a></h1>
<p>Surreal ORM provides various options to perform data insertion operations in
your database. This guide focuses on three main operations:</p>
<p><strong>Table of Contents</strong></p>
<ol>
<li><a href="statements/insert.html#Inserting-Single-Record">Inserting Single Record</a></li>
<li><a href="statements/insert.html#Inserting-Multiple-Records">Inserting Multiple Records</a></li>
<li><a href="statements/insert.html#Inserting-from-Another-Table">Inserting from Another Table</a></li>
</ol>
<hr />
<p><a name="Inserting-Single-Record"></a></p>
<h2 id="inserting-single-record"><a class="header" href="#inserting-single-record">Inserting Single Record</a></h2>
<p>The ORM allows for inserting a single record into a database table. Below is an
example of this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Required imports
use surrealdb::Surreal;
use surrealdb::engine::local::Mem;
use surreal_models::Weapon;
use surreal_orm::statements::insert;
use chrono::Utc;

// Initialize SurrealDB with the in-memory engine
let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
db.use_ns("test").use_db("test").await.unwrap();

// Define a single weapon
let weapon = Weapon {
    name: String::from("Excalibur"),
    created: Utc::now(),
    strength: 1000,
    ..Default::default()
};

// Insert the weapon into the database
let created_weapon = insert(weapon).return_one(db.clone()).await.unwrap();

// Verify the inserted record
assert_eq!(created_weapon.name, "Excalibur");
assert_eq!(created_weapon.strength, 1000);
<span class="boring">}</span></code></pre></pre>
<p>This code creates a single <code>Weapon</code> record with the name "Excalibur" and a
strength of 1000.</p>
<hr />
<p><a name="Inserting-Multiple-Records"></a></p>
<h2 id="inserting-multiple-records"><a class="header" href="#inserting-multiple-records">Inserting Multiple Records</a></h2>
<p>In addition to inserting single records, Surreal ORM also supports inserting
multiple records at once. Here is an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Required imports
use surrealdb::Surreal;
use surrealdb::engine::local::Mem;
use surreal_models::Weapon;
use surreal_orm::statements::insert;
use chrono::Utc;

// Initialize SurrealDB with the in-memory engine
let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
db.use_ns("test").use_db("test").await.unwrap();

// Define a list of weapons
let weapons = (0..1000)
    .into_iter()
    .map(|i| Weapon {
        name: format!("Weapon{}", i),
        created: Utc::now(),
        strength: i,
        ..Default::default()
    })
    .collect::&lt;Vec&lt;_&gt;&gt;();

// Insert the weapons into the database
let created_weapons = insert(weapons).return_many(db.clone()).await.unwrap();

// Verify the inserted records
assert_eq!(created_weapons.len(), 1000);
assert_eq!(created_weapons[0].name, "Weapon0");
assert_eq!(created_weapons[0].strength, 0);
<span class="boring">}</span></code></pre></pre>
<p>This code creates 1000 <code>Weapon</code> records with sequential names and strength
values.</p>
<hr />
<p><a name="Inserting-from-Another-Table"></a></p>
<h2 id="inserting-from-another-table"><a class="header" href="#inserting-from-another-table">Inserting from Another Table</a></h2>
<p>Surreal ORM allows you to copy data from one table to another using the <code>insert</code>
statement. This is similar to creating a view in PostgreSQL, but instead of just
a projection, it's copying the data to a new table.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Required imports
use surrealdb::Surreal;
use surrealdb::engine::local::Mem;
use surreal_models::{Weapon, StrongWeapon};
use surreal_orm::statements::{insert, select, All, cond, order};
use chrono::Utc;

// Initialize SurrealDB with the in-memory engine
let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
db.use_ns("test").use_db("test").await.unwrap();

// Define a list of weapons
let weapons = (

0..1000)
    .into_iter()
    .map(|i| Weapon {
        name: format!("Weapon{}", i),
        created: Utc::now(),
        strength: i,
        ..Default::default()
    })
    .collect::&lt;Vec&lt;_&gt;&gt;();

// Insert the weapons into the database
let created_weapons = insert(weapons).return_many(db.clone()).await.unwrap();

// Define a SELECT statement for weapons with strength values between 800 and 950
let weapon::Schema { strength, .. } = Weapon::schema();
let select_statement = select(All)
    .from(Weapon::table())
    .where_(cond(strength.greater_than_or_equal(800)).and(strength.less_than(950)));

// Insert the selected weapons into the StrongWeapon table
let strong_weapons = insert::&lt;StrongWeapon&gt;(select_statement)
    .return_many(db.clone())
    .await
    .unwrap();

// Verify the copied records
assert_eq!(strong_weapons.len(), 150);
assert_eq!(strong_weapons[0].strength, 800);
<span class="boring">}</span></code></pre></pre>
<p>This script inserts 1000 <code>Weapon</code> records, selects those with strength values
between 800 and 950, and copies them into the <code>StrongWeapon</code> table.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-statement"><a class="header" href="#create-statement">Create Statement</a></h1>
<p>The <code>create</code> statement is used to add new entries to the SurrealDB database. It
allows you to create records with specified content and set additional
properties for the query. This documentation provides an overview of the syntax
and usage of the <code>create</code> statement.</p>
<h2 id="table-of-contents-11"><a class="header" href="#table-of-contents-11">Table of Contents</a></h2>
<ul>
<li><a href="statements/create.html#syntax">Syntax</a></li>
<li><a href="statements/create.html#examples">Examples</a>
<ul>
<li><a href="statements/create.html#basic-create-statement-with-content-method">Basic Create Statement with Content Method</a></li>
<li><a href="statements/create.html#creating-linked-entities">Creating Linked Entities</a></li>
<li><a href="statements/create.html#using-the-object-macro">Using the object! Macro</a></li>
<li><a href="statements/create.html#create-with-set-method">Create with Set Method</a></li>
</ul>
</li>
</ul>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<p>The basic syntax of the <code>create</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create()
    .content(record_content)
    .set(set_statements)
    .return_type(return_types)
    .timeout(seconds)
    .parallel();
<span class="boring">}</span></code></pre></pre>
<p>The <code>create</code> statement supports the following methods:</p>
<ul>
<li><code>.content(record_content)</code>: Specifies the content of the record to be created.</li>
<li><code>.set(set_statements)</code>: Sets the values of the fields to be updated in the
record.</li>
<li><code>.return_type(return_types)</code>: Specifies the return type for the query.</li>
<li><code>.timeout(seconds)</code>: Sets the timeout duration for the query.</li>
<li><code>.parallel()</code>: Indicates whether the query should be executed in parallel.</li>
</ul>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="basic-create-statement-with-content-method"><a class="header" href="#basic-create-statement-with-content-method">Basic Create Statement with Content Method</a></h3>
<p>To create a basic record using the <code>create</code> statement, you can use the following
code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let space_ship1 = create()
    .content(space_ship1.clone())
    .get_one(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>This code will create a new entry for <code>space_ship1</code> in the database.</p>
<h3 id="creating-linked-entities"><a class="header" href="#creating-linked-entities">Creating Linked Entities</a></h3>
<p>The <code>create</code> statement allows you to create entries that have links to other
entities. Here's an example of creating a linked entity:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let unsaved_alien = Alien {
    ...
    space_ships: LinkMany::from(vec![
        created_spaceship1.clone(),
        created_spaceship2.clone(),
        space_ship3.clone(),
    ]),
    ...
};

let created_alien_with_fetched_links = create()
    .content(unsaved_alien.clone())
    .load_link_manys()?
    .return_one(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>unsaved_alien</code> is being created with links to three different
spaceships. The <code>.load_link_manys()</code> method loads the linked entities in a
single statement.</p>
<h3 id="create-using-the-object-macro"><a class="header" href="#create-using-the-object-macro">Create Using the <code>object!</code> Macro</a></h3>
<p>The <code>object!</code> macro provides a concise and type-safe way to specify values when
creating or updating records when using the <code>set</code> method. It acts as syntactic
sugar for an array of setters but provides stricter field checking compared to
using a basic struct.</p>
<p>Here's an example showcasing its usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let spaceship_id_1 = SpaceShip::create_id("spaceship1".to_string());

let space_ship1 = create::&lt;SpaceShip&gt;()
    .set(object!(SpaceShip {
        id: spaceship_id_1,
        name: "SpaceShip1",
        created: Utc::now(),
    }))
    .get_one(db.clone())
    .await?;
assert_eq!(space_ship1.name, "SpaceShip1");
<span class="boring">}</span></code></pre></pre>
<p>Using the <code>object!</code> macro ensures all fields are provided and belong to the
specified struct. It also allows for using <code>parameter</code> or <code>field</code> as values.
This is recommended over using array of setters as shown next because of the
extra checks this provides.</p>
<p>Additionally, the <code>object_partial!</code> macro functions similarly but allows for
omitting some fields. This is particularly useful for update statements where
only a subset of fields need to be changed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let updated = update::&lt;Weapon&gt;(id)
    .set(object_partial!(Weapon { strength: 923u64 }))
    .return_one(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="create-with-set-method"><a class="header" href="#create-with-set-method">Create with Set Method</a></h3>
<p>You can use the <code>set</code> method with the <code>create</code> statement to set specific fields
of the record being created. The <code>set</code> method supports multiple approaches for
specifying the setter statements:</p>
<ol>
<li>Using an array const (<code>&amp;[T]</code>):</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let space_ship2 = create::&lt;SpaceShip&gt;()
    .set([
        id.equal_to(spaceship_id_2),
        name.equal_to("SpaceShip2".to_string()),
        created.equal_to(Utc::now()),
    ])
    .get_one(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>Using a <code>Vec</code> of setter statements:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let space_ship1 = create::&lt;SpaceShip&gt;()
    .set(vec![
        id.equal_to(spaceship_id_1),
        name.equal_to("SpaceShip1".to_string()),
        created.equal_to(Utc::now()),
    ])
    .get_one(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>In these examples, we demonstrate different ways to use the <code>set</code> method. You
can use an array const (<code>[T]</code> or <code>&amp;[T]</code>) or a <code>Vec</code> to provide a list of setter
statements.</p>
<p>This concludes the documentation for the <code>create</code> statement. Use this statement
to add new entries to the SurrealDB database with desired content and additional
properties.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update-statement"><a class="header" href="#update-statement">Update Statement</a></h1>
<p>The <code>update</code> statement in Surreal ORM allows you to modify existing records in
your database. It provides various operations to update fields and perform
incremental changes to the data. This documentation provides an overview of the
syntax and usage of the <code>update</code> statement, including the use of the <code>object!</code>
and <code>object_partial!</code> macros for setting values.</p>
<h2 id="table-of-contents-12"><a class="header" href="#table-of-contents-12">Table of Contents</a></h2>
<ul>
<li><a href="statements/update.html#syntax">Syntax</a></li>
<li><a href="statements/update.html#using-the-cond!-macro">Using the <code>cond!</code> Macro</a></li>
<li><a href="statements/update.html#examples">Examples</a>
<ul>
<li><a href="statements/update.html#updating-a-single-object">Updating a Single Object</a>
<ul>
<li><a href="statements/update.html#using-the-update-content">Using the Update Content</a></li>
<li><a href="statements/update.html#using-the-object-and-object_partial-macros-with-set-operation">Using the object! and object_partial! Macros with Set Operation</a></li>
<li><a href="statements/update.html#using-the-set-operation">Using the Set Operation</a></li>
<li><a href="statements/update.html#using-the-merge-operation">Using the Merge Operation</a></li>
<li><a href="statements/update.html#using-the-replace-operation">Using the Replace Operation</a></li>
<li><a href="statements/update.html#using-the-patch-operation">Using the Patch Operation</a>
<ul>
<li><a href="statements/update.html#using-the-patch-add-operation">Using the Patch Add Operation</a></li>
<li><a href="statements/update.html#using-the-patch-replace-operation">Using the Patch Replace Operation</a></li>
<li><a href="statements/update.html#using-the-patch-remove-operation">Using the Patch Remove Operation</a></li>
<li><a href="statements/update.html#using-the-patch-change-operation">Using the Patch Change Operation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="statements/update.html#updating-multiple-objects">Updating Multiple Objects</a></li>
</ul>
</li>
</ul>
<h2 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h2>
<p>The basic syntax of the <code>update</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>update::&lt;Type&gt;(id)
    .content(content)
    .merge(merge)
    .replace(replace)
    .set(settables)
    .patch(patch_op)
    .where_(condition)
    .return_type(return_type)
    .timeout(duration)
    .parallel();
<span class="boring">}</span></code></pre></pre>
<p>The <code>update</code> statement supports the following methods:</p>
<ul>
<li><code>.content(content)</code>: Sets the content of the update statement.</li>
<li><code>.merge(merge)</code>: Performs a merge operation to update specific fields.</li>
<li><code>.replace(replace)</code>: Replaces the entire object with a new one.</li>
<li><code>.set(settables)</code>: Sets the values of the fields to be updated.</li>
<li><code>.patch(patch_op)</code>: Applies patch operations to the record.</li>
<li><code>.where_(condition)</code>: Adds a condition to the update statement.</li>
<li><code>.return_type(return_type)</code>: Specifies the desired return type for the query.</li>
<li><code>.timeout(duration)</code>: Sets the timeout duration for the query.</li>
<li><code>.parallel()</code>: Executes the query in parallel.</li>
</ul>
<p>Note: Only one of the .content(), .merge(), .replace(), .set(), or .patch()
methods can be used at a time.</p>
<h2 id="using-the-cond-macro-1"><a class="header" href="#using-the-cond-macro-1">Using the <code>cond!</code> Macro</a></h2>
<p>The <code>cond!</code> macro provides a concise way to define conditions for update
operations. It enhances code readability while ensuring type safety.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let filter = cond!((strength &gt; 5) &amp;&amp; (strength &lt; 15));
<span class="boring">}</span></code></pre></pre>
<p>By using the <code>cond!</code> macro, you can define conditions efficiently and
expressively for the <code>update</code> statement.</p>
<p>For a more in-depth explanation and advanced usage of the <code>cond!</code> macro,
<a href="statements/update.html#helper-macros">refer to the dedicated chapter on helper macros</a>.</p>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="updating-a-single-object"><a class="header" href="#updating-a-single-object">Updating a Single Object</a></h3>
<h4 id="using-the-update-content"><a class="header" href="#using-the-update-content">Using the Update Content</a></h4>
<p>The <code>update</code> statement also supports the <code>content</code> method, which allows you to
specify the updated fields using a separate object. This provides a convenient
way to define the fields to be updated.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let created_weapon = create().content(weapon).get_one(db.clone()).await.unwrap();

let weapon_to_update = Weapon {
    name: "Oyelowo".to_string(),
    created: Utc::now(),
    strength: 1000,
    ..Default::default()
};

let updated_weapon = update::&lt;Weapon&gt;(created_weapon.clone().id)
    .content(weapon_to_update)
    .get_one(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the <code>content</code> method is used to specify the fields to be
updated in the <code>created_weapon</code> object using the <code>weapon_to_update</code> object.</p>
<h4 id="using-the-object-and-object_partial-macros-with-set-operation"><a class="header" href="#using-the-object-and-object_partial-macros-with-set-operation">Using the <code>object!</code> and <code>object_partial!</code> Macros with Set Operation</a></h4>
<p>The <code>set</code> method of the <code>update</code> statement supports the <code>object!</code> and
<code>object_partial!</code> macros, providing a type-safe and concise way to specify
values when updating records. These macros offer several advantages:</p>
<ol>
<li><strong>Type-safety</strong>: Both macros ensure that all fields provided belong to the
specified struct.</li>
<li><strong>Parameters and Fields</strong>: They allow the use of <code>parameters</code> or <code>fields</code> as
values, providing flexibility in constructing dynamic update statements.</li>
<li><strong>Use within Transactions</strong>: Especially within the <code>block!</code> macro for
transactions, these macros can be invaluable as they allow dynamic field and
parameter manipulations based on transactional logic.</li>
</ol>
<p>Here's an example showcasing the usage of the <code>object_partial!</code> macro with the
<code>set</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let created_weapon = create().content(weapon).get_one(db.clone()).await.unwrap();
assert_eq!(created_weapon.name, "Laser");
assert_eq!(created_weapon.strength, 0);

let ref id = created_weapon.clone().id;
let weapon::Schema { strength, .. } = Weapon::schema();

update::&lt;Weapon&gt;(id)
    .set(object_partial!(Weapon { strength: 923u64 }))
    .return_one(db.clone())
    .await?;

let selected: Option&lt;Weapon&gt; = select(All)
    .from(Weapon::table())
    .return_one(db.clone())
    .await?;
assert_eq!(selected.unwrap().strength, 923);
<span class="boring">}</span></code></pre></pre>
<p>In this example, the <code>object_partial!</code> macro is used with the <code>set</code> method to
update the <code>strength</code> field of the <code>Weapon</code> object. This approach offers the
advantages of type-safety and conciseness.</p>
<p>Here's an example showcasing the usage of the <code>object!</code> macro with the <code>set</code>
method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let created_weapon = create().content(weapon).get_one(db.clone()).await.unwrap();

let weapon::Schema { strength, name, .. } = Weapon::schema();

update::&lt;Weapon&gt;(created_weapon.clone().id)
    .set(object!(Weapon {
        strength: strength.increment_by(100u64),
        name: "UpgradedWeapon".to_string()
    }))
    .return_one(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>In this example, the <code>object!</code> macro is used with the <code>set</code> method to
simultaneously set the <code>strength</code> field and rename the <code>Weapon</code>. The macro
ensures that the fields provided belong to the <code>Weapon</code> struct, providing
type-safety.</p>
<p>The primary difference between <code>object!</code> and <code>object_partial!</code> is completeness:</p>
<ul>
<li>
<p><strong><code>object!</code> Macro</strong>: This macro requires you to provide values for all fields
of the struct. It's useful when you have values for all fields and want to
ensure no fields are missed.</p>
</li>
<li>
<p><strong><code>object_partial!</code> Macro</strong>: This allows for specifying only a subset of
fields. It's especially useful when you only want to update specific fields
without having to specify all of them.</p>
</li>
</ul>
<p>In practice, you'll choose between them based on the update requirements. If
you're updating all fields of a record and want to ensure none are missed,
<code>object!</code> is preferable. If you're updating only certain fields,
<code>object_partial!</code> offers a more concise approach.</p>
<h4 id="using-the-set-operation"><a class="header" href="#using-the-set-operation">Using the Set Operation</a></h4>
<p>The <code>update</code> statement also supports the <code>set</code> method, which allows you to
perform 3 major kinds of updates including, overwriting a field with an
<code>equal_to</code> method, <code>increment</code> and <code>decrement</code> method operations for numbers,
<code>append</code> and <code>remove</code> methods for arrays. All the arguments to these methods are
type-checked at compile- time to make sure they are valid for the respective
fields</p>
<ol>
<li>Use set method for a single field</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let created_weapon = create().content(weapon).get_one(db.clone()).await.unwrap();

let weapon_to_update = Weapon {
    name: "Oyelowo".to_string(),
    created: Utc::now(),
    strength: 1000,
    ..Default::default()
};

update::&lt;Weapon&gt;(weapon_to_update.id)
    .set(strength.increment_by(5u64))
    .run(db.clone())
    .await?;

// You can even pass the entire model instance as an argument
update::&lt;Weapon&gt;(weapon_to_update)
    .set(strength.increment_by(5u64))
    .run(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>Use set methods for updating multiple fields</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>update::&lt;Weapon&gt;(id)
    .set([
        strength.increment_by(5u64),
        name.equal("Oyedayo"),
    ])
    .run(db.clone())
    .await?;

// In addition to array const `[T]`,you can also use a `vec!`.
update::&lt;Weapon&gt;(id)
    .set(vec![
        strength.increment_by(5u64),
        name.equal("Oyedayo"),
    ])
    .run(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the <code>set</code> method is used to specify the fields to be
updated in the <code>created_weapon</code> object using the <code>weapon_to_update</code> object.</p>
<h4 id="using-the-merge-operation"><a class="header" href="#using-the-merge-operation">Using the Merge Operation</a></h4>
<p>The <code>merge</code> operation allows you to update a single object by merging new values
into the existing object. The new values overwrite the old ones, while fields
not present in the new object are unaffected.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let created_weapon = create().content(weapon).get_one(db.clone()).await.unwrap();

let weapon_to_update = Weapon {
    name: "Oyelowo".to_string(),
    created: Utc::now(),
    strength: 1000,
    ..Default::default()
};

let updated_weapon = update::&lt;Weapon&gt;(created_weapon.clone().id)
    .merge(weapon_to_update)
    .get_one(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the <code>merge</code> operation is used to update the
<code>created_weapon</code> object with the fields from <code>weapon_to_update</code>. The result is
stored in <code>updated_weapon</code>.</p>
<h4 id="using-the-replace-operation"><a class="header" href="#using-the-replace-operation">Using the Replace Operation</a></h4>
<p>The <code>replace</code> operation allows you to replace an existing object entirely with a
new one. This operation removes all fields not present in the new object.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let created_weapon = create().content(weapon).get_one(db.clone()).await.unwrap();

let weapon_to_replace = Weapon {
    name: "Oyelowo".to_string(),
    created: Utc::now(),
    strength: 823,
    ..Default::default()
};

let updated_weapon = update::&lt;Weapon&gt;(created_weapon.clone().id)
    .replace(weapon_to_replace)
    .get_one(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the <code>replace</code> operation replaces the <code>created_weapon</code>
object with the fields from <code>weapon_to_replace</code>. The result is stored in
<code>updated_weapon</code>.</p>
<h4 id="using-the-patch-operation"><a class="header" href="#using-the-patch-operation">Using the Patch Operation</a></h4>
<p>The <code>patch</code> operation allows you to perform detailed modifications on fields
using methods such as <code>patch_change</code>, <code>patch_replace</code>, <code>patch_remove</code>, and
<code>patch_add</code>. It enables incremental changes to string fields, replacing field
values, removing fields, or adding new fields.</p>
<h5 id="using-the-patch-add-operation"><a class="header" href="#using-the-patch-add-operation">Using the Patch Add Operation</a></h5>
<p>The <code>patch_add</code> operation adds a new field to the object. It allows you to
include additional fields during the update.</p>
<ol>
<li>Applying single patch</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let created_weapon = create().content(weapon).get_one(db.clone()).await.unwrap();

let updated_weapon = update::&lt;Weapon&gt;(created_weapon.clone().id)
    .patch(nice.patch_add(true))
    .get_one(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>Applying multiple patches</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ref _updated_weapon = update::&lt;WeaponOld&gt;(old_weapon.clone().id)
    .patch([nice.patch_add(true), bunchOfOtherFields.patch_add(56)])
    .return_one(db.clone())
    .await;
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the <code>patch_add</code> operation adds the <code>nice</code> field with the
value <code>true</code> to the <code>created_weapon</code> object.</p>
<h5 id="using-the-patch-replace-operation"><a class="header" href="#using-the-patch-replace-operation">Using the Patch Replace Operation</a></h5>
<p>The <code>patch_replace</code> operation replaces the value of a field with a new value. It
allows you to update a field to a different value.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let created_weapon = create().content(weapon).get_one(db.clone()).await.unwrap();

let updated_weapon = update::&lt;Weapon&gt;(created_weapon.clone().id)
    .patch(strength.patch_replace(34u64))
    .get_one(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the <code>patch_replace</code> operation replaces the value of the
<code>strength</code> field in the <code>created_weapon</code> object with the specified value.</p>
<h5 id="using-the-patch-remove-operation"><a class="header" href="#using-the-patch-remove-operation">Using the Patch Remove Operation</a></h5>
<p>The <code>patch_remove</code> operation removes a field from the object entirely. This
operation is destructive, and the field will no longer be available after the
update. Make sure that the struct used here does not require that field to be
present. You can create a copy of the existing struct but without the new field.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let created_weapon = create().content(weapon).get_one(db.clone()).await.unwrap();

let updated_weapon = update::&lt;Weapon&gt;(created_weapon.clone().id)
    .patch(bunchOfOtherFields.patch_remove())
    .get_one(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the <code>patch_remove</code> operation removes the
<code>bunchOfOtherFields</code> field from the <code>created_weapon</code> object.</p>
<h5 id="using-the-patch-change-operation"><a class="header" href="#using-the-patch-change-operation">Using the Patch Change Operation</a></h5>
<p>The <code>patch_change</code> operation modifies part of a string field using the diff
format. It allows you to specify the changes to be applied to the field.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let created_weapon = create().content(weapon).get_one(db.clone()).await.unwrap();

let updated_weapon = update::&lt;Weapon&gt;(created_weapon.clone().id)
    .patch(name.patch_change("@@ -1,4 +1,4 @@\n te\n-s\n+x\n t\n"))
    .get_one(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the <code>patch_change</code> operation modifies the <code>name</code> field of
the <code>created_weapon</code> object by changing "test" to "text".</p>
<h3 id="updating-multiple-objects"><a class="header" href="#updating-multiple-objects">Updating Multiple Objects</a></h3>
<p>To update multiple objects, you can use the <code>update</code> statement with a filter to
select the objects to update.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let filter = cond(strength.greater_than(5)).and(strength.less_than_or_equal(15));

let update_weapons_with_filter = update::&lt;Weapon&gt;(Weapon::table())
    .content(Weapon {
        name: "Oyelowo".to_string(),
        created: Utc::now(),
        ..Default::default()
    })
    .where_(filter)
    .return_many(db.clone())
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the <code>update</code> statement updates all <code>Weapon</code> objects that
meet the specified filter condition with the new values.</p>
<p>Please note that the above code snippets are for illustration purposes and may
need to be adapted to your specific use case.</p>
<p>You have now learned how to use the <code>update</code> statement to modify existing
records in your SurrealDB database. Use the various operations and methods
provided by the <code>update</code> statement to perform precise updates and incremental
changes to your data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relate-statement"><a class="header" href="#relate-statement">Relate Statement</a></h1>
<p>The <code>relate</code> statement is used to create relationships between different
entities in SurrealDB. It allows you to establish connections and associate data
between tables. Here are some examples and usage scenarios for the <code>relate</code>
statement.</p>
<h2 id="table-of-contents-13"><a class="header" href="#table-of-contents-13">Table of Contents</a></h2>
<ul>
<li><a href="statements/relate.html#getting-relations">Getting Relations</a></li>
<li><a href="statements/relate.html#valid-id-usage">Valid ID Usage</a></li>
<li><a href="statements/relate.html#invalid-id-usage">Invalid ID Usage</a></li>
<li><a href="statements/relate.html#relate-subquery-to-subquery">Relate Subquery to Subquery</a></li>
<li><a href="statements/relate.html#any-edge-filter">Any Edge Filter</a></li>
<li><a href="statements/relate.html#recursive-edge-to-edge-connection">Recursive Edge-to-Edge Connection</a></li>
<li><a href="statements/relate.html#relate-query">Relate Query</a></li>
<li><a href="statements/relate.html#relate-query-with-subquery">Relate Query with Subquery</a></li>
<li><a href="statements/relate.html#using-set-method-with-object-macro-in-the-relate-statement">Using <code>set</code> Method with <code>object!</code> Macro in the <code>relate</code> Statement</a>
<ul>
<li><a href="statements/relate.html#example-using-object-macro-with-set-in-relate">Example: Using <code>object!</code> Macro with <code>set</code> in <code>relate</code></a></li>
</ul>
</li>
<li><a href="statements/relate.html#the-importance-of-the-object-macro-in-the-relate-statement">The Importance of the <code>object!</code> Macro in the <code>relate</code> Statement</a></li>
</ul>
<h2 id="getting-relations"><a class="header" href="#getting-relations">Getting Relations</a></h2>
<p>You can retrieve the relations and aliases for a specific field in a struct
using the <code>get_fields_relations_aliased</code> method. This example demonstrates how
to retrieve the relations and aliases for the <code>Student</code> struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let relations_aliases = Student::get_fields_relations_aliased();
<span class="boring">}</span></code></pre></pre>
<h2 id="valid-id-usage"><a class="header" href="#valid-id-usage">Valid ID Usage</a></h2>
<p>To create a relationship between entities using valid IDs, you can use the
<code>relate</code> statement. Here's an example of how to relate a student to a book:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let student_id = Student::create_id("1");
let book_id = Book::create_id("2");

let write_book = StudentWritesBook {
    time_written: Duration::from_secs(343),
    // other fields...
};

let relation = relate(Student::with(&amp;student_id).writes__(Empty).book(&amp;book_id))
    .content(write_book)
    .parallel();
<span class="boring">}</span></code></pre></pre>
<h2 id="invalid-id-usage"><a class="header" href="#invalid-id-usage">Invalid ID Usage</a></h2>
<p>When using invalid IDs in the <code>relate</code> statement, errors will be generated.
Here's an example of relating entities with invalid IDs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let student_id = Student::create_id("oye");
let book_id = Book::create_id("mars");

let write = StudentWritesBook {
    time_written: Duration::from_secs(343),
    // other fields...
};

let relate_statement = relate(Student::with(&amp;book_id).writes__(Empty).book(&amp;student_id))
    .content(write.clone())
    .return_type(ReturnType::Before)
    .parallel();
<span class="boring">}</span></code></pre></pre>
<h2 id="relate-subquery-to-subquery"><a class="header" href="#relate-subquery-to-subquery">Relate Subquery to Subquery</a></h2>
<p>You can also use subqueries in the <code>relate</code> statement to establish relationships
between subquery results. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let write = StudentWritesBook {
    time_written: Duration::from_secs(52),
    // other fields...
};

let statement = relate(
    Student::with(select(All).from(Student::get_table()))
        .writes__(E)
        .book(
            select(All).from(Book::get_table()),
        ),
)
.content(write.clone());
<span class="boring">}</span></code></pre></pre>
<h2 id="any-edge-filter"><a class="header" href="#any-edge-filter">Any Edge Filter</a></h2>
<p>The <code>any_other_edges</code> function allows you to filter relationships based on
multiple edge types. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let aliased_connection = Student::with(student_id)
    .writes__(any_other_edges([visits, likes]).where_(timeWritten.less_than_or_equal(50)))
    .book(book_id)
    .__as__(Student::aliases().writtenBooks);
<span class="boring">}</span></code></pre></pre>
<h2 id="recursive-edge-to-edge-connection"><a class="header" href="#recursive-edge-to-edge-connection">Recursive Edge-to-Edge Connection</a></h2>
<p>You can create recursive edge-to-edge connections using the <code>relate</code> statement.
This allows you to select and relate entities at multiple levels. Here's an
example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let aliased_connection = Student::with(student_id)
    .writes__(Empty)
    .writes__(Empty)
    .writes__(any_other_edges(&amp;[writes, likes]).where_(timeWritten.less_than_or_equal(50)))
    .book(book_id)
    .__as__(Student::aliases().writtenBooks);
<span class="boring">}</span></code></pre></pre>
<h2 id="relate-query"><a class="header" href="#relate-query">Relate Query</a></h2>
<p>The <code>relate</code> statement can be used to execute a query and return the result.
Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let relate_simple = relate(Student::with(student_id).writes__(E).book(book_id)).content(write);
let relate_simple_object = relate_simple.return_one(db.clone()).await?;
let relate_simple_array = relate_simple.return_many(db.clone()).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="relate-query-with-subquery"><a class="header" href="#relate-query-with-subquery">Relate Query with Subquery</a></h2>
<p>You can also use subqueries in the <code>relate</code> statement to execute more complex
queries. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let statement = relate(
    Student::with(select(All).from(Student::get_table()))
        .writes__(E)
        .book(
            select(All).from(Book::get_table()),
        ),
)
.content(write.clone());
<span class="boring">}</span></code></pre></pre>
<h3 id="using-set-method-with-object-macro-in-the-relate-statement"><a class="header" href="#using-set-method-with-object-macro-in-the-relate-statement">Using <code>set</code> Method with <code>object!</code> Macro in the <code>relate</code> Statement</a></h3>
<p>The <code>relate</code> statement supports the use of the <code>set</code> method, serving as an
alternative to the <code>content</code> method for specifying data when creating
relationships between entities.</p>
<p>The <code>set</code> method, when combined with the <code>object!</code> macro, offers a concise,
type-safe, and robust way to define the fields to be set during the relation
creation. Using the <code>object!</code> macro ensures that all fields are present, which
is crucial for avoiding serialization/deserialization issues arising from
missing fields or schema mismatches.</p>
<h4 id="example-using-object-macro-with-set-in-relate"><a class="header" href="#example-using-object-macro-with-set-in-relate">Example: Using <code>object!</code> Macro with <code>set</code> in <code>relate</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let student_id = Student::create_id("1");
let book_id = Book::create_id("2");

relate(Student::with(&amp;student_id).writes__(Empty).book(&amp;book_id))
    .set(object!(StudentWritesBook {
        time_written: Duration::from_secs(343),
        // other fields...
    }))
    .parallel();
<span class="boring">}</span></code></pre></pre>
<h3 id="the-importance-of-the-object-macro-in-the-relate-statement"><a class="header" href="#the-importance-of-the-object-macro-in-the-relate-statement">The Importance of the <code>object!</code> Macro in the <code>relate</code> Statement</a></h3>
<p>In the context of the <code>relate</code> statement, the <code>object!</code> macro provides
significant advantages:</p>
<ol>
<li><strong>Type Safety:</strong> The <code>object!</code> macro ensures type safety, drastically
reducing the risk of type mismatches during compile-time.</li>
<li><strong>Full Field Coverage:</strong> Ensures that all fields are present, protecting
against potential issues during serialization/deserialization due to missing
fields or schema mismatches.</li>
<li><strong>Readability and Clarity:</strong> Using the <code>object!</code> macro leads to cleaner code.
By explicitly defining fields and their corresponding values, the code
becomes more understandable.</li>
<li><strong>Parameterized Fields:</strong> Supports the inclusion of parameters and fields,
making it especially valuable in transactional contexts within the <code>block!</code>
macro.</li>
</ol>
<p>Given these benefits, it's strongly recommended to utilize the <code>object!</code> macro
in the <code>relate</code> statement:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let relation_with_macro = relate(Student::with(&amp;student_id).writes__(Empty).book(&amp;book_id))
    .set(object!({
        timeWritten: Utc::now(),
        someOtherField: "Some Value",
        anotherField: "Another Value"
    }))
    .parallel();
<span class="boring">}</span></code></pre></pre>
<p>Prioritizing the use of the <code>object!</code> macro ensures a combination of safety,
clarity, and robustness in your development process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delete-operations"><a class="header" href="#delete-operations">Delete Operations</a></h1>
<h2 id="table-of-contents-14"><a class="header" href="#table-of-contents-14">Table of Contents</a></h2>
<ol>
<li><a href="statements/delete.html#setup-and-test-data-creation">Setup and Test Data Creation</a></li>
<li><a href="statements/delete.html#delete-by-id-using-helper-functions">Delete by ID Using Helper Functions</a></li>
<li><a href="statements/delete.html#delete-by-id">Delete by ID</a></li>
<li><a href="statements/delete.html#delete-using-model-instance">Delete Using Model Instance</a></li>
<li><a href="statements/delete.html#delete-using-conditions-with-model-helper-functions">Delete Using Conditions with Model Helper Functions</a></li>
<li><a href="statements/delete.html#delete-multiple-records-based-on-conditions">Delete Multiple Records Based on Conditions</a></li>
<li><a href="statements/delete.html#conclusion">Conclusion</a></li>
</ol>
<hr />
<h2 id="setup-and-test-data-creation"><a class="header" href="#setup-and-test-data-creation">Setup and Test Data Creation</a></h2>
<p>Before diving into the deletion methods, let's set up the necessary environment
and generate some test data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use pretty_assertions::assert_eq;
</span><span class="boring">use surreal_models::{weapon, Weapon};
</span><span class="boring">use surreal_orm::{
</span><span class="boring">    statements::{delete, insert},
</span><span class="boring">    *,
</span><span class="boring">};
</span><span class="boring">use surrealdb::{
</span><span class="boring">    engine::local::{Db, Mem},
</span><span class="boring">    Surreal,
</span><span class="boring">};
</span>
async fn create_test_data(db: Surreal&lt;Db&gt;) -&gt; Vec&lt;Weapon&gt; {
    let space_ships = (0..1000)
        .map(|i| Weapon {
            name: format!("weapon-{}", i),
            strength: i,
            ..Default::default()
        })
        .collect::&lt;Vec&lt;Weapon&gt;&gt;();
    insert(space_ships).return_many(db.clone()).await.unwrap()
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="delete-by-id-using-helper-functions"><a class="header" href="#delete-by-id-using-helper-functions">Delete by ID Using Helper Functions</a></h2>
<p>The <code>surreal_orm</code> library provides helper functions on model instances for
common operations. Here's how you can delete a record using the <code>delete_by_id</code>
helper function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_delete_by_id_helper_function() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let weapons = create_test_data(db.clone()).await;
    let weapon1 = weapons.first().unwrap();
    let ref weapon1_id = weapon1.id.clone();

    let weapon::Schema { id, .. } = &amp;Weapon::schema();

    let deleted_weapon_count = || async {
        Weapon::count_where(id.eq(weapon1_id))
            .get(db.clone())
            .await
            .unwrap()
    };
    assert_eq!(deleted_weapon_count().await, 1);

    Weapon::delete_by_id(weapon1_id).run(db.clone()).await?;

    assert_eq!(deleted_weapon_count().await, 0);

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="delete-by-id"><a class="header" href="#delete-by-id">Delete by ID</a></h2>
<p>Another approach to delete a record is by directly using its ID. This method is
efficient for deleting a single record:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_delete_one_by_id() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let weapons = create_test_data(db.clone()).await;
    let weapon1 = weapons.first().unwrap();
    let ref weapon1_id = weapon1.id.clone();

    let weapon::Schema { id, .. } = &amp;Weapon::schema();

    let deleted_weapon_count = || async {
        Weapon::count_where(id.eq(weapon1_id))
            .get(db.clone())
            .await
            .unwrap()
    };
    assert_eq!(deleted_weapon_count().await, 1);

    delete::&lt;Weapon&gt;(weapon1_id).run(db.clone()).await?;

    assert_eq!(deleted_weapon_count().await, 0);

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="delete-using-model-instance"><a class="header" href="#delete-using-model-instance">Delete Using Model Instance</a></h2>
<p>Rather than specifying an ID or condition, <code>surreal_orm</code> allows developers to
delete records directly using a model instance. This approach can be useful when
the developer already has a reference to the model instance they want to delete:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_delete_one_by_model_instance() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let weapons = create_test_data(db.clone()).await;
    let weapon1 = weapons.first().unwrap();
    let ref weapon1_id = weapon1.id.clone();

    let weapon::Schema { id, .. } = &amp;Weapon::schema();

    let deleted_weapon_count = || async {
        Weapon::count_where(id.eq(weapon1_id))
            .get(db.clone())
            .await
            .unwrap()
    };
    let deleted_weapon = || async {
        Weapon::find_by_id(weapon1_id)
            .return_one(db.clone())
            .await
            .unwrap()
    };

    assert_eq!(deleted_weapon().await.is_some(), true);
    assert_eq!(deleted_weapon_count().await, 1);

    weapon1.delete().run(db.clone()).await?;

    assert_eq!(deleted_weapon().await.is_some(), false);
    assert_eq!(deleted_weapon_count().await, 0);

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="delete-using-conditions-with-model-helper-functions"><a class="header" href="#delete-using-conditions-with-model-helper-functions">Delete Using Conditions with Model Helper Functions</a></h2>
<p>Sometimes, developers may need to delete a group of records based on a
particular condition. Model helper functions can also facilitate such
operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_delete_where_model_helper_function() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    create_test_data(db.clone()).await;

    let weapon::Schema { strength, .. } = &amp;Weapon::schema();

    let weapons_count = || async { Weapon::count_all().get(db.clone()).await.unwrap() };
    assert_eq!(weapons_count().await, 1000);

    Weapon::delete_where(cond(strength.gte(500)).and(strength.lt(600)))
        .run(db.clone())
        .await?;

    assert_eq!(weapons_count().await, 900);

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="delete-multiple-records-based-on-conditions"><a class="header" href="#delete-multiple-records-based-on-conditions">Delete Multiple Records Based on Conditions</a></h2>
<p>The ORM also provides direct deletion methods for multiple records based on
specific conditions. This is particularly useful when the developer knows the
exact criteria they want to match for the deletion:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_delete_many_query_by_condition() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    create_test_data(db.clone()).await;

    let weapon::Schema { strength, .. } = &amp;Weapon::schema();

    let weapons_count = || async { Weapon::count_all().get(db.clone()).await.unwrap() };
    assert_eq!(weapons_count().await, 1000);

    delete::&lt;Weapon&gt;(Weapon::table())
        .where_(cond(strength.gte(500)).and(strength.lt(600)))
        .run(db.clone())
        .await?;

    assert_eq!(weapons_count().await, 900);

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>The delete operations in <code>surreal_orm</code> offer a flexible and comprehensive
mechanism to remove records from the <code>surrealdb</code> database. Whether it's deleting
a single record using its ID, removing multiple records based on conditions, or
even utilizing model instances for deletions, the ORM provides an arsenal of
tools to help developers manage their data efficiently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-statement-permissions"><a class="header" href="#for-statement-permissions">For Statement (Permissions)</a></h1>
<p>The <code>for</code> statement is used to define permissions for a specific action or CRUD
operation in SurrealDB. It allows you to specify the desired permissions and
conditions for the action. This statement is commonly used when defining tables
or fields in SurrealDB, but it may also be used for access control for other
objects in the future. This documentation provides an overview of the syntax and
usage of the <code>for</code> statement.</p>
<h2 id="table-of-contents-15"><a class="header" href="#table-of-contents-15">Table of Contents</a></h2>
<ul>
<li><a href="statements/permissions.html#syntax">Syntax</a></li>
<li><a href="statements/permissions.html#permission-types">Permission Types</a></li>
<li><a href="statements/permissions.html#using-the-cond!-macro">Using the <code>cond!</code> Macro</a></li>
<li><a href="statements/permissions.html#examples">Examples</a>
<ul>
<li><a href="statements/permissions.html#define-permission-for-single-action">Define Permission for Single Action</a></li>
<li><a href="statements/permissions.html#define-permissions-for-multiple-actions-individual">Define Permissions for Multiple Actions (Individual)</a></li>
<li><a href="statements/permissions.html#define-permissions-for-multiple-actions-array">Define Permissions for Multiple Actions (Array)</a></li>
<li><a href="statements/permissions.html#define-permissions-for-multiple-actions-mixed">Define Permissions for Multiple Actions (Mixed)</a></li>
</ul>
</li>
</ul>
<h2 id="syntax-3"><a class="header" href="#syntax-3">Syntax</a></h2>
<p>The basic syntax of the <code>for</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for_permission(permission_type)
    .where_(condition);
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>permission_type</code>: The type of permission or action for which you want to
define permissions. It can be a single permission type or an array of
permission types.</li>
<li><code>condition</code>: The condition or criteria for the permission. It specifies the
conditions under which the permission should be granted.</li>
</ul>
<p>The <code>for</code> statement supports the following methods:</p>
<ul>
<li><code>.where_(condition)</code>: Specifies the condition or criteria for the permission.</li>
</ul>
<h2 id="permission-types"><a class="header" href="#permission-types">Permission Types</a></h2>
<p>SurrealDB uses permission types to define different actions or CRUD operations
that can be performed on tables or fields. Here are the available permission
types:</p>
<ul>
<li><code>Create</code>: Grants permission to create new records or objects.</li>
<li><code>Read</code> (or <code>Select</code>): Grants permission to read or retrieve data from records
or objects.</li>
<li><code>Update</code>: Grants permission to modify or update existing records or objects.</li>
<li><code>Delete</code>: Grants permission to delete records or objects.</li>
</ul>
<p>These permission types allow you to define fine-grained access control for
different actions in your database.</p>
<h2 id="using-the-cond-macro-2"><a class="header" href="#using-the-cond-macro-2">Using the <code>cond!</code> Macro</a></h2>
<p>The <code>cond!</code> macro provides an alternative way to the <code>cond</code> function way to
define conditions for the <code>for</code> statement when specifying the condition for the
permissions. With the <code>cond!</code> macro, you can easily specify conditions that
determine when permissions are granted.</p>
<p>For instance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let condition = cond!((field_name OR  "value") OR (age &gt; 18));
<span class="boring">}</span></code></pre></pre>
<p>The above code checks if the field named "field_name" equals the string "value".
For more details on the <code>cond!</code> macro,
<a href="statements/permissions.html#helper-macros">refer to the dedicated chapter on helper macros</a>.</p>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="define-permission-for-single-action"><a class="header" href="#define-permission-for-single-action">Define Permission for Single Action</a></h3>
<p>To define permissions for a single action, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use CrudType::*;
let name = Field::new("name");

let for_res = for_permission(Create).where_(name.like("Oyelowo"));
println!("{}", for_res.to_raw().build());
<span class="boring">}</span></code></pre></pre>
<p>The above code will generate the following raw statement:</p>
<pre><code>FOR create
    WHERE name ~ 'Oyelowo'
</code></pre>
<p>In the example above, the <code>for</code> statement defines permissions for the <code>Create</code>
action. It specifies the condition that the field "name" should be matched with
the pattern "Oyelowo". This means that the permission to create records will be
granted only when the field "name" matches the pattern.</p>
<h3 id="define-permissions-for-multiple-actions-individual"><a class="header" href="#define-permissions-for-multiple-actions-individual">Define Permissions for Multiple Actions (Individual)</a></h3>
<p>To define permissions for multiple actions individually, you can use the
following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use CrudType::*;
let name = Field::new("name");

let for_res = for_permission(Select).where_(age.greater_than_or_equal(18))
    .permissions(for_permission(Create).where_(name.is("Oyedayo")))
    .permissions(for_permission(Update).where_(age.less_than_or_equal(130)));
println!("{}", for_res.to_raw().build());
<span class="boring">}</span></code></pre></pre>
<p>The above code will generate the following raw statement:</p>
<pre><code>FOR select
    WHERE age &gt;= 18
PERMISSIONS
    FOR create
        WHERE name IS 'Oyedayo'
    FOR update


 WHERE age &lt;= 130
</code></pre>
<p>In the example above, the <code>for</code> statement defines permissions for the <code>Select</code>
action, as well as individual permissions for the <code>Create</code> and <code>Update</code> actions.
It specifies different conditions for each action. This means that the
permissions for these actions will be granted only when the specified conditions
are met.</p>
<h3 id="define-permissions-for-multiple-actions-array"><a class="header" href="#define-permissions-for-multiple-actions-array">Define Permissions for Multiple Actions (Array)</a></h3>
<p>To define permissions for multiple actions using an array, you can use the
following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use CrudType::*;
let name = Field::new("name");

let for_res = for_permission(&amp;[Create, Delete, Select, Update]).where_(name.is("Oyedayo"));
println!("{}", for_res.to_raw().build());
<span class="boring">}</span></code></pre></pre>
<p>The above code will generate the following raw statement:</p>
<pre><code>FOR create, delete, select, update
    WHERE name IS 'Oyedayo'
</code></pre>
<p>In the example above, the <code>for</code> statement defines permissions for multiple
actions (<code>Create</code>, <code>Delete</code>, <code>Select</code>, and <code>Update</code>) using an array. It
specifies a common condition for all the actions. This means that the
permissions for these actions will be granted only when the field "name" is
equal to "Oyedayo".</p>
<h3 id="define-permissions-for-multiple-actions-mixed"><a class="header" href="#define-permissions-for-multiple-actions-mixed">Define Permissions for Multiple Actions (Mixed)</a></h3>
<p>To define permissions for multiple actions using a mix of individual permissions
and an array, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use CrudType::*;
let name = Field::new("name");

let for_res = for_permission(&amp;[Create, Delete]).where_(name.is("Oyedayo"))
    .permissions(for_permission(Update).where_(age.less_than_or_equal(130)));
println!("{}", for_res.to_raw().build());
<span class="boring">}</span></code></pre></pre>
<p>The above code will generate the following raw statement:</p>
<pre><code>FOR create, delete
    WHERE name IS 'Oyedayo'
PERMISSIONS
    FOR update
        WHERE age &lt;= 130
</code></pre>
<p>In the example above, the <code>for</code> statement defines individual permissions for the
<code>Create</code> and <code>Delete</code> actions, and an array of permissions for the <code>Update</code>
action. It specifies different conditions for each action. This means that the
permissions for these actions will be granted only when the specified conditions
are met.</p>
<p>You have now learned how to define permissions using the <code>for</code> statement in
SurrealDB. Use this statement to specify the desired access control for
different actions or CRUD operations in your database. While it is commonly used
when defining tables or fields, it may also be utilized for access control for
other objects in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-statement"><a class="header" href="#define-statement">Define Statement</a></h1>
<p>The <code>define</code> statement in SurrealDB is a powerful tool that allows you to define various objects and configurations within the database. It provides a flexible and expressive way to create and manage entities such as tables, indexes, namespaces, tokens, logins, and more. This documentation provides an overview of the <code>define</code> statement and its usage.</p>
<h2 id="table-of-contents-16"><a class="header" href="#table-of-contents-16">Table of Contents</a></h2>
<ul>
<li><a href="statements/define.html#introduction">Introduction</a></li>
<li><a href="statements/define.html#syntax">Syntax</a></li>
<li><a href="statements/define.html#supported-objects">Supported Objects</a></li>
<li><a href="statements/define.html#examples">Examples</a></li>
</ul>
<h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>The <code>define</code> statement serves as a declarative mechanism for defining and configuring various elements in SurrealDB. It enables you to specify the properties and characteristics of different objects, helping you define the structure, behavior, and access controls of your database components.</p>
<p>By using the <code>define</code> statement, you can create and manage objects such as tables, indexes, namespaces, tokens, logins, and more, all within a single comprehensive syntax. This provides a unified approach to defining and organizing your database entities, making it easier to maintain and modify them over time.</p>
<h2 id="syntax-4"><a class="header" href="#syntax-4">Syntax</a></h2>
<p>The general syntax of the <code>define</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define(object_name)
    .property1(value1)
    .property2(value2)
    .property3(value3)
    // ...
<span class="boring">}</span></code></pre></pre>
<p>The specific properties and values depend on the type of object being defined. Each object may have different properties that can be set, such as names, types, constraints, configurations, and more. The <code>define</code> statement provides a fluent and chainable API to set these properties in a concise and readable manner.</p>
<h2 id="supported-objects"><a class="header" href="#supported-objects">Supported Objects</a></h2>
<p>The <code>define</code> statement supports a variety of objects that can be defined within SurrealDB. Some of the commonly used objects include:</p>
<ul>
<li>Tables: Define the structure and schema of tables within the database.</li>
<li>Indexes: Define indexes on tables to optimize data retrieval and querying.</li>
<li>Namespaces: Define logical containers to organize database objects.</li>
<li>Tokens: Define authentication and authorization tokens for access control.</li>
<li>Logins: Define user logins for authentication purposes.</li>
<li>Scopes: Define scopes to encapsulate and manage query execution environments.</li>
</ul>
<p>These are just a few examples of the objects that can be defined using the <code>define</code> statement. SurrealDB provides a rich set of features and options for each object type, allowing you to customize and tailor the behavior of your database entities according to your specific requirements.</p>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<p>Here are a few examples of using the <code>define</code> statement to define different objects:</p>
<ul>
<li>Defining a table:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = Table::from("user");
let statement = define_table(user).schemaless().permissions_full();
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Defining an index:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let query = define_index("userEmailIndex")
    .on_table(User::table())
    .fields(email)
    .unique();
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Defining a namespace:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let namespace_def = define_namespace("myapp");
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Defining a token:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let token_def = define_token("access_token")
    .on_namespace()
    .type_(TokenType::HS256)
    .value("mysecretpassword");
<span class="boring">}</span></code></pre></pre>
<p>These examples showcase the versatility and power of the <code>define</code> statement in SurrealDB. You can define and configure a wide range of objects using a consistent and intuitive syntax, enabling you to shape your database according to your desired structure and requirements.</p>
<p>This concludes the overview of the <code>define</code> statement in SurrealDB. You can now leverage its capabilities to define and manage various objects within your database, providing a solid foundation</p>
<p>for building robust and scalable applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-namespace-statement"><a class="header" href="#define-namespace-statement">Define Namespace Statement</a></h1>
<p>The <code>define_namespace</code> statement is used to define a namespace in SurrealDB. A namespace is a logical container for organizing database objects, such as tables, indexes, and functions. This documentation provides an overview of the syntax and usage of the <code>define_namespace</code> statement.</p>
<h2 id="table-of-contents-17"><a class="header" href="#table-of-contents-17">Table of Contents</a></h2>
<ul>
<li><a href="statements/define/namespace.html#syntax">Syntax</a></li>
<li><a href="statements/define/namespace.html#examples">Examples</a>
<ul>
<li><a href="statements/define/namespace.html#define-a-namespace">Define a Namespace</a></li>
</ul>
</li>
</ul>
<h2 id="syntax-5"><a class="header" href="#syntax-5">Syntax</a></h2>
<p>The syntax of the <code>define_namespace</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_namespace(namespace_name: &amp;str)
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>namespace_name</code>: The name of the namespace to define.</li>
</ul>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<h3 id="define-a-namespace"><a class="header" href="#define-a-namespace">Define a Namespace</a></h3>
<p>To define a namespace, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let statement = define_namespace("oyelowo");
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>define_namespace</code> statement defines a namespace named "oyelowo".</p>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE NAMESPACE oyelowo;
</code></pre>
<p>You have now learned how to define a namespace using the <code>define_namespace</code> statement.
Namespaces provide a way to organize and structure your database objects within SurrealDB,
enabling better management and organization of your resources.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-database-statement"><a class="header" href="#define-database-statement">Define Database Statement</a></h1>
<p>The <code>define_database</code> statement is used to define a database in SurrealDB. A database is a logical container for storing related data and organizing resources. This documentation provides an overview of the syntax and usage of the <code>define_database</code> statement.</p>
<h2 id="table-of-contents-18"><a class="header" href="#table-of-contents-18">Table of Contents</a></h2>
<ul>
<li><a href="statements/define/database.html#syntax">Syntax</a></li>
<li><a href="statements/define/database.html#examples">Examples</a>
<ul>
<li><a href="statements/define/database.html#define-a-database">Define a Database</a></li>
</ul>
</li>
</ul>
<h2 id="syntax-6"><a class="header" href="#syntax-6">Syntax</a></h2>
<p>The syntax of the <code>define_database</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_database(database_name: Database)
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>database_name</code>: The name of the database to define.</li>
</ul>
<h2 id="examples-7"><a class="header" href="#examples-7">Examples</a></h2>
<h3 id="define-a-database"><a class="header" href="#define-a-database">Define a Database</a></h3>
<p>To define a database, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let statement = define_database("oyelowo");
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>define_database</code> statement defines a database named "oyelowo".</p>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE DATABASE oyelowo;
</code></pre>
<p>You have now learned how to define a database using the <code>define_database</code> statement. Databases provide a way to organize and manage data within SurrealDB, allowing you to create distinct containers for your data resources.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="define-login-statement"><a class="header" href="#define-login-statement">Define Login Statement</a></h2>
<p>The <code>define_login</code> statement is used to define a login in SurrealDB. Logins are used for authentication purposes, allowing users to authenticate and access protected resources. This documentation provides an overview of the syntax and usage of the <code>define_login</code> statement.</p>
<h2 id="table-of-contents-19"><a class="header" href="#table-of-contents-19">Table of Contents</a></h2>
<ul>
<li><a href="statements/define/login.html#syntax">Syntax</a></li>
<li><a href="statements/define/login.html#examples">Examples</a>
<ul>
<li><a href="statements/define/login.html#define-login-with-password">Define Login with Password</a></li>
<li><a href="statements/define/login.html#define-login-with-passhash">Define Login with Passhash</a></li>
</ul>
</li>
</ul>
<h2 id="syntax-7"><a class="header" href="#syntax-7">Syntax</a></h2>
<p>The basic syntax of the <code>define_login</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_login(login_name: Login)
    .on_namespace()
    .password(password: &amp;str)

define_login(login_name: Login)
    .on_database()
    .password(password: &amp;str)

define_login(login_name: Login)
    .on_namespace()
    .passhash(passhash: &amp;str)
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>login_name</code>: The name of the login to define.</li>
<li><code>password</code>: The password associated with the login.</li>
<li><code>passhash</code>: The password hash associated with the login.</li>
</ul>
<p>The <code>define_login</code> statement supports the following options:</p>
<ul>
<li><code>on_namespace()</code>: Specifies that the login should be defined on the namespace level.</li>
<li><code>on_database()</code>: Specifies that the login should be defined on the database level.</li>
</ul>
<h2 id="examples-8"><a class="header" href="#examples-8">Examples</a></h2>
<h3 id="define-login-with-password"><a class="header" href="#define-login-with-password">Define Login with Password</a></h3>
<p>To define a login with a password, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let username = Login::new("username");
let login_with_password = define_login(username)
    .on_database()
    .password("oyelowo");
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>define_login</code> statement defines a login named "username" on the database level. The login is associated with a password "oyelowo".</p>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE LOGIN username ON DATABASE PASSWORD 'oyelowo';
</code></pre>
<h3 id="define-login-with-passhash"><a class="header" href="#define-login-with-passhash">Define Login with Passhash</a></h3>
<p>To define a login with a password hash, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let login_with_hash = define_login("username")
    .on_namespace()
    .passhash("reiiereroyedayo");
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>define_login</code> statement defines a login named "username" on the namespace level. The login is associated with a password hash "reiiereroyedayo".</p>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE LOGIN username ON NAMESPACE PASSHASH 'reiiereroyedayo';
</code></pre>
<p>You have now learned how to define logins using the <code>define_login</code> statement. Logins are essential for authentication in SurrealDB, allowing users to securely access protected resources.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="define-token-statement"><a class="header" href="#define-token-statement">Define Token Statement</a></h2>
<p>The <code>define_token</code> statement is used to define a token in SurrealDB. Tokens are used for authentication and authorization purposes, allowing users or applications to access protected resources. This documentation provides an overview of the syntax and usage of the <code>define_token</code> statement.</p>
<h2 id="table-of-contents-20"><a class="header" href="#table-of-contents-20">Table of Contents</a></h2>
<ul>
<li><a href="statements/define/token.html#syntax">Syntax</a></li>
<li><a href="statements/define/token.html#examples">Examples</a>
<ul>
<li><a href="statements/define/token.html#define-token-on-namespace">Define Token on Namespace</a></li>
<li><a href="statements/define/token.html#define-token-on-database">Define Token on Database</a></li>
<li><a href="statements/define/token.html#define-token-on-scope">Define Token on Scope</a></li>
</ul>
</li>
<li><a href="statements/define/token.html#token-types">Token Types</a></li>
</ul>
<h2 id="syntax-8"><a class="header" href="#syntax-8">Syntax</a></h2>
<p>The basic syntax of the <code>define_token</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_token(token_name: Token)
    .on_namespace()
    .type_(token_type: TokenType)
    .value(token_value: &amp;str)

define_token(token_name: Token)
    .on_database()
    .type_(token_type: TokenType)
    .value(token_value: &amp;str)

define_token(token_name: Token)
    .on_scope(scope_name: Scope)
    .type_(token_type: TokenType)
    .value(token_value: &amp;str)
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>token_name</code>: The name of the token to define.</li>
<li><code>token_type</code>: The type of the token, specified using the <code>TokenType</code> enum.</li>
<li><code>token_value</code>: The value or secret associated with the token.</li>
</ul>
<p>The <code>define_token</code> statement supports the following options:</p>
<ul>
<li><code>on_namespace()</code>: Specifies that the token should be defined on the namespace level.</li>
<li><code>on_database()</code>: Specifies that the token should be defined on the database level.</li>
<li><code>on_scope(scope_name)</code>: Specifies that the token should be defined on a specific scope.</li>
</ul>
<h2 id="examples-9"><a class="header" href="#examples-9">Examples</a></h2>
<h3 id="define-token-on-namespace"><a class="header" href="#define-token-on-namespace">Define Token on Namespace</a></h3>
<p>To define a token on the namespace level, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let statement = define_token("oyelowo_token")
    .on_namespace()
    .type_(TokenType::PS512)
    .value("abrakradabra");
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>define_token</code> statement defines a token named "oyelowo_token" on the namespace level. The token type is set to <code>TokenType::PS512</code> and the value is set to "abrakradabra".</p>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE TOKEN oyelowo_token ON NAMESPACE TYPE PS512 VALUE 'abrakradabra';
</code></pre>
<h3 id="define-token-on-database"><a class="header" href="#define-token-on-database">Define Token on Database</a></h3>
<p>To define a token on the database level, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let statement = define_token("oyelowo_token")
    .on_database()
    .type_(TokenType::HS512)
    .value("anaksunamun");
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>define_token</code> statement defines a token named "oyelowo_token" on the database level. The token type is set to <code>TokenType::HS512</code> and the value is set to "anaksunamun".</p>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE TOKEN oyelowo_token ON DATABASE TYPE HS512 VALUE 'anaksunamun';
</code></pre>
<h3 id="define-token-on-scope"><a class="header" href="#define-token-on-scope">Define Token on Scope</a></h3>
<p>To define a token on a specific scope, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let statement = define_token("oyelowo_token")
    .on_scope("planet")
    .type_(TokenType::EDDSA)
    .value("abcde");
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>define_token</code> statement defines a token named "oyelowo_token" on the scope "planet". The token type is set to <code>TokenType::EDDSA</code> and the value is set to "abcde".</p>
<p>This will generate the following SQL</p>
<p>statement:</p>
<pre><code class="language-sql">DEFINE TOKEN oyelowo_token ON SCOPE planet TYPE EDDSA VALUE 'abcde';
</code></pre>
<h2 id="token-types"><a class="header" href="#token-types">Token Types</a></h2>
<p>The <code>TokenType</code> enum represents the available token types in SurrealDB. Each token type corresponds to a specific algorithm or cryptographic scheme used for token generation and validation. The following token types are available:</p>
<ul>
<li><code>EDDSA</code>: EdDSA (Edwards-curve Digital Signature Algorithm)</li>
<li><code>ES256</code>: ECDSA using P-256 and SHA-256</li>
<li><code>ES384</code>: ECDSA using P-384 and SHA-384</li>
<li><code>ES512</code>: ECDSA using P-521 and SHA-512</li>
<li><code>HS256</code>: HMAC using SHA-256</li>
<li><code>HS384</code>: HMAC using SHA-384</li>
<li><code>HS512</code>: HMAC using SHA-512</li>
<li><code>PS256</code>: RSASSA-PSS using SHA-256 and MGF1 with SHA-256</li>
<li><code>PS384</code>: RSASSA-PSS using SHA-384 and MGF1 with SHA-384</li>
<li><code>PS512</code>: RSASSA-PSS using SHA-512 and MGF1 with SHA-512</li>
<li><code>RS256</code>: RSASSA-PKCS1-v1_5 using SHA-256</li>
<li><code>RS384</code>: RSASSA-PKCS1-v1_5 using SHA-384</li>
<li><code>RS512</code>: RSASSA-PKCS1-v1_5 using SHA-512</li>
</ul>
<p>You can specify the desired token type when using the <code>define_token</code> statement by providing the corresponding <code>TokenType</code> enum variant.</p>
<p>You have now learned how to define tokens using the <code>define_token</code> statement. Tokens are essential for authentication and authorization in SurrealDB, allowing you to secure your data and control access to resources.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-scope-statement"><a class="header" href="#define-scope-statement">Define Scope Statement</a></h1>
<p>The <code>define_scope</code> statement is used to define a scope in SurrealDB. Scopes
provide a way to encapsulate a set of operations within a specific context or
namespace. This documentation provides an overview of the syntax and usage of
the <code>define_scope</code> statement.</p>
<h2 id="table-of-contents-21"><a class="header" href="#table-of-contents-21">Table of Contents</a></h2>
<ul>
<li><a href="statements/define/scope.html#syntax">Syntax</a></li>
<li><a href="statements/define/scope.html#examples">Examples</a>
<ul>
<li><a href="statements/define/scope.html#define-scope-on-namespace">Define Scope on Namespace</a></li>
</ul>
</li>
</ul>
<h2 id="syntax-9"><a class="header" href="#syntax-9">Syntax</a></h2>
<p>The basic syntax of the <code>define_scope</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_scope(scope_name: &amp;str) {
    // Scope definition
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>scope_name</code>: The name of the scope to define.</li>
</ul>
<p>The <code>define_scope</code> statement supports the following features:</p>
<ul>
<li>Defining session duration for the scope.</li>
<li>Defining operations for the scope, such as signup and signin.</li>
</ul>
<h2 id="examples-10"><a class="header" href="#examples-10">Examples</a></h2>
<h3 id="define-scope-on-namespace"><a class="header" href="#define-scope-on-namespace">Define Scope on Namespace</a></h3>
<p>To define a scope on a namespace with signup and signin operations, you can use
the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>block! {
let user::Schema { email, pass } = &amp;User::schema();
let email = "oyelowo@codebreather.com";
let password = "very-strong";

let token_def = define_scope("oyelowo_scope")
    .session(Duration::from_secs(45))
    .signup(
        create::&lt;User&gt;()
            .set(vec![
                email.equal_to(email),
                pass.equal_to(crypto::argon2::generate!(password)),
            ])
    )
    .signin(
        select(All).from(User::table()).where_(
            cond(email.equal(email))
                .and(crypto::argon2::compare!(pass, password)),
        ),
    );
}
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>define_scope</code> statement defines a scope named
"oyelowo_scope" on the namespace. The scope includes a session duration of 45
seconds. It also defines signup and signin operations within the scope. The
signup operation uses the <code>create</code> statement with a non-raw query to create a
new user record. The <code>email</code> and <code>pass</code> fields are set using parameter
placeholders. The <code>pass</code> field is generated using the <code>crypto::argon2::generate</code>
function. The signin operation performs a select query with conditions.</p>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE SCOPE oyelowo_scope SESSION 45s
    SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($password) )
    SIGNIN ( SELECT * FROM user WHERE (email = email) AND (crypto::argon2::compare(pass, $password)) );
</code></pre>
<p>You can then use the defined scope in your queries by referencing the scope
name.</p>
<hr />
<p>Now you have learned how to define a scope using the <code>define_scope</code> statement.
Scopes provide a way to encapsulate a set of operations within a specific
context or namespace. Refer to the SurrealDB documentation for more information
on scopes and their usage.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-table-statement"><a class="header" href="#define-table-statement">Define Table Statement</a></h1>
<p>The <code>define_table</code> statement is used to define a table in SurrealDB. It allows you to specify various options and permissions for the table. This documentation provides an overview of the syntax and usage of the <code>define_table</code> statement.</p>
<h2 id="table-of-contents-22"><a class="header" href="#table-of-contents-22">Table of Contents</a></h2>
<ul>
<li><a href="statements/define/table.html#syntax">Syntax</a></li>
<li><a href="statements/define/table.html#examples">Examples</a>
<ul>
<li><a href="statements/define/table.html#schemaless-table">Schemaless Table</a></li>
<li><a href="statements/define/table.html#schemaless-table-with-permissions">Schemaless Table with Permissions</a></li>
<li><a href="statements/define/table.html#define-table-with-projection">Define Table with Projection</a></li>
<li><a href="statements/define/table.html#define-table-with-multiple-permissions">Define Table with Multiple Permissions</a></li>
</ul>
</li>
</ul>
<h2 id="syntax-10"><a class="header" href="#syntax-10">Syntax</a></h2>
<p>The basic syntax of the <code>define_table</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_table(table)
    .drop()
    .as_(select_statement)
    .schemafull()
    .permissions(permission_statements);
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>table</code>: The name of the table to define.</li>
</ul>
<p>The <code>define_table</code> statement supports the following methods:</p>
<ul>
<li><code>.drop()</code>: Drops the existing table before defining it.</li>
<li><code>.as_(select_statement)</code>: Specifies a <code>SELECT</code> statement to populate the table.</li>
<li><code>.schemafull()</code>: Defines the table with a schema.</li>
<li><code>.permissions(permission_statements)</code>: Specifies the permissions for the table.</li>
</ul>
<h2 id="examples-11"><a class="header" href="#examples-11">Examples</a></h2>
<h3 id="schemaless-table"><a class="header" href="#schemaless-table">Schemaless Table</a></h3>
<p>To define a schemaless table with no permissions, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = Table::from("user");
let statement = define_table(user).schemaless().permissions_none();
<span class="boring">}</span></code></pre></pre>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE TABLE user SCHEMALESS PERMISSIONS NONE;
</code></pre>
<h3 id="schemaless-table-with-permissions"><a class="header" href="#schemaless-table-with-permissions">Schemaless Table with Permissions</a></h3>
<p>To define a schemaless table with full permissions, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = Table::from("user");
let statement = define_table(user).schemaless().permissions_full();
<span class="boring">}</span></code></pre></pre>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE TABLE user SCHEMALESS PERMISSIONS FULL;
</code></pre>
<h3 id="define-table-with-projection"><a class="header" href="#define-table-with-projection">Define Table with Projection</a></h3>
<p>A projection allows you to define a table based on a subset of columns from another table. It is similar to creating a view in a relational database. You can specify a projection using the <code>as_</code> method and provide a <code>SELECT</code> statement as the projection definition. The selected columns and rows will be used to populate the defined table.</p>
<p>Here's an example that demonstrates how to define a table with a projection:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user_table = Table::from("user");
let projection_statement = select(All).from(user_table).where_(age.greater_than(18));
let statement = define_table(user_table).as_(projection_statement);
<span class="boring">}</span></code></pre></pre>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE TABLE user AS SELECT * FROM user WHERE age &gt; 18;
</code></pre>
<p>In the example above, the <code>define_table</code> statement defines a table named "user" with a projection based on a <code>SELECT</code> statement. Only the rows that satisfy the condition <code>age &gt; 18</code> will be included in the table.</p>
<h3 id="define-table-with-multiple-permissions"><a class="header" href="#define-table-with-multiple-permissions">Define Table with Multiple Permissions</a></h3>
<p>You can define a table with multiple permissions using the <code>permissions</code> method. The following example demonstrates various permission configurations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = Field::new("name");
let user_table = Table::from("user");
let age = Field::new("age");
let country = Field::new("country");
let fake_id2 = sql::Thing::from(("user".to_string(), "oyedayo".to_string()));

let statement = define_table(user_table)
    .drop()
    .as_(
        select(All)
            .from(fake_id2)
            .where_(country.is("INDONESIA"))
            .order_by(order(&amp;age).numeric().desc())
            .limit(20)
            .start(5),
    )
    .schemafull()
    .permissions(for_permission(Select).where_(age.greater_than_or_equal(18))) // Single works
    .permissions(for_permission([Create, Delete]).where_(name.is("Oyedayo"))) // Multiple
    .permissions([
        for_permission([Create, Delete]).where_(name.is("Oyedayo")),
        for_permission(Update).where_(age.less_than_or_equal(130)),
    ]);
<span class="boring">}</span></code></pre></pre>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE TABLE user DROP SCHEMAFULL AS
    SELECT * FROM user:oyedayo
    WHERE country IS 'INDONESIA' ORDER BY age NUMERIC DESC
    LIMIT 20 START AT 5
PERMISSIONS
    FOR select
        WHERE age &gt;= 18
    FOR create, delete
        WHERE name IS 'Oyedayo'
    FOR create, delete
        WHERE name IS 'Oyedayo'
    FOR update
        WHERE age &lt;= 130;
</code></pre>
<p>In the example above, the <code>define_table</code> statement defines a table named "user". It drops the existing table, populates it with data from a <code>SELECT</code> statement, and sets various permissions based on conditions.</p>
<p>This concludes the documentation for the <code>define_table</code> statement. Use this statement to define tables in SurrealDB and specify the desired permissions, configurations, and projections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-event-statement"><a class="header" href="#define-event-statement">Define Event Statement</a></h1>
<p>The <code>define_event</code> statement is used to define an event in SurrealDB. It allows
you to specify the conditions and actions associated with the event. This
documentation provides an overview of the syntax and usage of the <code>define_event</code>
statement.</p>
<h2 id="table-of-contents-23"><a class="header" href="#table-of-contents-23">Table of Contents</a></h2>
<ul>
<li><a href="statements/define/event.html#syntax">Syntax</a></li>
<li><a href="statements/define/event.html#using-the-cond!-macro">Using the <code>cond!</code> Macro</a></li>
<li><a href="statements/define/event.html#examples">Examples</a>
<ul>
<li><a href="statements/define/event.html#define-event-with-state-machine">Define Event with State Machine</a></li>
</ul>
</li>
</ul>
<h2 id="syntax-11"><a class="header" href="#syntax-11">Syntax</a></h2>
<p>The basic syntax of the <code>define_event</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_event(event_name)
    .on_table(table)
    .when(condition)
    .then(action);
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>event_name</code>: The name of the event to define.</li>
<li><code>table</code>: The name of the table where the event occurs.</li>
<li><code>condition</code>: The condition that triggers the event.</li>
<li><code>action</code>: The action to perform when the event is triggered.</li>
</ul>
<p>The <code>define_event</code> statement supports the following methods:</p>
<ul>
<li><code>.on_table(table)</code>: Specifies the table where the event occurs.</li>
<li><code>.when(condition)</code>: Specifies the condition that triggers the event.</li>
<li><code>.then(action)</code>: Specifies the action to perform when the event is triggered.</li>
</ul>
<h2 id="using-the-cond-macro-3"><a class="header" href="#using-the-cond-macro-3">Using the <code>cond!</code> Macro</a></h2>
<p>The <code>cond!</code> macro is a handy tool when defining conditions for the <code>WHEN</code> clause
in the <code>DEFINE EVENT</code> statement. It provides a concise way to define conditions,
enhancing readability while ensuring type safety.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let filter = cond!((strength &gt; 5) &amp;&amp; (strength &lt; 15));
<span class="boring">}</span></code></pre></pre>
<p>By using the <code>cond!</code> macro, you can effectively and expressively define
conditions for the <code>DEFINE EVENT</code> statement.</p>
<p>For a more in-depth explanation and advanced usage of the <code>cond!</code> macro,
<a href="statements/define/event.html#helper-macros">refer to the dedicated chapter on helper macros</a>.</p>
<h2 id="examples-12"><a class="header" href="#examples-12">Examples</a></h2>
<h3 id="define-event-with-state-machine"><a class="header" href="#define-event-with-state-machine">Define Event with State Machine</a></h3>
<p>To define an event with a state machine-like behavior, you can use the following
code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let age = Field::new("age");
let city = Field::new("city");
let fake_id = sql::Thing::from(("user".to_string(), "oyelowo".to_string()));
let user_table = Table::new("user");
let email_event = Event::new("email");

let query = define_event(email_event)
    .on_table(user_table)
    .when(cond(age.greater_than_or_equal(18)))
    .then(
        select(All)
            .from(fake_id)
            .where_(
                cond(city.is("Prince Edward Island"))
                    .and(city.is("NewFoundland"))
                    .or(city.like("Toronto")),
            )
            .limit(153)
            .start(10)
            .parallel(),
    );
<span class="boring">}</span></code></pre></pre>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE EVENT email ON TABLE user WHEN age &gt;= 18 THEN SELECT * FROM user:oyelowo WHERE (city IS 'Prince Edward Island') AND (city IS 'NewFoundland') OR (city ~ 'Toronto') LIMIT 153 START AT 10 PARALLEL;
</code></pre>
<p>In the example above, the <code>define_event</code> statement defines an event named
"email" on the "user" table. It specifies that the event is triggered when the
age is greater than or equal to 18. The action associated with the event is to
perform a <code>SELECT</code> query on the "user:oyelowo" table with certain conditions and
settings.</p>
<p>This concludes the documentation for the <code>define_event</code> statement. Use this
statement to define events in SurrealDB and specify their conditions and
actions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-function-statement"><a class="header" href="#define-function-statement">Define Function Statement</a></h1>
<p>The <code>define_function!</code> statement is used to define a custom function in
SurrealDB. It allows you to define reusable logic that can be used within
queries. This documentation provides an overview of the syntax and usage of the
<code>define_function!</code> statement.</p>
<h2 id="table-of-contents-24"><a class="header" href="#table-of-contents-24">Table of Contents</a></h2>
<ul>
<li><a href="statements/define/function.html#syntax">Syntax</a></li>
<li><a href="statements/define/function.html#examples">Examples</a>
<ul>
<li><a href="statements/define/function.html#define-function-with-parameters-and-logic">Define Function with Parameters and Logic</a></li>
<li><a href="statements/define/function.html#define-function-with-complex-logic">Define Function with Complex Logic</a></li>
</ul>
</li>
<li><a href="statements/define/function.html#using-the-generated-function">Using the Generated Function</a></li>
</ul>
<h2 id="syntax-12"><a class="header" href="#syntax-12">Syntax</a></h2>
<p>The basic syntax of the <code>define_function!</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_function!(function_name(parameter1: type1, parameter2: type2, ...) {
    // Function logic
});
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>function_name</code>: The name of the function to define.</li>
<li><code>parameter1</code>, <code>parameter2</code>, ...: The parameters of the function, along with
their types.</li>
<li><code>function logic</code>: The logic or operations to be performed by the function.</li>
</ul>
<p>The <code>define_function!</code> statement supports the following features:</p>
<ul>
<li>Defining function parameters and their types.</li>
<li>Writing custom logic or operations within the function body.</li>
<li>Returning values from the function.</li>
</ul>
<h2 id="examples-13"><a class="header" href="#examples-13">Examples</a></h2>
<h3 id="define-function-with-parameters-and-logic"><a class="header" href="#define-function-with-parameters-and-logic">Define Function with Parameters and Logic</a></h3>
<p>To define a function with parameters and custom logic, you can use the following
code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_function!(get_it(first: bool, last: string, birthday: string) {
    let person = "43";
    return person;
});
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>define_function!</code> statement defines a function named
"get_it" with three parameters: <code>first</code>, <code>last</code>, and <code>birthday</code>. The function
body consists of assigning a value to the <code>person</code> variable and returning it.</p>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE FUNCTION get_it($first: bool, $last: string, $birthday: string) {
    LET $person = '43';

    RETURN $person;
};
</code></pre>
<p>You can then use the defined function in queries by calling it with the
appropriate arguments.</p>
<h3 id="define-function-with-complex-logic"><a class="header" href="#define-function-with-complex-logic">Define Function with Complex Logic</a></h3>
<p>Here's an example of defining a function with more complex logic and operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_models::SpaceShip;
use surreal_orm::{
    cond, index,
    statements::{create, define_function, if_, select},
    All, Buildable, Operatable, SchemaGetter, SetterAssignable, Model, ToRaw, NONE,
};

define_function!(get_person(first_arg: string, last_arg: string, birthday_arg: string) {
    let person = select(All)
        .from(SpaceShip::table())
        .where_(
            cond(SpaceShip::schema().id.equal(&amp;first_arg))
                .and(SpaceShip::schema().name.equal(&amp;last_arg))
                .and(SpaceShip::schema().created.equal(&amp;birthday_arg)),
        );

    return if_(person.with_path::&lt;SpaceShip&gt;(index(0)).id.is_not(NONE))
                .then(person.with_path::&lt;SpaceShip&gt;(index(0)))
            .else_(
                create::&lt;SpaceShip&gt;().set(
                    vec![
                        SpaceShip::schema().id.equal_to(&amp;first_arg),


 SpaceShip::schema().name.equal_to(&amp;last_arg),
                        SpaceShip::schema().created.equal_to(&amp;birthday_arg),
                    ]
                )
            ).end();
});
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>define_function!</code> statement defines a function named
"get_person" with three parameters: <code>first_arg</code>, <code>last_arg</code>, and <code>birthday_arg</code>.
The function body consists of a complex logic that includes a SELECT statement,
conditional checks, and the creation of a new record if the condition is not
met.</p>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE FUNCTION get_person($first_arg: string, $last_arg: string, $birthday_arg: string) {
    LET $person = (SELECT * FROM space_ship WHERE (id = $first_arg) AND (name = $last_arg) AND (created = $birthday_arg));

    RETURN IF $person[0].id != NONE THEN $person[0] ELSE (CREATE space_ship SET id = $first_arg, name = $last_arg, created = $birthday_arg) END;
};
</code></pre>
<p>You can then use the defined function in queries by calling it with the
appropriate arguments.</p>
<h2 id="using-the-generated-function"><a class="header" href="#using-the-generated-function">Using the Generated Function</a></h2>
<p>To use the function defined using <code>define_function!</code>, you need to execute the
generated statement before you can use the function in your queries. The
generated statement is suffixed by <code>_statement</code> and contains the actual function
definition. After executing the statement, you can use the function without the
<code>_statement</code> suffix.</p>
<p>Here's an example of how to use the defined function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define the function statement
let fn_statement = get_it_statement();

// Execute the statement to define the function
// This statement needs to be executed before the function can be used
fn_statement.run(db);

// Use the defined function in a query
let get_it_function = get_it(false, "3".to_string(), "3".to_string());

// Verify the generated function can be used in a query
assert_eq!(get_it_function.to_raw().build(), "get_it(false, '3', '3')");
assert_eq!(
    get_it_function.fine_tune_params(),
    "et_it($_param_00000001, $_param_00000002, $_param_00000003)"
);
<span class="boring">}</span></code></pre></pre>
<p>In this example, we first define the function statement using the
<code>get_it_statement()</code> macro. Then, we execute the generated statement using
<code>surreal_orm::execute()</code> to define the function in SurrealDB. After that, we can
use the defined function <code>get_it()</code> in our queries by calling it with the
appropriate arguments.</p>
<p>Make sure to execute the statement to define the function before using it in
your queries.</p>
<hr />
<p>Now you have learned how to define custom functions using the <code>define_function!</code>
macro, how to execute the generated statement to define the function, and how to
use the defined function in your queries. Refer to the SurrealDB documentation
for more information on custom functions and their usage.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-field-statement"><a class="header" href="#define-field-statement">Define Field Statement</a></h1>
<p>The <code>define_field</code> statement is used to define a field in SurrealDB. It allows you to specify various options and permissions for the field. This documentation provides an overview of the syntax and usage of the <code>define_field</code> statement.</p>
<h2 id="table-of-contents-25"><a class="header" href="#table-of-contents-25">Table of Contents</a></h2>
<ul>
<li><a href="statements/define/field.html#syntax">Syntax</a></li>
<li><a href="statements/define/field.html#examples">Examples</a>
<ul>
<li><a href="statements/define/field.html#define-field-with-full-configuration">Define Field with Full Configuration</a></li>
<li><a href="statements/define/field.html#define-field-with-simple-configuration">Define Field with Simple Configuration</a></li>
</ul>
</li>
<li><a href="statements/define/field.html#field-types">Field Types</a></li>
<li><a href="statements/define/field.html#geometry-types">Geometry Types</a></li>
<li><a href="statements/define/field.html#permission-types">Permission Types</a></li>
</ul>
<h2 id="syntax-13"><a class="header" href="#syntax-13">Syntax</a></h2>
<p>The basic syntax of the <code>define_field</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_field(field_name)
    .on_table(table)
    .type_(field_type)
    .value(default_value)
    .assert(assertion)
    .permissions(permission_statements);
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>field_name</code>: The name of the field to define.</li>
<li><code>table</code>: The name of the table where the field belongs.</li>
<li><code>field_type</code>: The type of the field.</li>
<li><code>default_value</code> (optional): The default value for the field.</li>
<li><code>assertion</code> (optional): An assertion condition for the field.</li>
<li><code>permission_statements</code> (optional): The permissions for the field.</li>
</ul>
<p>The <code>define_field</code> statement supports the following methods:</p>
<ul>
<li><code>.on_table(table)</code>: Specifies the table where the field belongs.</li>
<li><code>.type_(field_type)</code>: Specifies the type of the field.</li>
<li><code>.value(default_value)</code>: Specifies the default value for the field.</li>
<li><code>.assert(assertion)</code>: Specifies an assertion condition for the field.</li>
<li><code>.permissions(permission_statements)</code>: Specifies the permissions for the field.</li>
</ul>
<h2 id="examples-14"><a class="header" href="#examples-14">Examples</a></h2>
<h3 id="define-field-with-full-configuration"><a class="header" href="#define-field-with-full-configuration">Define Field with Full Configuration</a></h3>
<p>To define a field with full configuration, including a default value, assertion condition, and permissions, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let email = Field::new("email");
let user_table = Table::from("user");
let age = Field::new("age");
let statement = define_field(email)
    .on_table(user_table)
    .type_(String)
    .value("example@codebreather.com")
    .assert(cond(value().is_not(NONE)).and(value().like("is_email")))
    .permissions(for_permission(Permission::Select).where_(age.greater_than_or_equal(18))) // Single permission
    .permissions(for_permission(&amp;[Permission::Create, Permission::Update]).where_(name.is("Oyedayo"))) // Multiple permissions
    .permissions(&amp;[
        for_permission(&amp;[Permission::Create, Permission::Delete]).where_(name.is("Oyedayo")),
        for_permission(Permission::Update).where_(age.less_than_or_equal(130)),
    ]);
<span class="boring">}</span></code></pre></pre>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE FIELD email ON TABLE user TYPE string VALUE 'example@codebreather.com' \
    ASSERT ($value IS NOT NONE) AND ($value ~ 'is_email')
PERMISSIONS
    FOR select
        WHERE age &gt;= 18
    FOR create, update
        WHERE name IS 'Oyedayo'
    FOR create, delete
        WHERE name IS 'Oyedayo'
    FOR update
        WHERE age &lt;= 130;
</code></pre>
<p>In the example above, the <code>define_field</code> statement defines a field named "email" on the "user" table. It specifies the field type as <code>String</code>, sets a default value of <code>'example@codebreather.com'</code>, and adds an</p>
<p>assertion condition. It also sets different permissions for the field based on conditions.</p>
<h3 id="define-field-with-simple-configuration"><a class="header" href="#define-field-with-simple-configuration">Define Field with Simple Configuration</a></h3>
<p>To define a field with a simple configuration, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use FieldType::*;

let email = Field::new("email");
let user_table = Table::from("user");
let statement = define_field(email).on_table(user_table).type_(String);
<span class="boring">}</span></code></pre></pre>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE FIELD email ON TABLE user TYPE string;
</code></pre>
<p>In the example above, the <code>define_field</code> statement defines a field named "email" on the "user" table. It specifies the field type as <code>String</code> without setting a default value, assertion condition, or permissions.</p>
<h2 id="field-types"><a class="header" href="#field-types">Field Types</a></h2>
<p>The <code>define_field</code> statement supports various field types in SurrealDB. The available field types are:</p>
<ul>
<li><code>any</code>: Allows any data type supported by SurrealDB.</li>
<li><code>array</code>: Represents a list.</li>
<li><code>bool</code>: Represents true or false values.</li>
<li><code>datetime</code>: Represents an ISO 8601 compliant date with time and time zone.</li>
<li><code>decimal</code>: Represents any real number with arbitrary precision.</li>
<li><code>duration</code>: Represents a length of time that can be added or subtracted from datetimes or other durations.</li>
<li><code>float</code>: Represents a value stored in a 64-bit float.</li>
<li><code>int</code>: Represents a value stored in a 64-bit integer.</li>
<li><code>number</code>: Represents numbers without specifying the type, allowing SurrealDB to detect and store the number based on its minimal representation.</li>
<li><code>object</code>: Represents formatted objects containing values of any supported type.</li>
<li><code>string</code>: Represents a string value.</li>
<li><code>record</code>: Represents a reference to another record in any table.</li>
<li><code>geometry</code>: Represents a geometry type conforming to the GeoJSON format.</li>
</ul>
<h2 id="geometry-types"><a class="header" href="#geometry-types">Geometry Types</a></h2>
<p>The <code>geometry</code> field type allows you to define geometric fields in SurrealDB. The available geometry types are:</p>
<ul>
<li><code>feature</code>: Represents any geometric type.</li>
<li><code>point</code>: Represents a point.</li>
<li><code>line</code>: Represents a line.</li>
<li><code>polygon</code>: Represents a polygon.</li>
<li><code>multipoint</code>: Represents a multipoint.</li>
<li><code>multiline</code>: Represents a multiline.</li>
<li><code>multipolygon</code>: Represents a multipolygon.</li>
<li><code>collection</code>: Represents a collection of geometry types.</li>
</ul>
<h2 id="permission-types-1"><a class="header" href="#permission-types-1">Permission Types</a></h2>
<p>The <code>define_field</code> statement allows you to define permissions for the field using permission types. The available permission types are:</p>
<ul>
<li><code>Create</code>: Allows creating new records with the field.</li>
<li><code>Read</code>: Allows reading the field value from existing records.</li>
<li><code>Update</code>: Allows updating the field value in existing records.</li>
<li><code>Delete</code>: Allows deleting records that have the field.</li>
</ul>
<p>These permission types can be used in the <code>permissions</code> method to define the desired access control for the field.</p>
<p>You have now learned how to define fields using the <code>define_field</code> statement, including different configuration options, field types, geometry types, and permission types. Use this statement to define fields in SurrealDB and specify their configurations and permissions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-index-statement"><a class="header" href="#define-index-statement">Define Index Statement</a></h1>
<p>The <code>define_index</code> statement is used to define an index in SurrealDB. Indexes are used to improve the performance of queries by creating data structures that allow for efficient lookup and retrieval of data. This documentation provides an overview of the syntax and usage of the <code>define_index</code> statement.</p>
<h2 id="table-of-contents-26"><a class="header" href="#table-of-contents-26">Table of Contents</a></h2>
<ul>
<li><a href="statements/define/index.html#syntax">Syntax</a></li>
<li><a href="statements/define/index.html#examples">Examples</a>
<ul>
<li><a href="statements/define/index.html#define-index-with-single-field">Define Index with Single Field</a></li>
<li><a href="statements/define/index.html#define-index-with-single-column">Define Index with Single Column</a></li>
<li><a href="statements/define/index.html#define-index-with-multiple-fields">Define Index with Multiple Fields</a></li>
<li><a href="statements/define/index.html#define-index-with-multiple-columns">Define Index with Multiple Columns</a></li>
</ul>
</li>
</ul>
<h2 id="syntax-14"><a class="header" href="#syntax-14">Syntax</a></h2>
<p>The basic syntax of the <code>define_index</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_index(index_name: Index)
    .on_table(table: Table)
    .fields(arr![fields: Field])
    .columns(arr![columns: Field])
    .unique()
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>index_name</code>: The name of the index to define.</li>
<li><code>table</code>: The name of the table on which the index is defined.</li>
<li><code>fields</code>: An array of fields to include in the index.</li>
<li><code>columns</code>: An array of columns to include in the index.</li>
<li><code>unique</code>: Specifies that the index should enforce uniqueness.</li>
</ul>
<p>The <code>define_index</code> statement supports the following features:</p>
<ul>
<li>Defining indexes with fields or columns.</li>
<li>Specifying uniqueness for the index.</li>
</ul>
<h2 id="examples-15"><a class="header" href="#examples-15">Examples</a></h2>
<h3 id="define-index-with-single-field"><a class="header" href="#define-index-with-single-field">Define Index with Single Field</a></h3>
<p>To define an index with a single field, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let email = Field::new("email");

let query = define_index("userEmailIndex")
    .on_table("user")
    .fields(email)
    .unique();
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>define_index</code> statement defines an index named "userEmailIndex" on the table "user" with the "email" field. The index is marked as unique.</p>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE INDEX userEmailIndex ON TABLE user FIELDS email UNIQUE;
</code></pre>
<h3 id="define-index-with-single-column"><a class="header" href="#define-index-with-single-column">Define Index with Single Column</a></h3>
<p>To define an index with a single column, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let email = Field::new("email");

let query = define_index("userEmailIndex")
    .on_table("user")
    .columns(email)
    .unique();
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>define_index</code> statement defines an index named "userEmailIndex" on the table "user" with the "email" column. The index is marked as unique.</p>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE INDEX userEmailIndex ON TABLE user COLUMNS email UNIQUE;
</code></pre>
<h3 id="define-index-with-multiple-fields"><a class="header" href="#define-index-with-multiple-fields">Define Index with Multiple Fields</a></h3>
<p>To define an index with multiple fields, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let age = Field::new("age");
let name = Field::new("name");
let email = Field::new("email");
let dob = Field::new("dob");

let query = define_index("alien_index")
    .on_table("alien")
    .fields(arr![age, name, email, dob])
    .unique();
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>define_index</code> statement defines an index named "alien_index" on the table "alien" with the "age", "name", "email", and "dob" fields. The index is marked as unique.</p>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE INDEX alien_index ON TABLE alien FIELDS age, name, email, dob UNIQUE;
</code></pre>
<h3 id="define-index-with-multiple-columns"><a class="header" href="#define-index-with-multiple-columns">Define Index with Multiple Columns</a></h3>
<p>To define an index with multiple columns, you can use the</p>
<p>following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let age = Field::new("age");
let name = Field::new("name");
let email = Field::new("email");
let dob = Field::new("dob");

let query = define_index("alien_index")
    .on_table("alien")
    .columns(arr![age, name, email, dob])
    .unique();
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>define_index</code> statement defines an index named "alien_index" on the table "alien" with the "age", "name", "email", and "dob" columns. The index is marked as unique.</p>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">DEFINE INDEX alien_index ON TABLE alien COLUMNS age, name, email, dob UNIQUE;
</code></pre>
<p>You have now learned how to define indexes using the <code>define_index</code> statement. Indexes improve query performance by creating data structures that allow for efficient lookup and retrieval of data. Use indexes strategically to optimize the performance of your database queries.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="define-param-statement"><a class="header" href="#define-param-statement">Define Param Statement</a></h1>
<p>The <code>define_param</code> statement is used to define a parameter in SurrealDB.
Parameters provide a way to store and reuse values within queries. This
documentation provides an overview of the syntax and usage of the <code>define_param</code> statement.</p>
<h2 id="table-of-contents-27"><a class="header" href="#table-of-contents-27">Table of Contents</a></h2>
<ul>
<li><a href="statements/define/param.html#syntax">Syntax</a></li>
<li><a href="statements/define/param.html#examples">Examples</a>
<ul>
<li><a href="statements/define/param.html#define-param-statement-usage">Define Param Statement</a></li>
</ul>
</li>
</ul>
<h2 id="syntax-15"><a class="header" href="#syntax-15">Syntax</a></h2>
<p>The basic syntax of the <code>define_param</code> statement is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>define_param(param_name: Param) {
    // Parameter definition
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>param_name</code>: The name of the parameter to define.</li>
</ul>
<p>The <code>define_param</code> statement supports the following features:</p>
<ul>
<li>Assigning a value to the parameter.</li>
</ul>
<h2 id="examples-16"><a class="header" href="#examples-16">Examples</a></h2>
<h3 id="define-param-statement-usage"><a class="header" href="#define-param-statement-usage">Define Param Statement Usage</a></h3>
<p>To define a parameter with a specific value, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define the parameter
fn endpoint_base() -&gt; Param {
    Param::new("endpoint_base")
}

// Define the param definition itself. This must be run against the database first to use the param.
let statement = define_param(endpoint_base()).value("https://dummyjson.com");
<span class="boring">}</span></code></pre></pre>
<p>In the example above, the <code>define_param</code> statement defines a parameter named "endpoint_base" with a value of "https://dummyjson.com".</p>
<p>Before using the defined parameter, it is important to run the <code>define_param</code> statement to register the parameter with the database. You can do this by calling the <code>run</code> method on the statement object, passing the SurrealDB instance as an argument:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>statement.run(db);
<span class="boring">}</span></code></pre></pre>
<p>Once the <code>define_param</code> statement has been executed, you can use the defined parameter (<code>$endpoint_base</code>) across your codebase in queries and other operations.</p>
<p>You can then reference the parameter name in your queries to utilize the stored value.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let query = select(All).from(User::table()).where_(endpoint_base().equal_to("https://dummyjson.com"));
<span class="boring">}</span></code></pre></pre>
<hr />
<p>Now you have learned how to define a parameter using the <code>define_param</code> statement.
Parameters provide a way to store and reuse values within queries. Remember to
execute the <code>define_param</code> statement to register the parameter with the database
before using it in your codebase. Refer to the SurrealDB documentation for more
information on parameters and their usage.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remove-statement"><a class="header" href="#remove-statement">Remove Statement</a></h1>
<p>The <code>REMOVE</code> statement in Surreal ORM is used to remove various elements from
the database, such as databases, events, fields, indexes, logins, scopes,
namespaces, tables, and tokens. This documentation covers the usage and examples
of the <code>REMOVE</code> statement for each of these elements.</p>
<h2 id="table-of-contents-28"><a class="header" href="#table-of-contents-28">Table of Contents</a></h2>
<ul>
<li><a href="statements/remove.html#remove-database">Remove Database</a></li>
<li><a href="statements/remove.html#remove-event">Remove Event</a></li>
<li><a href="statements/remove.html#remove-field">Remove Field</a></li>
<li><a href="statements/remove.html#remove-index">Remove Index</a></li>
<li><a href="statements/remove.html#remove-login">Remove Login</a></li>
<li><a href="statements/remove.html#remove-scope">Remove Scope</a></li>
<li><a href="statements/remove.html#remove-namespace">Remove Namespace</a></li>
<li><a href="statements/remove.html#remove-table">Remove Table</a></li>
<li><a href="statements/remove.html#remove-token">Remove Token</a></li>
</ul>
<h2 id="remove-database"><a class="header" href="#remove-database">Remove Database</a></h2>
<p>The <code>REMOVE DATABASE</code> statement is used to remove a database from the SurrealDB.
Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(
    remove_database("oyelowo").build(),
    "REMOVE DATABASE oyelowo;"
);
<span class="boring">}</span></code></pre></pre>
<p>The generated SQL query for this code block would be <code>REMOVE DATABASE oyelowo;</code>.</p>
<h2 id="remove-event"><a class="header" href="#remove-event">Remove Event</a></h2>
<p>The <code>REMOVE EVENT</code> statement is used to remove an event from a table. Here's an
example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = Table::new("user");
let party = Event::new("party");

let statement = remove_event(party).on_table(user);
assert_eq!(statement.build(), "REMOVE EVENT party ON TABLE user;");
<span class="boring">}</span></code></pre></pre>
<p>The generated SQL query for this code block would be
<code>REMOVE EVENT party ON TABLE user;</code>.</p>
<h2 id="remove-field"><a class="header" href="#remove-field">Remove Field</a></h2>
<p>The <code>REMOVE FIELD</code> statement is used to remove a field from a table. Here's an
example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = Table::new("user");
let name = Field::new("name");

let statement = remove_field(name).on_table(user);
assert_eq!(statement.build(), "REMOVE FIELD name ON TABLE user;");
<span class="boring">}</span></code></pre></pre>
<p>The generated SQL query for this code block would be
<code>REMOVE FIELD name ON TABLE user;</code>.</p>
<h2 id="remove-index"><a class="header" href="#remove-index">Remove Index</a></h2>
<p>The <code>REMOVE INDEX</code> statement is used to remove an index from a table. Here's an
example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = Table::new("user");
let party = TableIndex::new("party");

let statement = remove_index(party).on_table(user);
assert_eq!(statement.build(), "REMOVE INDEX party ON TABLE user;");
<span class="boring">}</span></code></pre></pre>
<p>The generated SQL query for this code block would be
<code>REMOVE INDEX party ON TABLE user;</code>.</p>
<h2 id="remove-login"><a class="header" href="#remove-login">Remove Login</a></h2>
<p>The <code>REMOVE LOGIN</code> statement is used to remove a login from either a namespace
or a database. Here are examples for removing a login on a namespace and a
database:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let login = Login::new("login");

// Remove login on a namespace
let statement = remove_login(login).on_namespace();
assert_eq!(statement.build(), "REMOVE LOGIN login ON NAMESPACE;");

// Remove login on a database
let statement = remove_login(login).on_database();
assert_eq!(statement.build(), "REMOVE LOGIN login ON DATABASE;");
<span class="boring">}</span></code></pre></pre>
<p>The generated SQL queries for these code blocks would be
<code>REMOVE LOGIN login ON NAMESPACE;</code> and <code>REMOVE LOGIN login ON DATABASE;</code>
respectively.</p>
<h2 id="remove-scope"><a class="header" href="#remove-scope">Remove Scope</a></h2>
<p>The <code>REMOVE SCOPE</code> statement is used to remove a scope from the SurrealDB.
Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let scope = Scope::new("scope");
let statement = remove_scope(scope);
assert_eq!(statement.build(), "REMOVE SCOPE scope;");
<span class="boring">}</span></code></pre></pre>
<p>The generated SQL query for this code block would be <code>REMOVE SCOPE scope;</code>.</p>
<h2 id="remove-namespace"><a class="header" href="#remove-namespace">Remove Namespace</a></h2>
<p>The <code>REMOVE NAMESPACE</code> statement is used to</p>
<p>remove a namespace from the SurrealDB. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let namespace = Namespace::new("namespace");
let statement = remove_namespace(namespace);
assert_eq!(statement.build(), "REMOVE NAMESPACE namespace;");
<span class="boring">}</span></code></pre></pre>
<p>The generated SQL query for this code block would be
<code>REMOVE NAMESPACE namespace;</code>.</p>
<h2 id="remove-table"><a class="header" href="#remove-table">Remove Table</a></h2>
<p>The <code>REMOVE TABLE</code> statement is used to remove a table from the SurrealDB.
Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let table = Table::new("table");
let statement = remove_table(table);
assert_eq!(statement.build(), "REMOVE TABLE table;");
<span class="boring">}</span></code></pre></pre>
<p>The generated SQL query for this code block would be <code>REMOVE TABLE table;</code>.</p>
<h2 id="remove-token"><a class="header" href="#remove-token">Remove Token</a></h2>
<p>The <code>REMOVE TOKEN</code> statement is used to remove a token from either a namespace
or a database. Here are examples for removing a token on a namespace and a
database:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let token = Token::new("token");

// Remove token on a namespace
let statement = remove_token(token).on_namespace();
assert_eq!(statement.build(), "REMOVE TOKEN token ON NAMESPACE;");

// Remove token on a database
let statement = remove_token(token).on_database();
assert_eq!(statement.build(), "REMOVE TOKEN token ON DATABASE;");
<span class="boring">}</span></code></pre></pre>
<p>The generated SQL queries for these code blocks would be
<code>REMOVE TOKEN token ON NAMESPACE;</code> and <code>REMOVE TOKEN token ON DATABASE;</code>
respectively.</p>
<p>That concludes the documentation for the <code>REMOVE</code> statement in Surreal ORM. Use
the examples and explanations provided to effectively remove various elements
from the database.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="info-statement"><a class="header" href="#info-statement">Info Statement</a></h1>
<p>The <code>INFO</code> statement in Surreal ORM is used to retrieve information about
various elements in the database, such as key-value pairs, namespaces,
databases, scopes, and tables. This documentation covers the usage and examples
of the <code>INFO</code> statement for each of these elements.</p>
<h2 id="table-of-contents-29"><a class="header" href="#table-of-contents-29">Table of Contents</a></h2>
<ul>
<li><a href="statements/info.html#info-for-key-value-kv-pairs">Info for Key-Value (KV) Pairs</a></li>
<li><a href="statements/info.html#info-for-namespaces">Info for Namespaces</a></li>
<li><a href="statements/info.html#info-for-databases">Info for Databases</a></li>
<li><a href="statements/info.html#info-for-scopes">Info for Scopes</a></li>
<li><a href="statements/info.html#info-for-tables">Info for Tables</a></li>
</ul>
<h2 id="info-for-key-value-kv-pairs"><a class="header" href="#info-for-key-value-kv-pairs">Info for Key-Value (KV) Pairs</a></h2>
<p>The <code>INFO FOR KV</code> statement is used to retrieve information about key-value
pairs in the SurrealDB. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let statement = info_for().kv().build();
assert_eq!(statement, "INFO FOR KV;");
<span class="boring">}</span></code></pre></pre>
<p>The generated SQL query for this code block would be <code>INFO FOR KV;</code>.</p>
<h2 id="info-for-namespaces"><a class="header" href="#info-for-namespaces">Info for Namespaces</a></h2>
<p>The <code>INFO FOR NS</code> statement is used to retrieve information about namespaces in
the SurrealDB. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let statement = info_for().namespace().build();
assert_eq!(statement, "INFO FOR NS;");
<span class="boring">}</span></code></pre></pre>
<p>The generated SQL query for this code block would be <code>INFO FOR NS;</code>.</p>
<h2 id="info-for-databases"><a class="header" href="#info-for-databases">Info for Databases</a></h2>
<p>The <code>INFO FOR DB</code> statement is used to retrieve information about databases in
the SurrealDB. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let statement = info_for().database().build();
assert_eq!(statement, "INFO FOR DB;");
<span class="boring">}</span></code></pre></pre>
<p>The generated SQL query for this code block would be <code>INFO FOR DB;</code>.</p>
<h2 id="info-for-scopes"><a class="header" href="#info-for-scopes">Info for Scopes</a></h2>
<p>The <code>INFO FOR SCOPE</code> statement is used to retrieve information about a specific
scope in the SurrealDB. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let statement = info_for().scope("test_scope").build();
assert_eq!(statement, "INFO FOR SCOPE test_scope;");
<span class="boring">}</span></code></pre></pre>
<p>The generated SQL query for this code block would be
<code>INFO FOR SCOPE test_scope;</code>.</p>
<h2 id="info-for-tables"><a class="header" href="#info-for-tables">Info for Tables</a></h2>
<p>The <code>INFO FOR TABLE</code> statement is used to retrieve information about a specific
table in the SurrealDB. Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let statement = info_for().table("test_table").build();
assert_eq!(statement, "INFO FOR TABLE test_table;");
<span class="boring">}</span></code></pre></pre>
<p>The generated SQL query for this code block would be
<code>INFO FOR TABLE test_table;</code>.</p>
<p>That concludes the documentation for the <code>INFO</code> statement in Surreal ORM. Use
the examples and explanations provided to retrieve information about key-value
pairs, namespaces, databases, scopes, and tables effectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sleep-statement"><a class="header" href="#sleep-statement">Sleep Statement</a></h1>
<p>The <code>SLEEP</code> statement in Surreal ORM is used to introduce a delay or pause in
the execution of a program or query. It allows you to control the timing of your
operations by specifying a duration to wait before proceeding further. This
documentation covers the usage and examples of the <code>SLEEP</code> statement.</p>
<h2 id="table-of-contents-30"><a class="header" href="#table-of-contents-30">Table of Contents</a></h2>
<ul>
<li><a href="statements/sleep.html#sleep-statement-usage">Sleep Statement Usage</a></li>
</ul>
<h2 id="sleep-statement-usage"><a class="header" href="#sleep-statement-usage">Sleep Statement Usage</a></h2>
<p>The <code>SLEEP</code> statement is used to introduce a pause in the program or query
execution. It takes a duration parameter to specify the length of the pause.
Here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Duration;

let statement = sleep(Duration::from_secs(43));
<span class="boring">}</span></code></pre></pre>
<p>In the code snippet above, we create a <code>Duration</code> object with a duration of 43
seconds and pass it to the <code>sleep</code> function to create the <code>SLEEP</code> statement.</p>
<p>You can use the <code>SLEEP</code> statement to introduce delays or pauses in your program
or query execution to control the timing of your operations effectively.</p>
<p>That concludes the documentation for the <code>SLEEP</code> statement in Surreal ORM. Use
the provided examples and explanations to introduce pauses in your program or
query execution as needed.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<h1 id="sql-query-builder-field-operators"><a class="header" href="#sql-query-builder-field-operators">SQL Query Builder: Field Operators</a></h1>
<p>All these operators can also be chained together to create more complex conditions. For instance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>age.outside(18, 65).and(age.not_equal(99));
p1.outside(18, 65).and(p1.not_equal(99));
<span class="boring">}</span></code></pre></pre>
<p>The chaining of these operators is quite flexible and allows for the construction of complex query logic in a clear and concise manner.</p>
<h2 id="table-of-contents-31"><a class="header" href="#table-of-contents-31">Table of Contents</a></h2>
<ul>
<li><a href="operators.html#introduction">Introduction</a></li>
<li><a href="operators.html#comparison-operators">Comparison Operators</a>
<ul>
<li><a href="operators.html#equal-eq"><code>equal</code>, <code>eq</code></a></li>
<li><a href="operators.html#not_equal-neq"><code>not_equal</code>, <code>neq</code></a></li>
<li><a href="operators.html#exactly_equal"><code>exactly_equal</code></a></li>
<li><a href="operators.html#any_equal"><code>any_equal</code></a></li>
<li><a href="operators.html#all_equal"><code>all_equal</code></a></li>
</ul>
</li>
<li><a href="operators.html#string-operators">String Operators</a>
<ul>
<li><a href="operators.html#like"><code>like</code></a></li>
<li><a href="operators.html#not_like"><code>not_like</code></a></li>
<li><a href="operators.html#any_like"><code>any_like</code></a></li>
<li><a href="operators.html#all_like"><code>all_like</code></a></li>
</ul>
</li>
<li><a href="operators.html#relational-operators">Relational Operators</a>
<ul>
<li><a href="operators.html#less_than-lt"><code>less_than</code>, <code>lt</code></a></li>
<li><a href="operators.html#less_than_or_equal-lte"><code>less_than_or_equal</code>, <code>lte</code></a></li>
<li><a href="operators.html#greater_than-gt"><code>greater_than</code>, <code>gt</code></a></li>
<li><a href="operators.html#greater_than_or_equal-gte"><code>greater_than_or_equal</code>, <code>gte</code></a></li>
</ul>
</li>
<li><a href="operators.html#arithmetic-operators">Arithmetic Operators</a>
<ul>
<li><a href="operators.html#add-plus"><code>add</code>, <code>plus</code></a></li>
<li><a href="operators.html#subtract-minus"><code>subtract</code>, <code>minus</code></a></li>
<li><a href="operators.html#multiply-mul"><code>multiply</code>, <code>mul</code></a></li>
<li><a href="operators.html#divide-div"><code>divide</code>, <code>div</code></a></li>
<li><a href="operators.html#power-pow"><code>power</code>, <code>pow</code></a></li>
</ul>
</li>
<li><a href="operators.html#logical-operators">Logical Operators</a>
<ul>
<li><a href="operators.html#truthy_and"><code>truthy_and</code></a></li>
<li><a href="operators.html#truthy_or"><code>truthy_or</code></a></li>
<li><a href="operators.html#and"><code>and</code></a></li>
<li><a href="operators.html#or"><code>or</code></a></li>
<li><a href="operators.html#is"><code>is</code></a></li>
<li><a href="operators.html#is_not"><code>is_not</code></a></li>
</ul>
</li>
<li><a href="operators.html#membership-operators">Membership Operators</a>
<ul>
<li><a href="operators.html#contains"><code>contains</code></a></li>
<li><a href="operators.html#contains_not"><code>contains_not</code></a></li>
<li><a href="operators.html#contains_all"><code>contains_all</code></a></li>
<li><a href="operators.html#contains_any"><code>contains_any</code></a></li>
<li><a href="operators.html#contains_none"><code>contains_none</code></a></li>
<li><a href="operators.html#inside_in"><code>inside</code>, <code>in_</code></a></li>
<li><a href="operators.html#not_inside"><code>not_inside</code></a></li>
<li><a href="operators.html#all_inside"><code>all_inside</code></a></li>
<li><a href="operators.html#any_inside"><code>any_inside</code></a></li>
<li><a href="operators.html#none_inside"><code>none_inside</code></a></li>
<li><a href="operators.html#outside"><code>outside</code></a></li>
<li><a href="operators.html#intersects"><code>intersects</code></a></li>
</ul>
</li>
<li><a href="operators.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h2>
<p>This document provides an overview of the different SQL query field operators available in our SQL Query Builder. For each operator, a brief description, usage, and examples are provided.</p>
<h2 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h2>
<h3 id="equal-eq"><a class="header" href="#equal-eq"><code>equal</code>, <code>eq</code></a></h3>
<p>The <code>equal</code> operator checks if the given field is equal to the provided value. It returns true if the condition is met, and false otherwise.</p>
<p>The <code>eq</code> operator is an alias for <code>equal</code>.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let field = Field::new("field");
</span>field.equal(5);
field.eq(9);

## `not_equal`, `neq`

The `not_equal` operator checks if the given field is not equal to the provided value. It returns true if the condition is met, and false otherwise.

The `neq` operator is an alias for `not_equal`.

Usage:

```rust
<span class="boring">use surreal_orm::*;
</span><span class="boring">let ref price = Field::new("price");
</span>price.not_equal(100);
price.neq(100);
<span class="boring">}</span></code></pre></pre>
<h3 id="exactly_equal"><a class="header" href="#exactly_equal"><code>exactly_equal</code></a></h3>
<p>The <code>exactly_equal</code> operator checks if the given field is exactly equal to the provided value. It is generally used for fields that are binary or have specific precision requirements.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let name = Field::new("name");
</span><span class="boring">let p1 = Field::new("p1");
</span>name.exactly_equal("Oyelowo");
p1.exactly_equal(3.14);
<span class="boring">}</span></code></pre></pre>
<h3 id="any_equal"><a class="header" href="#any_equal"><code>any_equal</code></a></h3>
<p>The <code>any_equal</code> operator checks if any value in a list of values is equal to the given field.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let status = Field::new("status");
</span><span class="boring">let p1 = Field::new("p1");
</span>status.any_equal(vec!["ACTIVE", "IN PROGRESS"]);
p1.any_equal(vec!["APPLE", "BANANA"]);
<span class="boring">}</span></code></pre></pre>
<h3 id="all_equal"><a class="header" href="#all_equal"><code>all_equal</code></a></h3>
<p>The <code>all_equal</code> operator checks if all values in a list are equal to the given field. It's a niche operator and has limited use.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let id = Field::new("id");
</span><span class="boring">let p1 = Field::new("p1");
</span>id.all_equal([1, 3, 5]);
p1.all_equal([2, 2, 2]);
<span class="boring">}</span></code></pre></pre>
<h3 id="like"><a class="header" href="#like"><code>like</code></a></h3>
<p>The <code>like</code> operator checks if the given field matches the provided pattern. <code>%</code> is used as a wildcard character.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let name = Field::new("name");
</span><span class="boring">let p1 = Field::new("p1");
</span>name.like("Jo");
p1.like("son");
<span class="boring">}</span></code></pre></pre>
<h3 id="not_like"><a class="header" href="#not_like"><code>not_like</code></a></h3>
<p>The <code>not_like</code> operator checks if the given field does not match the provided pattern. <code>%</code> is used as a wildcard character.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let name = Field::new("name");
</span><span class="boring">let p1 = Field::new("p1");
</span>name.not_like("Jo%");
p1.not_like("%son");
<span class="boring">}</span></code></pre></pre>
<h3 id="any_like"><a class="header" href="#any_like"><code>any_like</code></a></h3>
<p>The <code>any_like</code> operator checks if any value in a list of values matches the given field.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let status = Field::new("status");
</span><span class="boring">let p1 = Field::new("p1");
</span>status.any_like(vec!["ACTIVE", "IN PROGRESS"]);
p1.any_like(vec!["APPLE", "BANANA"]);
<span class="boring">}</span></code></pre></pre>
<h3 id="all_like"><a class="header" href="#all_like"><code>all_like</code></a></h3>
<p>The <code>all_like</code> operator checks if all values in a list match the given field. It's a niche operator and has limited use.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let id = Field::new("id");
</span><span class="boring">let p1 = Field::new("p1");
</span>id.all_like(vec!["1", "2", "4"]);
p1.all_like(vec!["2", "2", "2"]);
<span class="boring">}</span></code></pre></pre>
<h3 id="less_than-lt"><a class="header" href="#less_than-lt"><code>less_than</code>, <code>lt</code></a></h3>
<p>The <code>less_than</code> operator checks if the given field is less than the provided value.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let age = Field::new("age");
</span><span class="boring">let p1 = Field::new("p1");
</span>age.less_than(18);
p1.lt(100);
<span class="boring">}</span></code></pre></pre>
<h3 id="less_than_or_equal-lte"><a class="header" href="#less_than_or_equal-lte"><code>less_than_or_equal</code>, <code>lte</code></a></h3>
<p>The <code>less_than_or_equal</code> operator checks if the given field is less than or equal to the provided value.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let age = Field::new("age");
</span><span class="boring">let p1 = Field::new("p1");
</span>age.less_than_or_equal(18);
p1.lte(100);
<span class="boring">}</span></code></pre></pre>
<h3 id="greater_than-gt"><a class="header" href="#greater_than-gt"><code>greater_than</code>, <code>gt</code></a></h3>
<p>The <code>greater_than</code> operator checks if the given field is greater than the provided value.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let age = Field::new("age");
</span><span class="boring">let p1 = Field::new("p1");
</span>age.greater_than(18);
p1.gt(100);
<span class="boring">}</span></code></pre></pre>
<h3 id="greater_than_or_equal-gte"><a class="header" href="#greater_than_or_equal-gte"><code>greater_than_or_equal</code>, <code>gte</code></a></h3>
<p>The <code>greater_than_or_equal</code> operator checks if the given field is greater than or equal to the provided value.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let age = Field::new("age");
</span><span class="boring">let p1 = Field::new("p1");
</span>age.greater_than_or_equal(18);
p1.gte(100);
<span class="boring">}</span></code></pre></pre>
<h2 id="add-plus"><a class="header" href="#add-plus">add, plus, +</a></h2>
<p>The <code>add</code> operator adds a value to the given field.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let salary = Field::new("salary");
</span><span class="boring">let age = Field::new("age");
</span><span class="boring">let p1 = Field::new("p1");
</span>salary.add(500);
age + 500;
p1.plus(200);
<span class="boring">}</span></code></pre></pre>
<h2 id="subtract-minus"><a class="header" href="#subtract-minus">subtract, minus, -</a></h2>
<p>The <code>subtract</code> operator subtracts a value from the given field.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let salary = Field::new("salary");
</span><span class="boring">let age = Field::new("age");
</span><span class="boring">let p1 = Field::new("p1");
</span>salary.subtract(500);
age - 500;
p1.subtract(200);
<span class="boring">}</span></code></pre></pre>
<h2 id="multiply-mul"><a class="header" href="#multiply-mul">multiply, mul, *</a></h2>
<p>The <code>multiply</code> operator multiplies the given field by the provided value.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let salary = Field::new("salary");
</span><span class="boring">let quantity = Field::new("quantity");
</span><span class="boring">let p1 = Field::new("p1");
</span>quantity.multiply(price);
salary * 434;
p1.multiply(10);
<span class="boring">}</span></code></pre></pre>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">quantity * price
p1 * 10
</code></pre>
<h2 id="divide-div"><a class="header" href="#divide-div">divide, div, /</a></h2>
<p>The <code>divide</code> operator divides the given field by the provided value.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let salary = Field::new("salary");
</span><span class="boring">let quantity = Field::new("quantity");
</span><span class="boring">let count = Field::new("count");
</span><span class="boring">let param = Param::new("param");
</span>salary.divide(343);
quantity / count;
param.div(2);
<span class="boring">}</span></code></pre></pre>
<h3 id="power-pow"><a class="header" href="#power-pow"><code>power</code>, <code>pow</code></a></h3>
<p>The <code>power</code> operator raises the given field to the power of the provided value.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let length = Field::new("length");
</span><span class="boring">let p1 = Field::new("p1");
</span>length.power(2);
p1.power(3);
<span class="boring">}</span></code></pre></pre>
<h3 id="trthy_and"><a class="header" href="#trthy_and"><code>trthy_and</code></a></h3>
<p>The <code>truthy_and</code> operator performs a logical AND operation between the field and the provided value.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let is_active = Field::new("is_active");
</span>is_active.truthy_and(true);
<span class="boring">}</span></code></pre></pre>
<h3 id="truthy_or"><a class="header" href="#truthy_or"><code>truthy_or</code></a></h3>
<p>The <code>truthy_or</code> operator performs a logical OR operation between the field and the provided value.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let is_active = Field::new("is_active");
</span>is_active.truthy_or(is_paid);
<span class="boring">}</span></code></pre></pre>
<p>This will generate the following SQL statement:</p>
<pre><code class="language-sql">is_active OR is_paid
p1 OR p2
</code></pre>
<h3 id="and"><a class="header" href="#and"><code>and</code></a></h3>
<p>The <code>and</code> operator is used to combine multiple conditions in a WHERE clause to create more complex conditions. It returns true if all conditions are true.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let price = Field::new("price");
</span>price.and(54).and(92);
<span class="boring">}</span></code></pre></pre>
<h3 id="or"><a class="header" href="#or"><code>or</code></a></h3>
<p>The <code>or</code> operator is used to combine multiple conditions in a WHERE clause to create more complex conditions. It returns true if at least one of the conditions is true.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let  = Field::new("price");
</span>is_active.or(is_paid);
p1.or(p2);
<span class="boring">}</span></code></pre></pre>
<p>This will generate the following SQL statement:</p>
<h3 id="is"><a class="header" href="#is"><code>is</code></a></h3>
<p>The <code>is</code> operator compares if a field is equal to a specific value.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let age = Field::new("age");
</span><span class="boring">let p1 = Field::new("p1");
</span>age.is(21);
p1.is("John");
<span class="boring">}</span></code></pre></pre>
<h3 id="is_not"><a class="header" href="#is_not"><code>is_not</code></a></h3>
<p>The <code>is_not</code> operator compares if a field is not equal to a specific value.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let age = Field::new("age");
</span>age.is_not(21);
p1.is_not("John");
<span class="boring">}</span></code></pre></pre>
<h3 id="contains"><a class="header" href="#contains"><code>contains</code></a></h3>
<p>The <code>contains</code> operator checks if a field contains a specific value.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let names = Field::new("names");
</span>names.contains("John");
<span class="boring">}</span></code></pre></pre>
<h3 id="contains_not"><a class="header" href="#contains_not"><code>contains_not</code></a></h3>
<p>The <code>contains_not</code> operator checks if a field does not contain a specific value.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let names = Field::new("names");
</span>names.contains_not("John");
<span class="boring">}</span></code></pre></pre>
<h3 id="contains_all"><a class="header" href="#contains_all"><code>contains_all</code></a></h3>
<p>The <code>contains_all</code> operator checks if a field contains all specified values.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let tags = Field::new("tags");
</span>tags.contains_all(vec!["novel", "adventure"]);
<span class="boring">}</span></code></pre></pre>
<h3 id="contains_any"><a class="header" href="#contains_any"><code>contains_any</code></a></h3>
<p>The <code>contains_any</code> operator checks if a field contains any of the specified values.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let tags = Field::new("tags");
</span>tags.contains_any(vec!["novel", "adventure"]);
<span class="boring">}</span></code></pre></pre>
<h3 id="contains_none"><a class="header" href="#contains_none"><code>contains_none</code></a></h3>
<p>The <code>contains_none</code> operator checks if a field does not contain any of the specified values.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let tags = Field::new("tags");
</span>tags.contains_none(vec!["novel", "adventure"]);
<span class="boring">}</span></code></pre></pre>
<h3 id="inside-and-in_"><a class="header" href="#inside-and-in_"><code>inside</code> and <code>in_</code></a></h3>
<p>The <code>inside</code> and <code>in_</code> operators check if a field's value is within a specified array of values.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let scores = Field::new("scores");
</span><span class="boring">let p1 = Field::new("p1");
</span>scores.inside(vec![20, 30, 40]);
p1.inside(vec![20, 30, 40]);
<span class="boring">}</span></code></pre></pre>
<h3 id="not_inside"><a class="header" href="#not_inside"><code>not_inside</code></a></h3>
<p>The <code>not_inside</code> operator checks if a field's value is not within a specified array of values.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let scores = Field::new("scores");
</span>scores.not_inside(vec![20, 30, 40]);
<span class="boring">}</span></code></pre></pre>
<h3 id="all_inside"><a class="header" href="#all_inside"><code>all_inside</code></a></h3>
<p>The <code>all_inside</code> operator checks if all values in a field are within a specified array of values.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let tags = Field::new("tags");
</span>tags.all_inside(["novel", "adventure", "mystery"]);
<span class="boring">}</span></code></pre></pre>
<h3 id="any_inside"><a class="header" href="#any_inside"><code>any_inside</code></a></h3>
<p>The <code>any_inside</code> operator checks if any value in a field is within a specified array of values.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let tags = Field::new("tags");
</span>tags.any_inside(vec!["novel", "adventure", "mystery"]);
<span class="boring">}</span></code></pre></pre>
<h3 id="none_inside"><a class="header" href="#none_inside"><code>none_inside</code></a></h3>
<p>The <code>none_inside</code> operator checks if none of the values in a field are within a specified array of values.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let tags = Field::new("tags");
</span>tags.none_inside(["novel", "adventure", "mystery"]);
<span class="boring">}</span></code></pre></pre>
<h3 id="outside"><a class="header" href="#outside"><code>outside</code></a></h3>
<p>The <code>outside</code> operator checks whether a geometry value is outside another geometry value.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let point = Field::new("point");
</span><span class="boring">let area = Param::new("area");
</span>point.outside(area);
<span class="boring">}</span></code></pre></pre>
<h3 id="intersects"><a class="header" href="#intersects"><code>intersects</code></a></h3>
<p>The <code>intersects</code> operator checks whether a geometry value intersects annother geometry value.</p>
<p>Usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use surreal_orm::*;
</span><span class="boring">let area1 = Field::new("area1");
</span><span class="boring">let area2 = Field::new("area2");
</span>area1.intersects(area2);
<span class="boring">}</span></code></pre></pre>
<p>Also, note the distinction between <code>Field</code> and <code>Param</code> in the usage and examples.
A <code>Field</code> represents a column in a database table, while a <code>Param</code> represents a parameter
that could be used in the for value assignment. These are interchangeable in the context of these operators,
meaning that you can apply the same operators whether you are comparing fields or parameters.</p>
<h2 id="conclusion-5"><a class="header" href="#conclusion-5">Conclusion</a></h2>
<p>This document covers the complete list of SQL Query Builder field operators.
Using these operators will help you build complex and robust SQL queries.
Always ensure that you use the correct operator for your specific needs to prevent unexpected results or errors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parameters"><a class="header" href="#parameters">Parameters</a></h1>
<p>Parameters in SurrealDB serve as essential tools for storing and manipulating
data within queries. The ORM simplifies this process, making it intuitive and
streamlined.</p>
<h2 id="table-of-contents-32"><a class="header" href="#table-of-contents-32">Table of Contents</a></h2>
<ul>
<li><a href="parameters.html#query-creation-and-execution">Parameters in Query Creation and Execution</a></li>
<li><a href="parameters.html#native-orm-parameters">Native ORM Parameters</a></li>
<li><a href="parameters.html#advanced-parameter-name-creation">Advanced Parameter Name Creation</a></li>
</ul>
<h2 id="query-creation-and-execution"><a class="header" href="#query-creation-and-execution">Query Creation and Execution</a></h2>
<p>The ORM abstracts away much of the complexity involved in crafting queries. To
calculate the average strength of weapons, for instance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
</span><span class="boring">db.use_ns("test").use_db("test").await.unwrap();
</span><span class="boring">
</span><span class="boring">let ref weapon = Weapon::table();
</span><span class="boring">let weapon::Schema { ref strength, .. } = Weapon::schema();
</span><span class="boring">let weapon_stats::Schema {
</span><span class="boring">    averageStrength, ..
</span><span class="boring">} = WeaponStats::schema();
</span><span class="boring">
</span><span class="boring">let generated_weapons = (0..=14)
</span><span class="boring">    .map(|i| Weapon {
</span><span class="boring">        name: format!("weapon_{}", i),
</span><span class="boring">        strength: i,
</span><span class="boring">        ..Default::default()
</span><span class="boring">    })
</span><span class="boring">    .collect::&lt;Vec&lt;_&gt;&gt;();
</span><span class="boring">
</span><span class="boring">insert(generated_weapons).return_many(db.clone()).await?;
</span>

let created_stats_statement = create::&lt;WeaponStats&gt;().set(averageStrength.equal_to(block! {
    LET strengths = select_value(strength).from(weapon);
    LET total = math::sum!(strengths);
    LET count = count!(strengths);
    LET distance = 65;
    RETURN math::ceil!((((total / count) * (count * total)) / (total + 4)) * 100);
}));


assert_eq!(
    created_stats_statement.to_raw().build(),
    "CREATE weapon_stats SET averageStrength = {\n\
            LET $strengths = (SELECT VALUE strength FROM weapon);\n\n\
            LET $total = math::sum($strengths);\n\n\
            LET $count = count($strengths);\n\n\
            RETURN math::ceil(((($total / $count) * ($count * $total)) / ($total + 4)) * 100);\n\
            };"
);

assert_eq!(
    created_stats_statement.fine_tune_params(),
    "CREATE weapon_stats SET averageStrength = {\n\
            LET $strengths = $_param_00000001;\n\n\
            LET $total = math::sum($strengths);\n\n\
            LET $count = count($strengths);\n\n\
            RETURN math::ceil(((($total / $count) * ($count * $total)) / ($total + $_param_00000002)) * $_param_00000003);\n\
            };"
);
<span class="boring">}</span></code></pre></pre>
<p>This block of code demonstrates the ORM's ability to define and utilize
parameters within queries.</p>
<h2 id="native-orm-parameters"><a class="header" href="#native-orm-parameters">Native ORM Parameters</a></h2>
<p>SurrealDB provides a set of predefined variables designed to simplify query
development. While these predefined parameters can be utilized directly within
your queries, it's crucial to note that you cannot declare new parameters with
these specific names. The ORM is equipped with built-in functions that represent
these standard SurrealDB parameters. A function like <code>after()</code> corresponds to
the <code>$after</code> parameter in raw queries. These functions allow developers to
interact with the database at a high level, abstracting away the complexity of
raw queries.</p>
<p>To bridge this system with the ORM, these predefined variables are represented
by functions in the ORM, each mimicking the name of the corresponding parameter:</p>
<p>Here's a list of some of the prominent parameters and their descriptions:</p>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameter</th><th>Description</th></tr></thead><tbody>
<tr><td><code>auth()</code></td><td><code>$auth</code></td><td>Represents the currently authenticated scope user.</td></tr>
<tr><td><code>token()</code></td><td><code>$token</code></td><td>Represents values held inside the JWT token used for the current session.</td></tr>
<tr><td><code>session()</code></td><td><code>$session</code></td><td>Values from session functions as an object.</td></tr>
<tr><td><code>before()</code></td><td><code>$before</code></td><td>Value before a field mutation.</td></tr>
<tr><td><code>after()</code></td><td><code>$after</code></td><td>Value post field mutation.</td></tr>
<tr><td><code>value()</code></td><td><code>$value</code></td><td>Post mutation value (identical to <code>$after</code> for events).</td></tr>
<tr><td><code>input()</code></td><td><code>$input</code></td><td>Initially inputted value in a field definition; the value clause might have modified the <code>$value</code> variable.</td></tr>
<tr><td><code>parent()</code></td><td><code>$parent</code></td><td>Parent record in a subquery.</td></tr>
<tr><td><code>event()</code></td><td><code>$event</code></td><td>Type of table event triggered on an event.</td></tr>
</tbody></table>
</div>
<p>These native functions simplify the query-writing process, enabling developers
to focus on the logic of their application without getting bogged down by the
intricacies of the database language.</p>
<h2 id="advanced-parameter-name-creation"><a class="header" href="#advanced-parameter-name-creation">Advanced Parameter Name Creation</a></h2>
<p>For those requiring further customization, the <code>create_param_name_fn!()</code> macro
is available. This macro not only aids in generating custom parameter names but
also supports field traversal using parameter paths. Typically though, you will
use this with the <code>define_param</code> statement when you want to define a constant
global variable. However, in a typical <code>let statement</code> (e.g used within the
<code>block!</code> macro), this is automatically handled.</p>
<p>Suppose you want to create a custom parameter name for a user's age. Using the
macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_param_name_fn!(user_age);
<span class="boring">}</span></code></pre></pre>
<p>If you would like to add a rust doc comment, you can do so as shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_param_name_fn!(
    /// $user_age represents the age of a user
    =&gt; userAge
);
<span class="boring">}</span></code></pre></pre>
<p>To use the param name created above, you can invoke it as <code>user_age</code></p>
<p>This means that any parameter name created with this macro can be used for field
traversal. For more information on field traversal, refer to the
<a href="./concepts/field_traversal.html">Field Traversal chapter</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-management-in-surreal-orm"><a class="header" href="#transaction-management-in-surreal-orm">Transaction Management in Surreal ORM</a></h1>
<p>Surreal ORM provides transaction management capabilities to ensure the integrity
and consistency of database operations. This allows you to group multiple
database operations into a single atomic unit that can be committed or canceled
as a whole. This documentation covers the Begin Transaction, Commit Statement,
and Cancel Transaction features in Surreal ORM.</p>
<h2 id="table-of-contents-33"><a class="header" href="#table-of-contents-33">Table of Contents</a></h2>
<ul>
<li><a href="transactions.html#begin-transaction">Begin Transaction</a></li>
<li><a href="transactions.html#commit-statement">Commit Statement</a>
<ul>
<li><a href="transactions.html#recommended-approaches">Recommended Approaches</a>
<ul>
<li><a href="transactions.html#using-block-macro-with-commit-statement-also-within-block-for-chaining-multiple-statements">Using <code>block!</code> Macro with Commit Statement also Within Block for Chaining Multiple Statements</a></li>
<li><a href="transactions.html#using-begintransaction-function-with-block-macro-for-chaining-multiple-statements">Using begin_transaction function with <code>block!</code> Macro for Chaining Multiple Statements</a></li>
</ul>
</li>
<li><a href="transactions.html#less-recommended-approach">Less Recommended Approach</a>
<ul>
<li><a href="transactions.html#chaining-multiple-statements-directly">Chaining Multiple Statements Directly</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="transactions.html#cancel-transaction">Cancel Transaction</a></li>
<li><a href="transactions.html#handling-transactions-with-database-operations">Handling Transactions with Database Operations</a></li>
</ul>
<h2 id="begin-transaction"><a class="header" href="#begin-transaction">Begin Transaction</a></h2>
<p>The <code>begin_transaction</code> statement in Surreal ORM marks the beginning of a
transaction. It sets the context for a series of database operations that should
be treated as a single atomic unit. By starting a transaction, you can ensure
the integrity and consistency of your database operations.</p>
<p>To begin a transaction, you can use the <code>begin_transaction</code> statement. Let's see
an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
db.use_ns("test").use_db("test").await.unwrap();

begin_transaction()
...
// Perform database operations within the transaction
;

// or
block!{
    BEGIN TRANSACTION;
    ...
// Perform database operations within the transaction
}


Ok(())
<span class="boring">}</span></code></pre></pre>
<p>In the code snippet above, the <code>begin_transaction</code> statement is used to start a
transaction. This sets the context for the subsequent database operations.</p>
<h2 id="commit-statement-1"><a class="header" href="#commit-statement-1">Commit Statement</a></h2>
<p>The <code>commit</code> statement in Surreal ORM is used to commit a transaction and save
the changes made within the transaction. It ensures that the changes are durable
and permanent in the database.</p>
<h3 id="recommended-approaches-2"><a class="header" href="#recommended-approaches-2">Recommended Approaches</a></h3>
<h4 id="using-block-macro-with-commit-statement-also-within-block-for-chaining-multiple-statements-1"><a class="header" href="#using-block-macro-with-commit-statement-also-within-block-for-chaining-multiple-statements-1">Using <code>block!</code> Macro with Commit Statement also Within Block for Chaining Multiple Statements</a></h4>
<p>To perform a transaction and commit the changes, you can use the <code>block!</code> macro
to chain multiple statements together. The <code>commit_transaction</code> statement is
used within the <code>block!</code> macro to explicitly indicate the commitment of the
transaction. Let's take a look at an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
db.use_ns("test").use_db("test").await.unwrap();

let ref id1 = Account::create_id("one".into());
let ref id2 = Account::create_id("two".into());
let acc = Account::schema();

let amount_to_transfer = 300.00;

block! {
    BEGIN TRANSACTION;

    LET acc1 = create().content(Account {
        id: id1.clone(),
        balance: 135_605.16,
    });
    LET acc2 = create().content(Account {
        id: id2.clone(),
        balance: 91_031.31,
    });

    LET updated1 = update::&lt;Account&gt;(id1).set(acc.balance.increment_by(amount_to_transfer));
    LET update2 = update::&lt;Account&gt;(id2).set(acc.balance.decrement_by(amount_to_transfer));

    COMMIT TRANSACTION;
};

Ok(())
<span class="boring">}</span></code></pre></pre>
<p>In the code snippet above, the <code>block!</code> macro is used to define a transaction
with multiple statements. The <code>LET</code> statement is used to bind variables `</p>
<p>acc1<code>,</code>acc2<code>,</code>updated1<code>, and</code>update2<code>to the respective statements.  The</code>BEGIN
TRANSACTION<code>statement marks the start of the transaction, and the</code>COMMIT
TRANSACTION` statement explicitly commits the transaction.</p>
<p>Using the <code>block!</code> macro with the <code>commit_transaction</code> statement within the
block provides a clear and concise way to define a transaction and commit the
changes.</p>
<h4 id="using-begin_transaction-function-with-block-macro-for-chaining-multiple-statements"><a class="header" href="#using-begin_transaction-function-with-block-macro-for-chaining-multiple-statements">Using begin_transaction function with <code>block!</code> Macro for Chaining Multiple Statements</a></h4>
<p>Another recommended approach is to use the <code>block!</code> macro to chain multiple
statements together within a transaction. The <code>commit_transaction</code> statement is
called separately after the <code>block!</code> macro to explicitly commit the transaction.
Let's see an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
db.use_ns("test").use_db("test").await.unwrap();

let ref id1 = Account::create_id("one".into());
let ref id2 = Account::create_id("two".into());
let acc = Account::schema();

let amount_to_transfer = 300.00;

let transaction_query = begin_transaction()
    .query(block! {
        LET acc1 = create().content(Account {
            id: id1.clone(),
            balance: 135_605.16,
        });
        LET acc2 = create().content(Account {
            id: id2.clone(),
            balance: 91_031.31,
        });

        LET updated1 = update::&lt;Account&gt;(id1).set(acc.balance.increment_by(amount_to_transfer));
        LET update2 = update::&lt;Account&gt;(id2).set(acc.balance.decrement_by(amount_to_transfer));
    })
    .commit_transaction();

transaction_query.run(db.clone()).await?;

Ok(())
<span class="boring">}</span></code></pre></pre>
<p>In this approach, the <code>block!</code> macro is used to define a transaction block that
includes multiple statements. The <code>BEGIN TRANSACTION</code> and <code>COMMIT TRANSACTION</code>
statements mark the start and end of the transaction, respectively. The <code>LET</code>
statement is used to bind variables to the statements within the block.</p>
<p>Using the <code>block!</code> macro for chaining multiple statements and explicitly
committing the transaction provides a more structured and organized way to
handle complex transactions.</p>
<h3 id="less-recommended-approach-3"><a class="header" href="#less-recommended-approach-3">Less Recommended Approach</a></h3>
<p>The less recommended approach involves chaining multiple statements directly
without using the <code>block!</code> macro. Although functional, this approach may feel
less ergonomic, especially when there is a need to bind and share variables
within the statements.</p>
<h4 id="chaining-multiple-statements-directly-2"><a class="header" href="#chaining-multiple-statements-directly-2">Chaining Multiple Statements Directly</a></h4>
<p>Here's an example of chaining multiple statements directly without using the
<code>block!</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_transaction_commit_increment_and_decrement_update() -&gt; SurrealOrmResult&lt;()&gt; {
    let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
    db.use_ns("test").use_db("test").await.unwrap();

    let ref id1 = Account::create_id("one".into());
    let ref id2 = Account::create_id("two".into());
    let amount_to_transfer = 300.00;

    let acc = Account::schema();

    begin_transaction()
        .query(create().content(Account {
            id: id1.clone(),
            balance: 135_605.16,
        }))
        .query(create().content(Account {
            id: id2.clone(),
            balance: 91_031.31,
        }))
        .query(update::&lt;Account&gt;(id1).set(acc.balance.increment_by(amount_to_transfer)))
        .query(update::&lt;Account&gt;(id2).set(acc.balance.decrement_by(amount_to_transfer)))
        .commit_transaction()
        .run(db.clone())
        .await?;

    // Assertions and other code...

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>In this approach, multiple statements are chained directly within the
transaction. The <code>create</code> and <code>update</code> statements</p>
<p>are used to perform operations on the <code>Account</code> table.</p>
<p>The less recommended approach of chaining multiple statements directly can be
less ergonomic, especially when dealing with complex transactions that require
variable bindings and subqueries.</p>
<p>It is generally recommended to use the recommended approaches with the <code>block!</code>
macro for better readability, automation of variable bindings, and subquery
handling.</p>
<h2 id="cancel-transaction"><a class="header" href="#cancel-transaction">Cancel Transaction</a></h2>
<p>The <code>cancel</code> transaction feature in Surreal ORM allows you to roll back a
transaction and discard the changes made within the transaction. It is useful
when you want to undo a series of database operations within a transaction.</p>
<p>To cancel a transaction, you can use the <code>cancel_transaction</code> statement. Let's
see an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let db = Surreal::new::&lt;Mem&gt;(()).await.unwrap();
db.use_ns("test").use_db("test").await.unwrap();

let transaction_query = begin_transaction()
    .query(create().content(Account {
        id: Account::create_id("one".into()),
        balance: 135_605.16,
    }))
    .cancel_transaction();

transaction_query.run(db.clone()).await?;

Ok(())
<span class="boring">}</span></code></pre></pre>
<p>In the code snippet above, the <code>cancel_transaction</code> statement is used to cancel
the ongoing transaction. This ensures that any changes made within the
transaction are discarded, and the database state remains unchanged.</p>
<h2 id="handling-transactions-with-database-operations"><a class="header" href="#handling-transactions-with-database-operations">Handling Transactions with Database Operations</a></h2>
<p>When performing database operations within a transaction, it is important to
ensure that the operations are executed as a single atomic unit. Surreal ORM
provides transaction management features to facilitate this.</p>
<p>To handle transactions with database operations, you can follow these steps:</p>
<ol>
<li>Begin the transaction using the <code>begin_transaction</code> statement.</li>
<li>Chain the necessary database operations using the appropriate ORM statements.</li>
<li>Use the recommended approaches described earlier to define and commit the
transaction.</li>
<li>If needed, use the <code>cancel_transaction</code> statement to cancel the transaction
and discard any changes.</li>
</ol>
<p>By following these steps, you can ensure the integrity and consistency of your
database operations and handle transactions effectively.</p>
<p>That concludes the documentation for the Begin Transaction, Commit Statement,
and Cancel Transaction features in Surreal ORM. Use the recommended approaches
to perform transactions, commit changes, handle cancellations, and manage your
database operations effectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-functions"><a class="header" href="#array-functions">Array Functions</a></h1>
<p>Surreal ORM provides a set of array functions that allow you to manipulate and
perform operations on arrays. These functions are designed to work with arrays
of various types, including vectors, fields, and parameters. This documentation
covers the usage and examples of the array functions available in Surreal ORM.</p>
<h2 id="table-of-contents-34"><a class="header" href="#table-of-contents-34">Table of Contents</a></h2>
<!--toc:start-->
<ul>
<li><a href="functions/array.html#array-functions">Array Functions</a>
<ul>
<li><a href="functions/array.html#table-of-contents">Table of Contents</a></li>
<li><a href="functions/array.html#append">Append</a></li>
<li><a href="functions/array.html#combine">Combine</a></li>
<li><a href="functions/array.html#concat">Concat</a></li>
<li><a href="functions/array.html#union">Union</a></li>
<li><a href="functions/array.html#difference">Difference</a></li>
<li><a href="functions/array.html#intersect">Intersect</a></li>
<li><a href="functions/array.html#complement">Complement</a></li>
<li><a href="functions/array.html#distinct">Distinct</a></li>
<li><a href="functions/array.html#flatten">Flatten</a></li>
<li><a href="functions/array.html#group">Group</a></li>
<li><a href="functions/array.html#insert">Insert</a></li>
<li><a href="functions/array.html#len">Len</a></li>
<li><a href="functions/array.html#pop">Pop</a></li>
<li><a href="functions/array.html#prepend">Prepend</a></li>
<li><a href="functions/array.html#push">Push</a></li>
<li><a href="functions/array.html#remove">Remove</a></li>
<li><a href="functions/array.html#reverse">Reverse</a></li>
<li><a href="functions/array.html#sort">Sort</a></li>
<li><a href="functions/array.html#asc-and-desc">Asc and Desc</a></li>
</ul>
<!--toc:end-->
</li>
</ul>
<h2 id="append"><a class="header" href="#append">Append</a></h2>
<p>The <code>append</code> function appends a value to the end of an array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::append!(vec![1, 2, 3, 4, 5], 6);
<span class="boring">}</span></code></pre></pre>
<p>You can use the <code>append</code> function to add values to an existing array.</p>
<h2 id="combine"><a class="header" href="#combine">Combine</a></h2>
<p>The <code>combine</code> function combines all values from two arrays together, returning
an array of arrays.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::combine!(vec![1, 2, 3], vec![4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<p>The <code>combine</code> function provides the same functionality as the <code>append</code> function
but can work with two arrays instead of appending a single value.</p>
<h2 id="concat"><a class="header" href="#concat">Concat</a></h2>
<p>The <code>concat</code> function merges two arrays together, returning an array that may
contain duplicate values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::concat!(vec![1, 2, 3], vec![4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<p>The <code>concat</code> function provides the same functionality as the <code>combine</code> function
but does not remove duplicate values from the resulting array.</p>
<h2 id="union"><a class="header" href="#union">Union</a></h2>
<p>The <code>union</code> function combines two arrays together, removing duplicate values,
and returning a single array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::union!(vec![1, 2, 3], vec![4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<p>The <code>union</code> function provides the same functionality as the <code>concat</code> function
but removes duplicate values from the resulting array.</p>
<h2 id="difference"><a class="header" href="#difference">Difference</a></h2>
<p>The <code>difference</code> function determines the difference between two arrays,
returning a single array containing items that are not in both arrays.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::difference!(vec![1, 2, 3], vec![4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<p>The <code>difference</code> function provides the same functionality</p>
<p>as the previous functions but returns only the unique values that are present in
one array but not in the other.</p>
<h2 id="intersect"><a class="header" href="#intersect">Intersect</a></h2>
<p>The <code>intersect</code> function calculates the values that intersect two arrays,
returning a single array containing the values present in both arrays.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::intersect!(vec![1, 2, 3], vec![4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<p>The <code>intersect</code> function provides the same functionality as the previous
functions but returns only the values that are common between the two arrays.</p>
<h2 id="complement"><a class="header" href="#complement">Complement</a></h2>
<p>The <code>complement</code> function returns the complement of two arrays, returning a
single array containing items that are not in the second array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::complement!(vec![1, 2, 3, 4], vec![3, 4, 5, 6]);
<span class="boring">}</span></code></pre></pre>
<p>The <code>complement</code> function provides the same functionality as the previous
functions but returns only the values that are present in the first array but
not in the second array.</p>
<h2 id="distinct"><a class="header" href="#distinct">Distinct</a></h2>
<p>The <code>distinct</code> function calculates the unique values in an array, returning a
single array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::distinct!(vec![1, 2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>You can use the <code>distinct</code> function to obtain unique values from an array.</p>
<h2 id="flatten"><a class="header" href="#flatten">Flatten</a></h2>
<p>The <code>flatten</code> function flattens an array of arrays, returning a new array with
all sub-array elements concatenated into it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::flatten!(array![vec![1, 2], vec![3, 4], "SurrealDB", vec![5, 6]]);
<span class="boring">}</span></code></pre></pre>
<p>The <code>flatten</code> function provides the same functionality as the previous functions
but flattens an array of arrays.</p>
<h2 id="group"><a class="header" href="#group">Group</a></h2>
<p>The <code>group</code> function flattens and returns the unique items in an array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::group!(array![1, 2, 3, 4, array![3, 5, 6], vec![2, 4, 5, 6], 7, 8, 8, 9]);
<span class="boring">}</span></code></pre></pre>
<p>The <code>group</code> function provides the same functionality as the previous functions
but returns only the unique items in the array.</p>
<h2 id="insert"><a class="header" href="#insert">Insert</a></h2>
<p>The <code>insert</code> function inserts a value into an array at a specific position.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::insert!(vec![1, 2, 3, 4], 5, 2);
<span class="boring">}</span></code></pre></pre>
<p>The <code>insert</code> function allows you to insert a value into an array at a specified
index.</p>
<h2 id="len"><a class="header" href="#len">Len</a></h2>
<p>The <code>len</code> function calculates the length of an array, returning a number. This
function includes all items when counting the number of items in the array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::len!(vec![1, 2, 3]);
<span class="boring">}</span></code></pre></pre>
<p>You can use the <code>len</code> function to calculate the length of an array.</p>
<h2 id="pop"><a class="header" href="#pop">Pop</a></h2>
<p>The <code>pop</code> function removes a value from the end of an array and returns it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::pop!(vec![1, 2, 3, 4]);
<span class="boring">}</span></code></pre></pre>
<p>You can use the <code>pop</code> function to remove the last value from an array.</p>
<h2 id="prepend"><a class="header" href="#prepend">Prepend</a></h2>
<p>The <code>prepend</code> function prepends a value to the end of an array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::prepend!(vec![1, 2, 3, 4], 5);
<span class="boring">}</span></code></pre></pre>
<p>You can use the <code>prepend</code> function to add a value to the beginning of an array.</p>
<h2 id="push"><a class="header" href="#push">Push</a></h2>
<p>The <code>push</code> function appends a value to the end of an array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::push!(vec![1, 2, 3, 4], 5);
<span class="boring">}</span></code></pre></pre>
<p>The <code>push</code> function provides the same functionality as the <code>prepend</code> function
but appends the value to the end of the array instead of the beginning.</p>
<h2 id="remove"><a class="header" href="#remove">Remove</a></h2>
<p>The <code>remove</code> function removes an item from a specific position in an array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::remove!(vec![1, 2, 3, 4, 5], 2);
<span class="boring">}</span></code></pre></pre>
<p>You can use the <code>remove</code> function to delete an item from a specific position in
an array.</p>
<h2 id="reverse"><a class="header" href="#reverse">Reverse</a></h2>
<p>The <code>reverse</code> function reverses the order of the elements in an array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::reverse!(vec![1, 2, 3, 4, 5]);
<span class="boring">}</span></code></pre></pre>
<p>You can use the <code>reverse</code> function to reverse the order of elements in an array.</p>
<h2 id="sort"><a class="header" href="#sort">Sort</a></h2>
<p>The <code>sort</code> function sorts an array in ascending or descending order.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result = array::sort!(vec![3, 1, 2], "asc");
<span class="boring">}</span></code></pre></pre>
<p>You can use the <code>sort</code> function to sort an array in ascending or descending
order.</p>
<p>The <code>sort</code> function also provides the following ordering options:</p>
<ul>
<li><code>"asc"</code>: Sorts the array in ascending order.</li>
<li><code>"desc"</code>: Sorts the array in descending order.</li>
<li><code>false</code>: Does not sort the array.</li>
</ul>
<p>You can use the <code>sort</code> function with different ordering options to sort an array
accordingly.</p>
<h2 id="asc-and-desc"><a class="header" href="#asc-and-desc">Asc and Desc</a></h2>
<p>The <code>asc</code> and <code>desc</code> functions are shorthand convenience functions for the
<code>sort</code> function. They sort values in an array in ascending or descending order,
respectively.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{functions::array, *};

let result_asc = array::sort::asc!(vec![3, 1, 2]);
let result_desc = array::sort::desc!(vec![3, 1, 2]);
<span class="boring">}</span></code></pre></pre>
<p>The <code>asc</code> and <code>desc</code> functions provide the same functionality as the <code>sort</code>
function but with a more concise syntax.</p>
<p>These are the array functions available in Surreal ORM. Use them to perform
various operations on arrays and manipulate array data effectively.</p>
<p>That concludes the documentation for the array functions in Surreal ORM. Refer
to this documentation whenever you need to use array functions in your code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="count-function"><a class="header" href="#count-function">Count Function</a></h1>
<p>This chapter introduces the <code>count</code> macros provided by Surreal ORM. The <code>count</code>
macros are used to generate SQL queries for counting records in a database
table.</p>
<h2 id="table-of-contents-35"><a class="header" href="#table-of-contents-35">Table of Contents</a></h2>
<ul>
<li><a href="functions/count.html#count">count!()</a></li>
<li><a href="functions/count.html#count-alias">count!().__as__(alias)</a></li>
<li><a href="functions/count.html#count-field">count!(field)</a></li>
<li><a href="functions/count.html#count-field-operation">count!(field.operation(value))</a></li>
<li><a href="functions/count.html#count-condition-and">count!(condition1.and(condition2))</a></li>
<li><a href="functions/count.html#count-array">count!(array)</a></li>
</ul>
<h2 id="count"><a class="header" href="#count">count!()</a></h2>
<p>The <code>count!()</code> macro counts all records in a table. It generates the SQL query
<code>count()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{count, *};

let result = count!();
<span class="boring">}</span></code></pre></pre>
<p>Generated SQL query:</p>
<pre><code class="language-sql">count()
</code></pre>
<p>The <code>count!()</code> macro provides the following functionality:</p>
<ul>
<li><code>to_raw().build()</code>: Converts the <code>count</code> macro into a raw SQL query string. In
this case, it would be <code>"count()"</code>.</li>
</ul>
<h2 id="count__as__alias"><a class="header" href="#count__as__alias">count!().__as__(alias)</a></h2>
<p>The <code>count!().__as__(alias)</code> macro allows you to specify an alias for the count
result. It generates the SQL query <code>count() AS alias</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{count, AliasName};

let head_count = AliasName::new("head_count");
let result = count!().__as__(head_count);
<span class="boring">}</span></code></pre></pre>
<p>Generated SQL query:</p>
<pre><code class="language-sql">count() AS head_count
</code></pre>
<p>The <code>count!().__as__(alias)</code> macro provides the same functionality as
<code>count!()</code>, but with an additional <code>AS</code> clause to specify the alias for the
count result.</p>
<h2 id="countfield"><a class="header" href="#countfield">count!(field)</a></h2>
<p>The <code>count!(field)</code> macro counts records in a table based on a specific field.
It generates the SQL query <code>count(field)</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{count, Field};

let email = Field::new("email");
let result = count!(email);
<span class="boring">}</span></code></pre></pre>
<p>Generated SQL query:</p>
<pre><code class="language-sql">count(email)
</code></pre>
<p>The <code>count!(field)</code> macro provides the same functionality as <code>count!()</code>, but
with a specific field to count records on.</p>
<h2 id="countfieldoperationvalue"><a class="header" href="#countfieldoperationvalue">count!(field.operation(value))</a></h2>
<p>The <code>count!(field.operation(value))</code> macro allows you to perform filter
operations on the count. It generates the SQL query
<code>count(field.operation(value))</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{count, Field};

let email = Field::new("email");
let result = count!(email.greater_than(15));
<span class="boring">}</span></code></pre></pre>
<p>Generated SQL query:</p>
<pre><code class="language-sql">count(email &gt; 15)
</code></pre>
<p>The <code>count!(field.operation(value))</code> macro provides the same functionality as
<code>count!(field)</code>, but with a filter operation applied to the field.</p>
<h2 id="countcondition1andcondition2"><a class="header" href="#countcondition1andcondition2">count!(condition1.and(condition2))</a></h2>
<p>The <code>count!(condition1.and(condition2))</code> macro allows you to apply multiple
conditions to the count. It generates the SQL query
<code>count(condition1 AND condition2)</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{count, Field, cond};

let email = Field::new("email");
let age = Field::new("age");
let result = count!(cond(age.greater_than(15)).and(email.like("oyelowo@example.com")));
<span class="boring">}</span></code></pre></pre>
<p>Generated SQL query:</p>
<pre><code class="language-sql">count((age &gt; 15) AND (email ~ 'oyelowo@example.com'))
</code></pre>
<p>The `count!(condition1.and(condition2))</p>
<p><code>macro provides the same functionality as</code>count!(field.operation(value))<code>, but with multiple conditions combined using the</code>AND`
operator.</p>
<h2 id="countarray"><a class="header" href="#countarray">count!(array)</a></h2>
<p>The <code>count!(array)</code> macro counts the number of elements in an array. It
generates the SQL query <code>count(array)</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{count, array};

let result = count!(array![1, 2, 3, 4, 5]);
<span class="boring">}</span></code></pre></pre>
<p>Generated SQL query:</p>
<pre><code class="language-sql">count([1, 2, 3, 4, 5])
</code></pre>
<p>The <code>count!(array)</code> macro provides the same functionality as <code>count!()</code>, but
with an array as the input for counting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crypto-functions"><a class="header" href="#crypto-functions">Crypto Functions</a></h1>
<p>This chapter introduces the crypto macros provided by Surreal ORM. The crypto
macros are used for cryptographic operations such as password hashing and
comparison.</p>
<h2 id="table-of-contents-36"><a class="header" href="#table-of-contents-36">Table of Contents</a></h2>
<ul>
<li><a href="functions/crypto.html#argon2-compare-macro">argon2::compare!()</a></li>
<li><a href="functions/crypto.html#argon2-generate-macro">argon2::generate!()</a></li>
<li><a href="functions/crypto.html#pbkdf2-compare-macro">pbkdf2::compare!()</a></li>
<li><a href="functions/crypto.html#pbkdf2-generate-macro">pbkdf2::generate!()</a></li>
<li><a href="functions/crypto.html#scrypt-compare-macro">scrypt::compare!()</a></li>
<li><a href="functions/crypto.html#scrypt-generate-macro">scrypt::generate!()</a></li>
<li><a href="functions/crypto.html#bcrypt-compare-macro">bcrypt::compare!()</a></li>
<li><a href="functions/crypto.html#bcrypt-generate-macro">bcrypt::generate!()</a></li>
</ul>
<h2 id="argon2compare"><a class="header" href="#argon2compare"><a name="argon2-compare-macro"></a>argon2::compare!()</a></h2>
<p>The <code>argon2::compare!()</code> macro compares two values using the Argon2 hashing
algorithm. It has the following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = argon2::compare!("Oyelowo", "Oyedayo");
<span class="boring">}</span></code></pre></pre>
<p>The <code>argon2::compare!()</code> macro generates the following SQL query:</p>
<pre><code class="language-plaintext">crypto::argon2::compare('Oyelowo', 'Oyedayo')
</code></pre>
<h2 id="argon2generate"><a class="header" href="#argon2generate"><a name="argon2-generate-macro"></a>argon2::generate!()</a></h2>
<p>The <code>argon2::generate!()</code> macro generates a hash value using the Argon2 hashing
algorithm. It has the following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = argon2::generate!("Oyelowo");
<span class="boring">}</span></code></pre></pre>
<p>The <code>argon2::generate!()</code> macro generates the following SQL query:</p>
<pre><code class="language-plaintext">crypto::argon2::generate('Oyelowo')
</code></pre>
<h2 id="pbkdf2compare"><a class="header" href="#pbkdf2compare"><a name="pbkdf2-compare-macro"></a>pbkdf2::compare!()</a></h2>
<p>The <code>pbkdf2::compare!()</code> macro compares two values using the PBKDF2 hashing
algorithm. It has the following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = pbkdf2::compare!("hash_value", "password");
<span class="boring">}</span></code></pre></pre>
<p>The <code>pbkdf2::compare!()</code> macro generates the following SQL query:</p>
<pre><code class="language-plaintext">crypto::pbkdf2::compare('hash_value', 'password')
</code></pre>
<h2 id="pbkdf2generate"><a class="header" href="#pbkdf2generate"><a name="pbkdf2-generate-macro"></a>pbkdf2::generate!()</a></h2>
<p>The <code>pbkdf2::generate!()</code> macro generates a hash value using the PBKDF2 hashing
algorithm. It has the following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = pbkdf2::generate!("password");
<span class="boring">}</span></code></pre></pre>
<p>The <code>pbkdf2::generate!()</code> macro generates the following SQL query:</p>
<pre><code class="language-plaintext">crypto::pbkdf2::generate('password')
</code></pre>
<h2 id="scryptcompare"><a class="header" href="#scryptcompare"><a name="scrypt-compare-macro"></a>scrypt::compare!()</a></h2>
<p>The <code>scrypt::compare!()</code> macro compares two values using the scrypt hashing
algorithm. It has the following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = scrypt::compare!("hash_value", "password");
<span class="boring">}</span></code></pre></pre>
<p>The <code>scrypt::compare!()</code> macro generates the following SQL query:</p>
<pre><code class="language-plaintext">crypto::scrypt::compare('hash_value', 'password')
</code></pre>
<h2 id="scryptgenerate"><a class="header" href="#scryptgenerate"><a name="scrypt-generate-macro"></a>scrypt::generate!()</a></h2>
<p>The <code>scrypt::generate!()</code> macro generates a hash value using the scrypt hashing
algorithm. It has the</p>
<p>following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = scrypt::generate!("password");
<span class="boring">}</span></code></pre></pre>
<p>The <code>scrypt::generate!()</code> macro generates the following SQL query:</p>
<pre><code class="language-plaintext">crypto::scrypt::generate('password')
</code></pre>
<h2 id="bcryptcompare"><a class="header" href="#bcryptcompare"><a name="bcrypt-compare-macro"></a>bcrypt::compare!()</a></h2>
<p>The <code>bcrypt::compare!()</code> macro compares two values using the bcrypt hashing
algorithm. It has the following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = bcrypt::compare!("hash_value", "password");
<span class="boring">}</span></code></pre></pre>
<p>The <code>bcrypt::compare!()</code> macro generates the following SQL query:</p>
<pre><code class="language-plaintext">crypto::bcrypt::compare('hash_value', 'password')
</code></pre>
<h2 id="bcryptgenerate"><a class="header" href="#bcryptgenerate"><a name="bcrypt-generate-macro"></a>bcrypt::generate!()</a></h2>
<p>The <code>bcrypt::generate!()</code> macro generates a hash value using the bcrypt hashing
algorithm. It has the following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = bcrypt::generate!("password");
<span class="boring">}</span></code></pre></pre>
<p>The <code>bcrypt::generate!()</code> macro generates the following SQL query:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geo-functions"><a class="header" href="#geo-functions">Geo Functions</a></h1>
<p>This chapter introduces the geo macros provided by the Surreal ORM. The geo
macros are used for geospatial operations such as calculating area, distance,
bearing, centroid, and encoding/decoding hashes.</p>
<h2 id="table-of-contents-37"><a class="header" href="#table-of-contents-37">Table of Contents</a></h2>
<ul>
<li><a href="functions/geo.html#geo-area-macro">geo::area!()</a></li>
<li><a href="functions/geo.html#geo-bearing-macro">geo::bearing!()</a></li>
<li><a href="functions/geo.html#geo-centroid-macro">geo::centroid!()</a></li>
<li><a href="functions/geo.html#geo-distance-macro">geo::distance!()</a></li>
<li><a href="functions/geo.html#geo-hash-decode-macro">geo::hash::decode!()</a></li>
<li><a href="functions/geo.html#geo-hash-encode-macro">geo::hash::encode!()</a></li>
</ul>
<h2 id="geoarea"><a class="header" href="#geoarea"><a name="geo-area-macro"></a>geo::area!()</a></h2>
<p>The <code>geo::area!()</code> macro calculates the area of a polygon. It has the following
syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let poly = polygon!(
    exterior: [
        (x: -111., y: 45.),
        (x: -111., y: 41.),
        (x: -104., y: 41.),
        (x: -104., y: 45.),
    ],
    interiors: [
        [
            (x: -110., y: 44.),
            (x: -110., y: 42.),
            (x: -105., y: 42.),
            (x: -105., y: 44.),
        ],
    ],
);
let result = geo::area!(poly);
<span class="boring">}</span></code></pre></pre>
<p>The <code>geo::area!()</code> macro generates the following SQL query:</p>
<pre><code class="language-plaintext">geo::area({ type: 'Polygon', coordinates: [[[-111, 45], [-111, 41], [-104, 41], [-104, 45], [-111, 45]], [[[-110, 44], [-110, 42], [-105, 42], [-105, 44], [-110, 44]]]] })
</code></pre>
<h2 id="geobearing"><a class="header" href="#geobearing"><a name="geo-bearing-macro"></a>geo::bearing!()</a></h2>
<p>The <code>geo::bearing!()</code> macro calculates the bearing between two points. It has
the following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let point1 = point! {
    x: 40.02f64,
    y: 116.34,
};

let point2 = point! {
    x: 80.02f64,
    y: 103.19,
};
let result = geo::bearing!(point1, point2);
<span class="boring">}</span></code></pre></pre>
<p>The <code>geo::bearing!()</code> macro generates the following SQL query:</p>
<pre><code class="language-plaintext">geo::bearing((40.02, 116.34), (80.02, 103.19))
</code></pre>
<h2 id="geocentroid"><a class="header" href="#geocentroid"><a name="geo-centroid-macro"></a>geo::centroid!()</a></h2>
<p>The <code>geo::centroid!()</code> macro calculates the centroid of a polygon. It has the
following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let poly = polygon!(
    exterior: [
        (x: -111., y: 45.),
        (x: -111., y: 41.),
        (x: -104., y: 41.),
        (x: -104., y: 45.),
    ],
    interiors: [
        [
            (x: -110., y: 44.),
            (x: -110., y: 42.),
            (x: -105., y: 42.),
            (x: -105., y: 44.),
        ],
    ],
);
let result = geo::centroid!(poly);
<span class="boring">}</span></code></pre></pre>
<p>The <code>geo::centroid!()</code> macro generates the following SQL query:</p>
<pre><code class="language-plaintext">geo::centroid({ type: 'Polygon', coordinates: [[[-111, 45], [-111, 41], [-104, 41], [-104, 45], [-111, 45]], [[[-110, 44], [-110, 42], [-105, 42], [-105, 44], [-110, 44]]]] })
</code></pre>
<h2 id="geodistance"><a class="header" href="#geodistance"><a name="geo-distance-macro"></a>geo::distance!()</a></h2>
<p>The <code>geo::distance!()</code> macro calculates the distance between two points. It has
the following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let point1 = point! {
    x: 40.02f64,
    y: 116.34,
};

let point2 = point! {
    x: 80.02f64,
    y: 103.19,
};
let result = geo::distance!(point1, point2);
<span class="boring">}</span></code></pre></pre>
<p>The <code>geo::distance!()</code> macro generates the following SQL query:</p>
<pre><code class="language-plaintext">geo::distance((40.02, 116.34), (80.02, 103.19))
</code></pre>
<h2 id="geohashdecode"><a class="header" href="#geohashdecode"><a name="geo-hash-decode-macro"></a>geo::hash::decode!()</a></h2>
<p>The <code>geo::hash::decode!()</code> macro decodes a geohash string. It has the following
syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = geo::hash::decode!("mpuxk4s24f51");
<span class="boring">}</span></code></pre></pre>
<p>The <code>geo::hash::decode!()</code> macro generates the following SQL query:</p>
<pre><code class="language-plaintext">geo::hash::decode('mpuxk4s24f51')
</code></pre>
<h2 id="geohashencode"><a class="header" href="#geohashencode"><a name="geo-hash-encode-macro"></a>geo::hash::encode!()</a></h2>
<p>The <code>geo::hash::encode!()</code> macro encodes a point or polygon into a geohash
string. It has the following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let point = point! {
    x: 40.02f64,
    y: 116.34,
};

let result = geo::hash::encode!(point, 5);
<span class="boring">}</span></code></pre></pre>
<p>The <code>geo::hash::encode!()</code> macro generates the following SQL query:</p>
<pre><code class="language-plaintext">geo::hash::encode((40.02, 116.34), 5)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-functions"><a class="header" href="#http-functions">HTTP Functions</a></h1>
<p>This chapter introduces the http macros provided by the Surreal ORM. The http
macros are used for performing remote HTTP requests such as HEAD, GET, POST,
PUT, and PATCH.</p>
<h2 id="table-of-contents-38"><a class="header" href="#table-of-contents-38">Table of Contents</a></h2>
<ul>
<li><a href="functions/http.html#http-head-macro">http::head!()</a></li>
<li><a href="functions/http.html#http-get-macro">http::get!()</a></li>
<li><a href="functions/http.html#http-delete-macro">http::delete!()</a></li>
<li><a href="functions/http.html#http-post-macro">http::post!()</a></li>
<li><a href="functions/http.html#http-put-macro">http::put!()</a></li>
<li><a href="functions/http.html#http-patch-macro">http::patch!()</a></li>
</ul>
<h2 id="httphead"><a class="header" href="#httphead"><a name="http-head-macro"></a>http::head!()</a></h2>
<p>The <code>http::head!()</code> macro performs a remote HTTP HEAD request. It has the
following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>http::head!("https://codebreather.com");
<span class="boring">}</span></code></pre></pre>
<p>The <code>http::head!()</code> macro generates the following function call:</p>
<pre><code class="language-plaintext">http::head("https://codebreather.com", None as Option&lt;ObjectLike&gt;)
</code></pre>
<h2 id="httpget"><a class="header" href="#httpget"><a name="http-get-macro"></a>http::get!()</a></h2>
<p>The <code>http::get!()</code> macro performs a remote HTTP GET request. It has the
following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>http::get!("https://codebreather.com");
<span class="boring">}</span></code></pre></pre>
<p>The <code>http::get!()</code> macro generates the following function call:</p>
<pre><code class="language-plaintext">http::get("https://codebreather.com", None as Option&lt;ObjectLike&gt;)
</code></pre>
<h2 id="httpdelete"><a class="header" href="#httpdelete"><a name="http-delete-macro"></a>http::delete!()</a></h2>
<p>The <code>http::delete!()</code> macro performs a remote HTTP DELETE request. It has the
following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>http::delete!("https://codebreather.com");
<span class="boring">}</span></code></pre></pre>
<p>The <code>http::delete!()</code> macro generates the following function call:</p>
<pre><code class="language-plaintext">http::delete("https://codebreather.com", None as Option&lt;ObjectLike&gt;)
</code></pre>
<h2 id="httppost"><a class="header" href="#httppost"><a name="http-post-macro"></a>http::post!()</a></h2>
<p>The <code>http::post!()</code> macro performs a remote HTTP POST request. It has the
following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>http::post!("https://codebreather.com", body);
<span class="boring">}</span></code></pre></pre>
<p>The <code>http::post!()</code> macro generates the following function call:</p>
<pre><code class="language-plaintext">http::post("https://codebreather.com", body, None as Option&lt;ObjectLike&gt;)
</code></pre>
<h2 id="httpput"><a class="header" href="#httpput"><a name="http-put-macro"></a>http::put!()</a></h2>
<p>The <code>http::put!()</code> macro performs a remote HTTP PUT request. It has the
following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>http::put!("https://codebreather.com", body);
<span class="boring">}</span></code></pre></pre>
<p>The <code>http::put!()</code> macro generates the following function call:</p>
<pre><code class="language-plaintext">http::put("https://codebreather.com", body, None as Option&lt;ObjectLike&gt;)
</code></pre>
<h2 id="httppatch"><a class="header" href="#httppatch"><a name="http-patch-macro"></a>http::patch!()</a></h2>
<p>The <code>http::patch!()</code> macro performs a remote HTTP PATCH request. It has the
following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>http::patch!("https://codebreather.com", body);
<span class="boring">}</span></code></pre></pre>
<p>The <code>http::patch!()</code> macro generates the following function call:</p>
<pre><code class="language-plaintext">http::patch("https://codebreather.com", body, None as Option&lt;ObjectLike&gt;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validation-functions"><a class="header" href="#validation-functions">Validation Functions</a></h1>
<p>This documentation provides an overview of the validation functions in the codebase. The <code>is</code> macros are used to create validation functions for checking various conditions on values.</p>
<h2 id="table-of-contents-39"><a class="header" href="#table-of-contents-39">Table of Contents</a></h2>
<ul>
<li><a href="functions/validation.html#alphanum">Alphanum</a></li>
<li><a href="functions/validation.html#alpha">Alpha</a></li>
<li><a href="functions/validation.html#ascii">ASCII</a></li>
<li><a href="functions/validation.html#domain">Domain</a></li>
<li><a href="functions/validation.html#email">Email</a></li>
<li><a href="functions/validation.html#hexadecimal">Hexadecimal</a></li>
<li><a href="functions/validation.html#latitude">Latitude</a></li>
<li><a href="functions/validation.html#longitude">Longitude</a></li>
<li><a href="functions/validation.html#numeric">Numeric</a></li>
<li><a href="functions/validation.html#semver">Semver</a></li>
<li><a href="functions/validation.html#uuid">UUID</a></li>
<li><a href="functions/validation.html#datetime">Datetime</a></li>
</ul>
<h2 id="alphanum"><a class="header" href="#alphanum">Alphanum</a></h2>
<p>The <code>is::alphanum</code> function checks whether a value has only alphanumeric characters. It is also aliased as <code>is_alphanum!</code>.</p>
<h3 id="arguments"><a class="header" href="#arguments">Arguments</a></h3>
<ul>
<li><code>value</code> - The value to check. It could be a field or a parameter that represents the value.</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::is, statements::let_};

let result = is::alphanum!("oyelowo1234");
assert_eq!(result.to_raw().build(), "is::alphanum('oyelowo1234')");

let alphanum_field = Field::new("alphanum_field");
let result = is::alphanum!(alphanum_field);
assert_eq!(result.to_raw().build(), "is::alphanum(alphanum_field)");

block!{
    LET alphanum_param = "oyelowo1234";
    LET result = is::alphanum!(alphanum_param);
};
<span class="boring">}</span></code></pre></pre>
<h2 id="alpha"><a class="header" href="#alpha">Alpha</a></h2>
<p>The <code>is::alpha</code> function checks whether a value has only alpha characters. It is also aliased as <code>is_alpha!</code>.</p>
<h3 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h3>
<ul>
<li><code>value</code> - The value to check. It could be a field or a parameter that represents the value.</li>
</ul>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::is, statements::let_};

let result = is::alpha!("oyelowo");
assert_eq!(result.to_raw().build(), "is::alpha('oyelowo')");

let alpha_field = Field::new("alpha_field");
let result = is::alpha!(alpha_field);
assert_eq!(result.to_raw().build(), "is::alpha(alpha_field)");
<span class="boring">}</span></code></pre></pre>
<h2 id="ascii"><a class="header" href="#ascii">ASCII</a></h2>
<p>The <code>is::ascii</code> function checks whether a value has only ASCII characters. It is also aliased as <code>is_ascii!</code>.</p>
<h3 id="arguments-2"><a class="header" href="#arguments-2">Arguments</a></h3>
<ul>
<li><code>value</code> - The value to check. It could be a field or a parameter that represents the value.</li>
</ul>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::is, statements::let_};

let result = is::ascii!("oyelowo");
assert_eq!(result.to_raw().build(), "is::ascii('oyelowo')");

let ascii_field = Field::new("ascii_field");
let result = is::ascii!(ascii_field);
assert_eq!(result.to_raw().build(), "is::ascii(ascii_field)");
<span class="boring">}</span></code></pre></pre>
<h2 id="domain"><a class="header" href="#domain">Domain</a></h2>
<p>The <code>is::domain</code> function checks whether a value is a domain. It is also aliased as <code>is_domain!</code>.</p>
<h3 id="arguments-3"><a class="header" href="#arguments-3">Arguments</a></h3>
<ul>
<li><code>value</code> - The value to check. It could be a field or a parameter that represents the value.</li>
</ul>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::is, statements::let_};

let result = is::domain!("oyelowo.com");
assert_eq!(result.to_raw().build(), "is::domain('oyelowo.com')");

let domain_field = Field::new("domain_field");
let result = is::domain!(domain_field);
assert_eq!(result.to_raw().build(), "is::domain(domain_field)");
<span class="boring">}</span></code></pre></pre>
<h2 id="email"><a class="header" href="#email">Email</a></h2>
<p>The <code>is::email</code> function checks whether a value is an email. It is also aliased as <code>is_email!</code>.</p>
<h3 id="arguments-4"><a class="header" href="#arguments-4">Arguments</a></h3>
<ul>
<li><code>value</code> - The value to check. It could be a field or a parameter that represents the value.</li>
</ul>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::is, statements::let_};

let result = is::email!("oyelowo@codebreather.com");
assert_eq!(result.to_raw().to_string(), "is::email('oyelowo@codebreather.com')");

let email_field = Field::new("email_field");
let result = is::email!(email_field);
assert_eq!(result.to_raw().to_string(), "is::email(email_field)");
<span class="boring">}</span></code></pre></pre>
<h2 id="hexadecimal"><a class="header" href="#hexadecimal">Hexadecimal</a></h2>
<p>The <code>is::hexadecimal</code> function checks whether a value is hexadecimal. It is also aliased as <code>is_hexadecimal!</code>.</p>
<h3 id="arguments-5"><a class="header" href="#arguments-5">Arguments</a></h3>
<ul>
<li><code>value</code> - The value to check. It could be a field or a parameter that represents the value.</li>
</ul>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::is, statements::let_};

let result = is::hexadecimal!("oyelowo");
assert_eq!(result.to_raw().to_string(), "is::hexadecimal('oyelowo')");

let hexadecimal_field = Field::new("hexadecimal_field");
let result = is::hexadecimal!(hexadecimal_field);
assert_eq!(result.to_raw().to_string(), "is::hexadecimal(hexadecimal_field)");

let!(hexadecimal_param = "oyelowo");
let result = is::hexadecimal!(hexadecimal_param);
assert_eq!(result.fine_tune_params(), "is::hexadecimal($hexadecimal_param)");
<span class="boring">}</span></code></pre></pre>
<h2 id="latitude"><a class="header" href="#latitude">Latitude</a></h2>
<p>The <code>is::latitude</code> function checks whether a value is a latitude value. It is also aliased as <code>is_latitude!</code>.</p>
<h3 id="arguments-6"><a class="header" href="#arguments-6">Arguments</a></h3>
<ul>
<li><code>value</code> - The value to check. It could be a field or a parameter that represents the value.</li>
</ul>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::is, statements::let_};

let result = is::latitude!("-0.118092");
assert_eq!(result.to_raw().build(), "is::latitude('-0.118092')");

let latitude_field = Field::new("latitude_field");
let result = is::latitude!(latitude_field);
assert_eq!(

result.to_raw().build(), "is::latitude(latitude_field)");
<span class="boring">}</span></code></pre></pre>
<h2 id="longitude"><a class="header" href="#longitude">Longitude</a></h2>
<p>The <code>is::longitude</code> function checks whether a value is a longitude value. It is also aliased as <code>is_longitude!</code>.</p>
<h3 id="arguments-7"><a class="header" href="#arguments-7">Arguments</a></h3>
<ul>
<li><code>value</code> - The value to check. It could be a field or a parameter that represents the value.</li>
</ul>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::is, statements::let_};

let result = is::longitude!("51.509865");
assert_eq!(result.to_raw().build(), "is::longitude('51.509865')");

let longitude_field = Field::new("longitude_field");
let result = is::longitude!(longitude_field);
assert_eq!(result.to_raw().build(), "is::longitude(longitude_field)");
<span class="boring">}</span></code></pre></pre>
<h2 id="numeric"><a class="header" href="#numeric">Numeric</a></h2>
<p>The <code>is::numeric</code> function checks whether a value has only numeric characters. It is also aliased as <code>is_numeric!</code>.</p>
<h3 id="arguments-8"><a class="header" href="#arguments-8">Arguments</a></h3>
<ul>
<li><code>value</code> - The value to check. It could be a field or a parameter that represents the value.</li>
</ul>
<h3 id="example-8"><a class="header" href="#example-8">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::is, statements::let_};

let result = is::numeric!("oyelowo");
assert_eq!(result.to_raw().build(), "is::numeric('oyelowo')");

let numeric_field = Field::new("numeric_field");
let result = is::numeric!(numeric_field);
assert_eq!(result.to_raw().build(), "is::numeric(numeric_field)");
<span class="boring">}</span></code></pre></pre>
<h2 id="semver"><a class="header" href="#semver">Semver</a></h2>
<p>The <code>is::semver</code> function checks whether a value matches a semver version. It is also aliased as <code>is_semver!</code>.</p>
<h3 id="arguments-9"><a class="header" href="#arguments-9">Arguments</a></h3>
<ul>
<li><code>value</code> - The value to check. It could be a field or a parameter that represents the value.</li>
</ul>
<h3 id="example-9"><a class="header" href="#example-9">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::is, statements::let_};

let result = is::semver!("oyelowo");
assert_eq!(result.to_raw().build(), "is::semver('oyelowo')");

let semver_field = Field::new("semver_field");
let result = is::semver!(semver_field);
assert_eq!(result.to_raw().build(), "is::semver(semver_field)");
<span class="boring">}</span></code></pre></pre>
<h2 id="uuid"><a class="header" href="#uuid">UUID</a></h2>
<p>The <code>is::uuid</code> function checks whether a value is a UUID. It is also aliased as <code>is_uuid!</code>.</p>
<h3 id="arguments-10"><a class="header" href="#arguments-10">Arguments</a></h3>
<ul>
<li><code>value</code> - The value to check. It could be a field or a parameter that represents the value.</li>
</ul>
<h3 id="example-10"><a class="header" href="#example-10">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::is, statements::let_};

let result = is::uuid!("oyelowo");
assert_eq!(result.to_raw().build(), "

is::uuid('oyelowo')");

let uuid_field = Field::new("uuid_field");
let result = is::uuid!(uuid_field);
assert_eq!(result.to_raw().build(), "is::uuid(uuid_field)");
<span class="boring">}</span></code></pre></pre>
<h2 id="datetime"><a class="header" href="#datetime">Datetime</a></h2>
<p>The <code>is::datetime</code> function checks whether a value matches a datetime format. It is also aliased as <code>is_datetime!</code>.</p>
<h3 id="arguments-11"><a class="header" href="#arguments-11">Arguments</a></h3>
<ul>
<li><code>value</code> - The value to check. It could be a field or a parameter that represents the value.</li>
</ul>
<h3 id="example-11"><a class="header" href="#example-11">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::is, statements::let_};

let result = is::datetime!("oyelowo");
assert_eq!(result.to_raw().build(), "is::datetime('oyelowo')");

let datetime_field = Field::new("datetime_field");
let result = is::datetime!(datetime_field);
assert_eq!(result.to_raw().build(), "is::datetime(datetime_field)");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="math-functions"><a class="header" href="#math-functions">Math Functions</a></h1>
<h2 id="table-of-contents-40"><a class="header" href="#table-of-contents-40">Table of Contents</a></h2>
<ul>
<li><a href="functions/math.html#math-abs-macro">math::abs!()</a></li>
<li><a href="functions/math.html#math-ceil-macro">math::ceil!()</a></li>
<li><a href="functions/math.html#math-floor-macro">math::floor!()</a></li>
<li><a href="functions/math.html#math-round-macro">math::round!()</a></li>
<li><a href="functions/math.html#math-sqrt-macro">math::sqrt!()</a></li>
<li><a href="functions/math.html#math-mean-macro">math::mean!()</a></li>
<li><a href="functions/math.html#math-median-macro">math::median!()</a></li>
<li><a href="functions/math.html#math-mode-macro">math::mode!()</a></li>
<li><a href="functions/math.html#math-min-macro">math::min!()</a></li>
<li><a href="functions/math.html#math-product-macro">math::product!()</a></li>
<li><a href="functions/math.html#math-sum-macro">math::sum!()</a></li>
</ul>
<hr />
<h2 id="mathabs"><a class="header" href="#mathabs">math::abs!() <a name="math-abs-macro"></a></a></h2>
<p>The math::abs function returns the absolute value of a number.</p>
<p>Function signature: <code>math::abs(number) -&gt; number</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>math::abs!(45.23);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="mathceil"><a class="header" href="#mathceil">math::ceil!() <a name="math-ceil-macro"></a></a></h2>
<p>The math::ceil function rounds a number up to the next largest integer.</p>
<p>Function signature: <code>math::ceil(number) -&gt; number</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>math::ceil!(45.23);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="mathfloor"><a class="header" href="#mathfloor">math::floor!() <a name="math-floor-macro"></a></a></h2>
<p>The math::floor function rounds a number down to the next largest integer.</p>
<p>Function signature: <code>math::floor(number) -&gt; number</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>math::floor!(45.23);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="mathround"><a class="header" href="#mathround">math::round!() <a name="math-round-macro"></a></a></h2>
<p>The math::round function rounds a number up or down to the nearest integer.</p>
<p>Function signature: <code>math::round(number) -&gt; number</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>math::round!(45.23);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="mathsqrt"><a class="header" href="#mathsqrt">math::sqrt!() <a name="math-sqrt-macro"></a></a></h2>
<p>The math::sqrt function returns the square root of a number.</p>
<p>Function signature: <code>math::sqrt(number) -&gt; number</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>math::sqrt!(45.23);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="mathmean"><a class="header" href="#mathmean">math::mean!() <a name="math-mean-macro"></a></a></h2>
<p>The math::mean function returns the average of a set of numbers.</p>
<p>Function signature: <code>math::mean(array) -&gt; number</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>math::mean!(vec![1, 2, 3, 4, 5]);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="mathmedian"><a class="header" href="#mathmedian">math::median!() <a name="math-median-macro"></a></a></h2>
<p>The math::median function returns the median of a set of numbers.</p>
<p>Function signature: <code>math::median(array) -&gt; number</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>math::median!(vec![1, 2, 3, 4, 5]);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="mathmode"><a class="header" href="#mathmode">math::mode!() <a name="math-mode-macro"></a></a></h2>
<p>The math::mode function returns the mode of a set of numbers.</p>
<p>Function signature: <code>math::mode(array) -&gt; number</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>math::mode!(vec![1, 2, 3, 4, 5]);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="mathmin"><a class="header" href="#mathmin">math::min!() <a name="math-min-macro"></a></a></h2>
<p>The math::min function returns the minimum number in a set of numbers.</p>
<p>Function signature: <code>math::min(array) -&gt; number</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>math::min!(vec![1, 2, 3, 4, 5]);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="mathproduct"><a class="header" href="#mathproduct">math::product!() <a name="math-product-macro"></a></a></h2>
<p>The math::product function returns the product of a set of numbers.</p>
<p>Function signature: <code>math::product(array) -&gt; number</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>math::product!(vec![1, 2, 3, 4, 5]);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="mathsum"><a class="header" href="#mathsum">math::sum!() <a name="math-sum-macro"></a></a></h2>
<p>The math::sum function returns the total sum of a set of numbers.</p>
<p>Function signature: <code>math::sum(array) -&gt; number</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>math::sum!(vec![1, 2, 3, 4, 5]);
<span class="boring">}</span></code></pre></pre>
<hr />
<p>That concludes the documentation for the math macros.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="meta-functions"><a class="header" href="#meta-functions">Meta functions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parse-functions"><a class="header" href="#parse-functions">Parse Functions</a></h1>
<h2 id="table-of-contents-41"><a class="header" href="#table-of-contents-41">Table of Contents</a></h2>
<ul>
<li><a href="functions/parse.html#parse-email-host-macro">parse::email::host()</a></li>
<li><a href="functions/parse.html#parse-email-user-macro">parse::email::user()</a></li>
<li><a href="functions/parse.html#parse-url-domain-macro">parse::url::domain()</a></li>
<li><a href="functions/parse.html#parse-url-fragment-macro">parse::url::fragment()</a></li>
<li><a href="functions/parse.html#parse-url-host-macro">parse::url::host()</a></li>
<li><a href="functions/parse.html#parse-url-path-macro">parse::url::path()</a></li>
<li><a href="functions/parse.html#parse-url-port-macro">parse::url::port()</a></li>
<li><a href="functions/parse.html#parse-url-query-macro">parse::url::query()</a></li>
</ul>
<hr />
<h2 id="parseemailhost"><a class="header" href="#parseemailhost">parse::email::host() <a name="parse-email-host-macro"></a></a></h2>
<p>The <code>parse::email::host</code> function parses and returns the email host from a valid email address. This function is also aliased as <code>parse_email_host!</code>.</p>
<p>Function signature: <code>parse::email::host(string) -&gt; value</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parse::email::host!("oyelowo@codebreather.com");
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="parseemailuser"><a class="header" href="#parseemailuser">parse::email::user() <a name="parse-email-user-macro"></a></a></h2>
<p>The <code>parse::email::user</code> function parses and returns the email username from a valid email address. This function is also aliased as <code>parse_email_user!</code>.</p>
<p>Function signature: <code>parse::email::user(string) -&gt; value</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parse::email::user!("oyelowo@codebreather.com");
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="parseurldomain"><a class="header" href="#parseurldomain">parse::url::domain() <a name="parse-url-domain-macro"></a></a></h2>
<p>The <code>parse::url::domain</code> function parses and returns the domain from a valid URL. This function is also aliased as <code>parse_url_domain!</code>.</p>
<p>Function signature: <code>parse::url::domain(string) -&gt; value</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parse::url::domain!("https://codebreather.com:443/topics?arg=value#fragment");
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="parseurlfragment"><a class="header" href="#parseurlfragment">parse::url::fragment() <a name="parse-url-fragment-macro"></a></a></h2>
<p>The <code>parse::url::fragment</code> function parses and returns the fragment from a valid URL. This function is also aliased as <code>parse_url_fragment!</code>.</p>
<p>Function signature: <code>parse::url::fragment(string) -&gt; value</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parse::url::fragment!("https://codebreather.com:443/topics?arg=value#fragment");
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="parseurlhost"><a class="header" href="#parseurlhost">parse::url::host() <a name="parse-url-host-macro"></a></a></h2>
<p>The <code>parse::url::host</code> function parses and returns the hostname from a valid URL. This function is also aliased as <code>parse_url_host!</code>.</p>
<p>Function signature: <code>parse::url::host(string) -&gt; value</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parse::url::host!("https://codebreather.com:443/topics?arg=value#fragment");
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="parseurlpath"><a class="header" href="#parseurlpath">parse::url::path() <a name="parse-url-path-macro"></a></a></h2>
<p>The <code>parse::url::path</code> function parses and returns the path from a valid URL. This function is also aliased as <code>parse_url_path!</code>.</p>
<p>Function signature: <code>parse::url::path(string) -&gt; value</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parse::url::path!("https://codebreather.com:443/topics?arg=value#fragment");
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="parseurlport"><a class="header" href="#parseurlport">parse::url::port() <a name="parse-url-port-macro"></a></a></h2>
<p>The <code>parse::url::port</code> function parses and returns the port from a valid URL. This function is also aliased as <code>parse_url_port!</code>.</p>
<p>Function signature: `parse::url</p>
<p>::port(string) -&gt; value`</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parse::url::port!("https://codebreather.com:443/topics?arg=value#fragment");
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="parseurlquery"><a class="header" href="#parseurlquery">parse::url::query() <a name="parse-url-query-macro"></a></a></h2>
<p>The <code>parse::url::query</code> function parses and returns the query from a valid URL. This function is also aliased as <code>parse_url_query!</code>.</p>
<p>Function signature: <code>parse::url::query(string) -&gt; value</code></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parse::url::query!("https://codebreather.com:443/topics?arg=value#fragment");
<span class="boring">}</span></code></pre></pre>
<hr />
<p>That concludes the documentation for the parse macros.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rand-functions"><a class="header" href="#rand-functions">Rand Functions</a></h1>
<h2 id="table-of-contents-42"><a class="header" href="#table-of-contents-42">Table of Contents</a></h2>
<ul>
<li><a href="functions/rand.html#rand-macro">rand!()</a></li>
<li><a href="functions/rand.html#bool-macro">rand::bool!()</a></li>
<li><a href="functions/rand.html#uuid-macro">rand::uuid!()</a></li>
<li><a href="functions/rand.html#uuid-v4-macro">rand::uuid::v4!()</a></li>
<li><a href="functions/rand.html#uuid-v7-macro">rand::uuid::v7!()</a></li>
<li><a href="functions/rand.html#enum-macro">rand::enum!()</a></li>
<li><a href="functions/rand.html#string-macro">rand::string!()</a></li>
<li><a href="functions/rand.html#guid-macro">rand::guid!()</a></li>
<li><a href="functions/rand.html#float-macro">rand::float!()</a></li>
<li><a href="functions/rand.html#int-macro">rand::int!()</a></li>
<li><a href="functions/rand.html#time-macro">rand::time!()</a></li>
</ul>
<h2 id="rand"><a class="header" href="#rand">rand!() <a name="rand-macro"></a></a></h2>
<p>The <code>rand!()</code> macro generates a random number.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::rand;

let result = rand!();
<span class="boring">}</span></code></pre></pre>
<h2 id="randbool"><a class="header" href="#randbool">rand::bool!() <a name="bool-macro"></a></a></h2>
<p>The <code>rand::bool!()</code> macro generates a random boolean value.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::rand;

let result = rand::bool!();
<span class="boring">}</span></code></pre></pre>
<h2 id="randuuid"><a class="header" href="#randuuid">rand::uuid!() <a name="uuid-macro"></a></a></h2>
<p>The <code>rand::uuid!()</code> macro generates a random UUID.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::rand;

let result = rand::uuid!();
<span class="boring">}</span></code></pre></pre>
<h2 id="randuuidv4"><a class="header" href="#randuuidv4">rand::uuid::v4!() <a name="uuid-v4-macro"></a></a></h2>
<p>The <code>rand::uuid::v4!()</code> macro generates a random UUID v4.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::rand;

let result = rand::uuid::v4!();
<span class="boring">}</span></code></pre></pre>
<h2 id="randuuidv7"><a class="header" href="#randuuidv7">rand::uuid::v7!() <a name="uuid-v7-macro"></a></a></h2>
<p>The <code>rand::uuid::v7!()</code> macro generates a random UUID v7.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::rand;

let result = rand::uuid::v7!();
<span class="boring">}</span></code></pre></pre>
<h2 id="randenum"><a class="header" href="#randenum">rand::enum!() <a name="enum-macro"></a></a></h2>
<p>The <code>rand::enum!()</code> macro generates a random value from a list of options.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::rand;
use surreal_orm::functions::rand::arr;

let result = rand::enum!(arr!["one", "two", 3, 4.15385, "five", true]);
<span class="boring">}</span></code></pre></pre>
<h2 id="randstring"><a class="header" href="#randstring">rand::string!() <a name="string-macro"></a></a></h2>
<p>The <code>rand::string!()</code> macro generates a random string.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::rand;

let result = rand::string!();
<span class="boring">}</span></code></pre></pre>
<h2 id="randguid"><a class="header" href="#randguid">rand::guid!() <a name="guid-macro"></a></a></h2>
<p>The <code>rand::guid!()</code> macro generates a random GUID.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::rand;

let result = rand::guid!();
<span class="boring">}</span></code></pre></pre>
<h2 id="randfloat"><a class="header" href="#randfloat">rand::float!() <a name="float-macro"></a></a></h2>
<p>The <code>rand::float!()</code> macro generates a random floating-point number.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::rand;

let result = rand::float!();
<span class="boring">}</span></code></pre></pre>
<h2 id="randint"><a class="header" href="#randint">rand::int!() <a name="int-macro"></a></a></h2>
<p>The <code>rand::int!()</code> macro generates a random integer.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::rand;

let result = rand::int!();
<span class="boring">}</span></code></pre></pre>
<h2 id="randtime"><a class="header" href="#randtime">rand::time!() <a name="time-macro"></a></a></h2>
<p>The <code>rand::time!()</code> macro generates a random time value.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::rand;

let result = rand::time!();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="session-functions"><a class="header" href="#session-functions">Session functions</a></h1>
<h2 id="table-of-contents-43"><a class="header" href="#table-of-contents-43">Table of Contents</a></h2>
<ul>
<li><a href="functions/session.html#db-macro">session::db!()</a></li>
<li><a href="functions/session.html#id-macro">session::id!()</a></li>
<li><a href="functions/session.html#ip-macro">session::ip!()</a></li>
<li><a href="functions/session.html#ns-macro">session::ns!()</a></li>
<li><a href="functions/session.html#origin-macro">session::origin!()</a></li>
<li><a href="functions/session.html#sc-macro">session::sc!()</a></li>
</ul>
<h2 id="sessiondb"><a class="header" href="#sessiondb">session::db!() <a name="db-macro"></a></a></h2>
<p>The <code>session::db!()</code> macro returns the currently selected database.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::session;

session::db!();
<span class="boring">}</span></code></pre></pre>
<h2 id="sessionid"><a class="header" href="#sessionid">session::id!() <a name="id-macro"></a></a></h2>
<p>The <code>session::id!()</code> macro returns the current user's session ID.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::session;

session::id!();
<span class="boring">}</span></code></pre></pre>
<h2 id="sessionip"><a class="header" href="#sessionip">session::ip!() <a name="ip-macro"></a></a></h2>
<p>The <code>session::ip!()</code> macro returns the current user's session IP address.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::session;

session::ip!();
<span class="boring">}</span></code></pre></pre>
<h2 id="sessionns"><a class="header" href="#sessionns">session::ns!() <a name="ns-macro"></a></a></h2>
<p>The <code>session::ns!()</code> macro returns the currently selected namespace.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::session;

session::ns!();
<span class="boring">}</span></code></pre></pre>
<h2 id="sessionorigin"><a class="header" href="#sessionorigin">session::origin!() <a name="origin-macro"></a></a></h2>
<p>The <code>session::origin!()</code> macro returns the current user's HTTP origin.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::session;

session::origin!();
<span class="boring">}</span></code></pre></pre>
<h2 id="sessionsc"><a class="header" href="#sessionsc">session::sc!() <a name="sc-macro"></a></a></h2>
<p>The <code>session::sc!()</code> macro returns the current user's authentication scope.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::functions::session;

session::sc!();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sleep-function"><a class="header" href="#sleep-function">Sleep function</a></h1>
<h2 id="table-of-contents-44"><a class="header" href="#table-of-contents-44">Table of Contents</a></h2>
<ul>
<li><a href="functions/sleep.html#sleep-macro">sleep!()</a></li>
</ul>
<h2 id="sleep"><a class="header" href="#sleep">sleep!() <a name="sleep-macro"></a></a></h2>
<p>The <code>sleep!()</code> macro suspends the current thread for the specified duration.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time;
use surreal_orm::functions::sleep;

let result = sleep!(time::Duration::from_secs(55));
assert_eq!(result.to_raw().build(), "sleep(55s)");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-functions"><a class="header" href="#string-functions">String functions</a></h1>
<h2 id="table-of-contents-45"><a class="header" href="#table-of-contents-45">Table of Contents</a></h2>
<ul>
<li><a href="functions/string.html#concat-macro">string::concat!()</a></li>
<li><a href="functions/string.html#join-macro">string::join!()</a></li>
<li><a href="functions/string.html#ends-with-macro">string::ends_with!()</a></li>
<li><a href="functions/string.html#starts-with-macro">string::starts_with!()</a></li>
<li><a href="functions/string.html#split-macro">string::split!()</a></li>
<li><a href="functions/string.html#length-macro">string::len!()</a></li>
<li><a href="functions/string.html#reverse-macro">string::reverse!()</a></li>
<li><a href="functions/string.html#trim-macro">string::trim!()</a></li>
<li><a href="functions/string.html#slug-macro">string::slug!()</a></li>
<li><a href="functions/string.html#lowercase-macro">string::lowercase!()</a></li>
<li><a href="functions/string.html#uppercase-macro">string::uppercase!()</a></li>
<li><a href="functions/string.html#words-macro">string::words!()</a></li>
<li><a href="functions/string.html#repeat-macro">string::repeat!()</a></li>
<li><a href="functions/string.html#replace-macro">string::replace!()</a></li>
<li><a href="functions/string.html#slice-macro">string::slice!()</a></li>
</ul>
<h2 id="stringconcat"><a class="header" href="#stringconcat">string::concat!() <a name="concat-macro"></a></a></h2>
<p>The <code>string::concat!()</code> macro allows you to concatenate multiple values into a string.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let title = Field::new("title");
let result = string::concat!(title, "one", 3, 4.15385, "  ", true);
assert_eq!(result.fine_tune_params(), "string::concat(title, $_param_00000001, $_param_00000002, $_param_00000003, $_param_00000004, $_param_00000005)");
assert_eq!(
    result.to_raw().build(),
    "string::concat(title, 'one', 3, 4.15385, '  ', true)"
);

let result = string::concat!(arr!["one", "two", 3, 4.15385, "five", true]);
assert_eq!(result.fine_tune_params(), "string::concat($_param_00000001, $_param_00000002, $_param_00000003, $_param_00000004, $_param_00000005, $_param_00000006)");
assert_eq!(
    result.to_raw().build(),
    "string::concat('one', 'two', 3, 4.15385, 'five', true)"
);
<span class="boring">}</span></code></pre></pre>
<h2 id="stringjoin"><a class="header" href="#stringjoin">string::join!() <a name="join-macro"></a></a></h2>
<p>The <code>string::join!()</code> macro allows you to join multiple values into a string using a delimiter.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let title = Field::new("title");
let result = string::join!(title, "one", 3, 4.15385, "  ", true);
assert_eq!(result.fine_tune_params(), "string::join(title, $_param_00000001, $_param_00000002, $_param_00000003, $_param_00000004, $_param_00000005)");
assert_eq!(
    result.to_raw().build(),
    "string::join(title, 'one', 3, 4.15385, '  ', true)"
);

let result = string::join!(arr!["one", "two", 3, 4.15385, "five", true]);
assert_eq!(result.fine_tune_params(), "string::join($_param_00000001, $_param_00000002, $_param_00000003, $_param_00000004

, $_param_00000005, $_param_00000006)");
assert_eq!(
    result.to_raw().build(),
    "string::join('one', 'two', 3, 4.15385, 'five', true)"
);
<span class="boring">}</span></code></pre></pre>
<h2 id="stringends_with"><a class="header" href="#stringends_with">string::ends_with!() <a name="ends-with-macro"></a></a></h2>
<p>The <code>string::ends_with!()</code> macro allows you to check if a string ends with a specified substring.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let name = Field::new("name");
let result = string::ends_with!(name, "lowo");
assert_eq!(
    result.fine_tune_params(),
    "string::ends_with(name, $_param_00000001)"
);
assert_eq!(result.to_raw().build(), "string::ends_with(name, 'lowo')");

let result = string::ends_with!("Oyelowo", "lowo");
assert_eq!(
    result.fine_tune_params(),
    "string::ends_with($_param_00000001, $_param_00000002)"
);
assert_eq!(
    result.to_raw().build(),
    "string::ends_with('Oyelowo', 'lowo')"
);
<span class="boring">}</span></code></pre></pre>
<h2 id="stringstarts_with"><a class="header" href="#stringstarts_with">string::starts_with!() <a name="starts-with-macro"></a></a></h2>
<p>The <code>string::starts_with!()</code> macro allows you to check if a string starts with a specified substring.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let name = Field::new("name");
let result = string::starts_with!(name, "lowo");
assert_eq!(
    result.fine_tune_params(),
    "string::starts_with(name, $_param_00000001)"
);
assert_eq!(result.to_raw().build(), "string::starts_with(name, 'lowo')");

let result = string::starts_with!("Oyelowo", "Oye");
assert_eq!(
    result.fine_tune_params(),
    "string::starts_with($_param_00000001, $_param_00000002)"
);
assert_eq!(
    result.to_raw().build(),
    "string::starts_with('Oyelowo', 'Oye')"
);
<span class="boring">}</span></code></pre></pre>
<h2 id="stringsplit"><a class="header" href="#stringsplit">string::split!() <a name="split-macro"></a></a></h2>
<p>The <code>string::split!()</code> macro allows you to split a string into multiple substrings based on a delimiter.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let phrase = Field::new("phrase");
let result = string::split!(phrase, ", ");
assert_eq!(
    result.fine_tune_params(),
    "string::split(phrase, $_param_00000001)"
);
assert_eq!(result.to_raw().build(), "string::split(phrase, ', ')");

let result = string::split!(
    "With great power, comes great responsibility",
    ", "
);
assert_eq!(
    result.fine_tune_params(),
    "string::split($_param_00000001, $_param_00000002)"
);
assert_eq!(
    result.to_raw().build(),
    "string::split('With great power, comes great responsibility', ', ')"
);
<span class="boring">}</span></code></pre></pre>
<h2 id="stringlen"><a class="header" href="#stringlen">string::len!() <a name="length-macro"></a></a></h2>
<p>The <code>string::len!()</code> macro allows you to get the length of a string.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let name = Field::new("name");
let result = string::len!(name);
assert_eq!(result.fine_tune_params(), "string::length(name)");
assert_eq!(result.to_raw().build(), "

string::length(name)");

let result = string::len!("toronto");
assert_eq!(
    result.fine_tune_params(),
    "string::length($_param_00000001)"
);
assert_eq!(result.to_raw().build(), "string::length('toronto')");
<span class="boring">}</span></code></pre></pre>
<h2 id="stringreverse"><a class="header" href="#stringreverse">string::reverse!() <a name="reverse-macro"></a></a></h2>
<p>The <code>string::reverse!()</code> macro allows you to reverse a string.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let name = Field::new("name");
let result = string::reverse!(name);
assert_eq!(result.fine_tune_params(), "string::reverse(name)");
assert_eq!(result.to_raw().build(), "string::reverse(name)");

let result = string::reverse!("oyelowo");
assert_eq!(
    result.fine_tune_params(),
    "string::reverse($_param_00000001)"
);
assert_eq!(result.to_raw().build(), "string::reverse('oyelowo')");
<span class="boring">}</span></code></pre></pre>
<h2 id="stringtrim"><a class="header" href="#stringtrim">string::trim!() <a name="trim-macro"></a></a></h2>
<p>The <code>string::trim!()</code> macro allows you to remove leading and trailing whitespace from a string.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let name = Field::new("name");
let result = string::trim!(name);
assert_eq!(result.fine_tune_params(), "string::trim(name)");
assert_eq!(result.to_raw().build(), "string::trim(name)");

let result = string::trim!("oyelowo");
assert_eq!(result.fine_tune_params(), "string::trim($_param_00000001)");
assert_eq!(result.to_raw().build(), "string::trim('oyelowo')");
<span class="boring">}</span></code></pre></pre>
<h2 id="stringslug"><a class="header" href="#stringslug">string::slug!() <a name="slug-macro"></a></a></h2>
<p>The <code>string::slug!()</code> macro allows you to convert a string into a slug.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let name = Field::new("name");
let result = string::slug!(name);
assert_eq!(result.fine_tune_params(), "string::slug(name)");
assert_eq!(result.to_raw().build(), "string::slug(name)");

let result = string::slug!("Codebreather is from #Jupiter");
assert_eq!(result.fine_tune_params(), "string::slug($_param_00000001)");
assert_eq!(
    result.to_raw().build(),
    "string::slug('Codebreather is from #Jupiter')"
);
<span class="boring">}</span></code></pre></pre>
<h2 id="stringlowercase"><a class="header" href="#stringlowercase">string::lowercase!() <a name="lowercase-macro"></a></a></h2>
<p>The <code>string::lowercase!()</code> macro allows you to convert a string to lowercase.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let name = Field::new("name");
let result = string::lowercase!(name);
assert_eq!(result.fine_tune_params(), "string::lowercase(name)");
assert_eq!(result.to_raw().build(), "string::lowercase(name)");

let result = string::lowercase!("OYELOWO");
assert_eq!(
    result.fine_tune_params(),
    "string::lowercase($_param_00000001)"
);
assert_eq!(result.to_raw().build(), "string::lowercase('OYELOWO')");
<span class="boring">}</span></code></pre></pre>
<h2 id="stringuppercase"><a class="header" href="#stringuppercase">string::uppercase!() <a name="uppercase-macro"></a></a></h2>
<p>The <code>string::uppercase!()</code> macro allows you to convert a string to uppercase.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let name = Field::new("name");
let result = string::uppercase!(name);
assert

_eq!(result.fine_tune_params(), "string::uppercase(name)");
assert_eq!(result.to_raw().build(), "string::uppercase(name)");

let result = string::uppercase!("oyelowo");
assert_eq!(
    result.fine_tune_params(),
    "string::uppercase($_param_00000001)"
);
assert_eq!(result.to_raw().build(), "string::uppercase('oyelowo')");
<span class="boring">}</span></code></pre></pre>
<h2 id="stringwords"><a class="header" href="#stringwords">string::words!() <a name="words-macro"></a></a></h2>
<p>The <code>string::words!()</code> macro allows you to split a string into individual words.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let sentence = Field::new("sentence");
let result = string::words!(sentence);
assert_eq!(result.fine_tune_params(), "string::words(sentence)");
assert_eq!(result.to_raw().build(), "string::words(sentence)");

let result = string::words!("The quick brown fox");
assert_eq!(
    result.fine_tune_params(),
    "string::words($_param_00000001)"
);
assert_eq!(result.to_raw().build(), "string::words('The quick brown fox')");
<span class="boring">}</span></code></pre></pre>
<h2 id="stringrepeat"><a class="header" href="#stringrepeat">string::repeat!() <a name="repeat-macro"></a></a></h2>
<p>The <code>string::repeat!()</code> macro allows you to repeat a string multiple times.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let word = Field::new("word");
let result = string::repeat!(word, 3);
assert_eq!(result.fine_tune_params(), "string::repeat(word, $_param_00000001)");
assert_eq!(result.to_raw().build(), "string::repeat(word, 3)");

let result = string::repeat!("hello", 5);
assert_eq!(result.fine_tune_params(), "string::repeat($_param_00000001, $_param_00000002)");
assert_eq!(result.to_raw().build(), "string::repeat('hello', 5)");
<span class="boring">}</span></code></pre></pre>
<h2 id="stringreplace"><a class="header" href="#stringreplace">string::replace!() <a name="replace-macro"></a></a></h2>
<p>The <code>string::replace!()</code> macro allows you to replace occurrences of a substring in a string with another substring.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let phrase = Field::new("phrase");
let result = string::replace!(phrase, "world", "Universe");
assert_eq!(
    result.fine_tune_params(),
    "string::replace(phrase, $_param_00000001, $_param_00000002)"
);
assert_eq!(
    result.to_raw().build(),
    "string::replace(phrase, 'world', 'Universe')"
);

let result = string::replace!("Hello, world!", "world", "Universe");
assert_eq!(
    result.fine_tune_params(),
    "string::replace($_param_00000001, $_param_00000002, $_param_00000003)"
);
assert_eq!(
    result.to_raw().build(),
    "string::replace('Hello, world!', 'world', 'Universe')"
);
<span class="boring">}</span></code></pre></pre>
<h2 id="stringslice"><a class="header" href="#stringslice">string::slice!() <a name="slice-macro"></a></a></h2>
<p>The <code>string::slice!()</code> macro allows you to extract a portion of a string.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let phrase = Field::new("phrase");
let result = string::slice!(phrase, 6, 11);
assert_eq!(
    result.fine_tune_params(),
    "string::slice(phrase, $_param_00000001, $_param_00000002)"
);
assert_eq!(result.to_raw().build(), "string::slice

(phrase, 6, 11)");

let result = string::slice!("Hello, world!", 7, 12);
assert_eq!(
    result.fine_tune_params(),
    "string::slice($_param_00000001, $_param_00000002, $_param_00000003)"
);
assert_eq!(
    result.to_raw().build(),
    "string::slice('Hello, world!', 7, 12)"
);
<span class="boring">}</span></code></pre></pre>
<h2 id="stringconcat-1"><a class="header" href="#stringconcat-1">string::concat!() <a name="concat-macro"></a></a></h2>
<p>The <code>string::concat!()</code> macro allows you to concatenate multiple strings.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let word1 = Field::new("word1");
let word2 = Field::new("word2");
let result = string::concat!(word1, " ", word2);
assert_eq!(
    result.fine_tune_params(),
    "string::concat(word1, $_param_00000001, word2)"
);
assert_eq!(result.to_raw().build(), "string::concat(word1, ' ', word2)");

let result = string::concat!("Hello", ", ", "world!");
assert_eq!(
    result.fine_tune_params(),
    "string::concat($_param_00000001, $_param_00000002, $_param_00000003)"
);
assert_eq!(
    result.to_raw().build(),
    "string::concat('Hello', ', ', 'world!')"
);
<span class="boring">}</span></code></pre></pre>
<h2 id="stringto_string"><a class="header" href="#stringto_string">string::to_string!() <a name="to-string-macro"></a></a></h2>
<p>The <code>string::to_string!()</code> macro allows you to convert a value to a string.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::functions::string;
use crate::*;

let number = Field::new("number");
let result = string::to_string!(number);
assert_eq!(
    result.fine_tune_params(),
    "string::to_string(number)"
);
assert_eq!(result.to_raw().build(), "string::to_string(number)");

let result = string::to_string!(42);
assert_eq!(
    result.fine_tune_params(),
    "string::to_string($_param_00000001)"
);
assert_eq!(result.to_raw().build(), "string::to_string(42)");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-functions"><a class="header" href="#time-functions">Time Functions</a></h1>
<ul>
<li><a href="functions/time.html#day-function">time::day()</a></li>
<li><a href="functions/time.html#floor-function">time::floor()</a></li>
<li><a href="functions/time.html#format-function">time::format()</a></li>
<li><a href="functions/time.html#group-function">time::group()</a></li>
<li><a href="functions/time.html#hour-function">time::hour()</a></li>
<li><a href="functions/time.html#minute-function">time::minute()</a></li>
<li><a href="functions/time.html#month-function">time::month()</a></li>
<li><a href="functions/time.html#nano-function">time::nano()</a></li>
<li><a href="functions/time.html#now-function">time::now()</a></li>
<li><a href="functions/time.html#round-function">time::round()</a></li>
<li><a href="functions/time.html#second-function">time::second()</a></li>
<li><a href="functions/time.html#timezone-function">time::timezone()</a></li>
<li><a href="functions/time.html#unix-function">time::unix()</a></li>
<li><a href="functions/time.html#wday-function">time::wday()</a></li>
<li><a href="functions/time.html#week-function">time::week()</a></li>
<li><a href="functions/time.html#yday-function">time::yday()</a></li>
<li><a href="functions/time.html#year-function">time::year()</a></li>
</ul>
<h2 id="timeday"><a class="header" href="#timeday">time::day() <a name="day-function"></a></a></h2>
<p>The <code>time::day()</code> function extracts the day as a number from a datetime.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::day(dt);
assert_eq!(
    result.to_raw().build(),
    "time::day('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::day(rebirth_date);
assert_eq!(result.to_raw().build(), "time::day(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::day(param);
assert_eq!(result.to_raw().build(), "time::day($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::day(dt);
assert_eq!(
    result.to_raw().build(),
    "time::day('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::day(rebirth_date);
assert_eq!(result.to_raw().build(), "time::day(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::day(param);
assert_eq!(result.to_raw().build(), "time::day($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<h2 id="timefloor"><a class="header" href="#timefloor">time::floor() <a name="floor-function"></a></a></h2>
<p>The <code>time::floor()</code> function rounds a datetime down by a specific duration.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let rebirth_date = Field::new("rebirth_date");
let duration = Field::new("duration");
let result = time::floor(rebirth_date, duration);

assert_eq!(
    result.to_raw().build(),
    "time::floor(rebirth_date, duration)"
);
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let rebirth_date = Field::new("rebirth_date");
let duration = Field::new("duration");
let result = time::floor(rebirth_date, duration);

assert_eq!(
    result.to_raw().

build(),
    "time::floor(rebirth_date, duration)"
);
<span class="boring">}</span></code></pre></pre>
<h2 id="timeformat"><a class="header" href="#timeformat">time::format() <a name="format-function"></a></a></h2>
<p>The <code>time::format()</code> function outputs a datetime according to a specific format.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);
let format_str = "'Year: 'yyyy-MM-dd";

let result = time::format(dt, format_str);
assert_eq!(
    result.to_raw().build(),
    "time::format('1970-01-01T00:01:01Z', 'Year: 'yyyy-MM-dd)"
);
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);
let format_str = "'Year: 'yyyy-MM-dd";

let result = time::format(dt, format_str);
assert_eq!(
    result.to_raw().build(),
    "time::format('1970-01-01T00:01:01Z', 'Year: 'yyyy-MM-dd)"
);
<span class="boring">}</span></code></pre></pre>
<h2 id="timegroup"><a class="header" href="#timegroup">time::group() <a name="group-function"></a></a></h2>
<p>The <code>time::group()</code> function groups a datetime by a particular time interval.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);
let interval = "month";

let result = time::group(dt, interval);
assert_eq!(
    result.to_raw().build(),
    "time::group('1970-01-01T00:01:01Z', 'month')"
);

let rebirth_date = Field::new("rebirth_date");
let interval_field = Field::new("interval");
let result = time::group(rebirth_date, interval_field);
assert_eq!(
    result.to_raw().build(),
    "time::group(rebirth_date, interval)"
);

let param = Param::new("rebirth_date");
let result = time::group(param, interval);
assert_eq!(
    result.to_raw().build(),
    "time::group($rebirth_date, 'month')"
);
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);
let interval = "month";

let result = time::group(dt, interval);
assert_eq!(
    result.to_raw().build(),
    "time::group('1970-01-01T00:01:01Z', 'month')"
);

let rebirth_date = Field::new("rebirth_date");
let interval_field = Field::new("interval");
let result = time::group(rebirth_date, interval_field);
assert_eq!(
    result.to_raw().build(),
    "time::group(rebirth_date, interval)"
);

let param = Param::new("rebirth_date");
let result = time::group(param, interval);
assert_eq!(
    result.to_raw().build(),
    "time::group($rebirth_date, 'month')"
);
<span class="boring">}</span></code></pre></pre>
<h2 id="timehour"><a class="header" href="#timehour">time::hour() <a name="hour-function"></a></a></h2>
<p>The <code>time::hour()</code> function extracts the hour as a number</p>
<p>from a datetime.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::hour(dt);
assert_eq!(
    result.to_raw().build(),
    "time::hour('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::hour(rebirth_date);
assert_eq!(result.to_raw().build(), "time::hour(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::hour(param);
assert_eq!(result.to_raw().build(), "time::hour($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::hour(dt);
assert_eq!(
    result.to_raw().build(),
    "time::hour('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::hour(rebirth_date);
assert_eq!(result.to_raw().build(), "time::hour(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::hour(param);
assert_eq!(result.to_raw().build(), "time::hour($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<h2 id="timeminute"><a class="header" href="#timeminute">time::minute() <a name="minute-function"></a></a></h2>
<p>The <code>time::minute()</code> function extracts the minutes as a number from a datetime.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::minute(dt);
assert_eq!(
    result.to_raw().build(),
    "time::minute('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::minute(rebirth_date);
assert_eq!(result.to_raw().build(), "time::minute(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::minute(param);
assert_eq!(result.to_raw().build(), "time::minute($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::minute(dt);
assert_eq!(
    result.to_raw().build(),
    "time::minute('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::minute(rebirth_date);
assert_eq!(result.to_raw().build(), "time::minute(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::minute(param);
assert_eq!(result.to_raw().build(), "time::minute($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<h2 id="timemonth"><a class="header" href="#timemonth">time::month() <a name="month-function"></a></a></h2>
<p>The <code>time::month()</code> function extracts the month as a number from a datetime.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::month(dt);
assert_eq!(
    result.to_raw().build(),
    "time::month('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::month(rebirth_date);
assert_eq!(result.to_raw().build(), "time::month(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::month(param);
assert_eq!(result.to_raw().build(), "time::month($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::month(dt);
assert_eq!(
    result.to_raw().build(),
    "time::month('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::month(rebirth_date);
assert_eq!(result.to_raw().build(), "time::month(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::month(param);
assert_eq!(result.to_raw().build(), "time::month($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<h2 id="timenano"><a class="header" href="#timenano">time::nano() <a name="nano-function"></a></a></h2>
<p>The <code>time::nano()</code> function returns the number of nanoseconds since the UNIX epoch.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let result = time::nano();
assert_eq!(result.to_raw().build(), "time::nano()");
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let result = time::nano();
assert_eq!(result.to_raw().build(), "time::nano()");
<span class="boring">}</span></code></pre></pre>
<h2 id="timenow"><a class="header" href="#timenow">time::now() <a name="now-function"></a></a></h2>
<p>The <code>time::now()</code> function returns the current datetime.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let result = time::now();
assert_eq!(result.to_raw().build(), "time::now()");
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let result = time::now();
assert_eq!(result.to_raw().build(), "time::now()");
<span class="boring">}</span></code></pre></pre>
<h2 id="timeround"><a class="header" href="#timeround">time::round() <a name="round-function"></a></a></h2>
<p>The <code>time::round()</code> function rounds a datetime to the nearest multiple of a specific duration.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let rebirth_date = Field::new("rebirth_date");
let duration = Field::new("duration");
let result = time::round(rebirth_date, duration);

assert_eq!(
    result.to_raw().build(),
    "time::round(rebirth_date, duration)"
);
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let rebirth_date = Field::new("rebirth_date");
let duration = Field::new("duration");
let result = time::round(rebirth_date, duration);

assert_eq!(
    result.to_raw().build(),
    "time::round(rebirth_date, duration)"
);
<span class="boring">}</span></code></pre></pre>
<h2 id="timesecond-a"><a class="header" href="#timesecond-a">time::second() <a name="second-function">&lt;/a</a></h2>
<blockquote>
</blockquote>
<p>The <code>time::second()</code> function extracts the second as a number from a datetime.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::second(dt);
assert_eq!(
    result.to_raw().build(),
    "time::second('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::second(rebirth_date);
assert_eq!(result.to_raw().build(), "time::second(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::second(param);
assert_eq!(result.to_raw().build(), "time::second($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::second(dt);
assert_eq!(
    result.to_raw().build(),
    "time::second('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::second(rebirth_date);
assert_eq!(result.to_raw().build(), "time::second(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::second(param);
assert_eq!(result.to_raw().build(), "time::second($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<h2 id="timetimezone"><a class="header" href="#timetimezone">time::timezone() <a name="timezone-function"></a></a></h2>
<p>The <code>time::timezone()</code> function returns the current local timezone offset in hours.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let result = time::timezone();
assert_eq!(result.to_raw().build(), "time::timezone()");
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let result = time::timezone();
assert_eq!(result.to_raw().build(), "time::timezone()");
<span class="boring">}</span></code></pre></pre>
<h2 id="timeunix"><a class="header" href="#timeunix">time::unix() <a name="unix-function"></a></a></h2>
<p>The <code>time::unix()</code> function returns the number of seconds since the UNIX epoch.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let result = time::unix();
assert_eq!(result.to_raw().build(), "time::unix()");
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let result = time::unix();
assert_eq!(result.to_raw().build(), "time::unix()");
<span class="boring">}</span></code></pre></pre>
<h2 id="timewday"><a class="header" href="#timewday">time::wday() <a name="wday-function"></a></a></h2>
<p>The <code>time::wday()</code> function extracts the week day as a number from a datetime.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::wday(dt);
assert_eq!(
    result.to_raw().build(),
    "time::wday('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::wday(rebirth_date);
assert_eq!(result.to_raw().build(), "time::wday(rebirth_date)");



let param = Param::new("rebirth_date");
let result = time::wday(param);
assert_eq!(result.to_raw().build(), "time::wday($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::wday(dt);
assert_eq!(
    result.to_raw().build(),
    "time::wday('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::wday(rebirth_date);
assert_eq!(result.to_raw().build(), "time::wday(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::wday(param);
assert_eq!(result.to_raw().build(), "time::wday($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<h2 id="timeweek"><a class="header" href="#timeweek">time::week() <a name="week-function"></a></a></h2>
<p>The <code>time::week()</code> function extracts the week as a number from a datetime.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::week(dt);
assert_eq!(
    result.to_raw().build(),
    "time::week('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::week(rebirth_date);
assert_eq!(result.to_raw().build(), "time::week(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::week(param);
assert_eq!(result.to_raw().build(), "time::week($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::week(dt);
assert_eq!(
    result.to_raw().build(),
    "time::week('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::week(rebirth_date);
assert_eq!(result.to_raw().build(), "time::week(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::week(param);
assert_eq!(result.to_raw().build(), "time::week($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<h2 id="timeyday"><a class="header" href="#timeyday">time::yday() <a name="yday-function"></a></a></h2>
<p>The <code>time::yday()</code> function extracts the yday as a number from a datetime.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::yday(dt);
assert_eq!(
    result.to_raw().build(),
    "time::yday('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::yday(rebirth_date);
assert_eq!(result.to_raw().build(), "

time::yday(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::yday(param);
assert_eq!(result.to_raw().build(), "time::yday($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::yday(dt);
assert_eq!(
    result.to_raw().build(),
    "time::yday('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::yday(rebirth_date);
assert_eq!(result.to_raw().build(), "time::yday(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::yday(param);
assert_eq!(result.to_raw().build(), "time::yday($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<h2 id="timeyear"><a class="header" href="#timeyear">time::year() <a name="year-function"></a></a></h2>
<p>The <code>time::year()</code> function extracts the year as a number from a datetime.</p>
<p><strong>Usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::year(dt);
assert_eq!(
    result.to_raw().build(),
    "time::year('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::year(rebirth_date);
assert_eq!(result.to_raw().build(), "time::year(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::year(param);
assert_eq!(result.to_raw().build(), "time::year($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::{*, functions::time};

let dt = chrono::DateTime::&lt;chrono::Utc&gt;::from_naive_utc_and_offset(
    chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(),
    chrono::Utc,
);

let result = time::year(dt);
assert_eq!(
    result.to_raw().build(),
    "time::year('1970-01-01T00:01:01Z')"
);

let rebirth_date = Field::new("rebirth_date");
let result = time::year(rebirth_date);
assert_eq!(result.to_raw().build(), "time::year(rebirth_date)");

let param = Param::new("rebirth_date");
let result = time::year(param);
assert_eq!(result.to_raw().build(), "time::year($rebirth_date)");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-functions"><a class="header" href="#type-functions">Type functions</a></h1>
<h2 id="table-of-contents-46"><a class="header" href="#table-of-contents-46">Table of Contents</a></h2>
<ul>
<li><a href="functions/type.html#bool-macro">type_::bool!()</a></li>
<li><a href="functions/type.html#datetime-macro">type_::datetime!()</a></li>
<li><a href="functions/type.html#decimal-macro">type_::decimal!()</a></li>
<li><a href="functions/type.html#duration-macro">type_::duration!()</a></li>
<li><a href="functions/type.html#float-macro">type_::float!()</a></li>
<li><a href="functions/type.html#int-macro">type_::int!()</a></li>
<li><a href="functions/type.html#number-macro">type_::number!()</a></li>
<li><a href="functions/type.html#point-macro">type_::point!()</a></li>
<li><a href="functions/type.html#regex-macro">type_::regex!()</a></li>
<li><a href="functions/type.html#string-macro">type_::string!()</a></li>
<li><a href="functions/type.html#table-macro">type_::table!()</a></li>
<li><a href="functions/type.html#thing-macro">type_::thing!()</a></li>
</ul>
<h2 id="type_bool"><a class="header" href="#type_bool">type_::bool!() <a name="bool-macro"></a></a></h2>
<p>The <code>type_::bool!()</code> macro allows you to convert a value into a boolean.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::macros::type_;

let result = type_::bool!(43545);
assert_eq!(result.to_raw().build(), "type::bool(43545)");

let bool_field = Field::new("bool_field");
let result = type_::bool!(bool_field);
assert_eq!(result.to_raw().build(), "type::bool(bool_field)");

let bool_param = Param::new("bool_param");
let result = type_::bool!(bool_param);
assert_eq!(result.to_raw().build(), "type::bool($bool_param)");
<span class="boring">}</span></code></pre></pre>
<h2 id="type_datetime"><a class="header" href="#type_datetime">type_::datetime!() <a name="datetime-macro"></a></a></h2>
<p>The <code>type_::datetime!()</code> macro allows you to convert a value into a datetime.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::macros::type_;
use chrono::DateTime;
use chrono::Utc;

let value = DateTime::&lt;Utc&gt;::from_naive_utc_and_offset(chrono::NaiveDateTime::from_timestamp_opt(61, 0).unwrap(), Utc);
let result = type_::datetime!(value);
assert_eq!(result.to_raw().build(), "type::datetime('1970-01-01T00:01:01Z')");

let datetime_field = Field::new("datetime_field");
let result = type_::datetime!(datetime_field);
assert_eq!(result.to_raw().build(), "type::datetime(datetime_field)");

let datetime_param = Param::new("datetime_param");
let result = type_::datetime!(datetime_param);
assert_eq!(result.to_raw().build(), "type::datetime($datetime_param)");
<span class="boring">}</span></code></pre></pre>
<h2 id="type_decimal"><a class="header" href="#type_decimal">type_::decimal!() <a name="decimal-macro"></a></a></h2>
<p>The <code>type_::decimal!()</code> macro allows you to convert a value into a decimal.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::macros::type_;

let result = type_::decimal!(1234.56);
assert_eq!(result.to_raw().build(), "type::decimal(1234.56)");

let decimal_field = Field::new("decimal_field");
let result = type_::decimal!(decimal_field);
assert_eq!(result.to_raw().build(), "type::decimal(decimal_field)");

let decimal_param = Param::new("decimal_param");
let result = type_::decimal!(decimal_param);
assert_eq!(result.to_raw().build(), "type::decimal($decimal_param)");
<span class="boring">}</span></code></pre></pre>
<h2 id="type_duration"><a class="header" href="#type_duration">type_::duration!() <a name="duration-macro"></a></a></h2>
<p>The <code>type_::duration!()</code> macro allows you to convert a value into a duration.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>

<span class="boring">fn main() {
</span>use surreal_orm::macros::type_;
use std::time::Duration;

let result = type_::duration!(Duration::from_secs(24 * 60 * 60 * 7));
assert_eq!(result.to_raw().build(), "type::duration(1w)");

let duration_field = Field::new("duration_field");
let result = type_::duration!(duration_field);
assert_eq!(result.to_raw().build(), "type::duration(duration_field)");

let duration_param = Param::new("duration_param");
let result = type_::duration!(duration_param);
assert_eq!(result.to_raw().build(), "type::duration($duration_param)");
<span class="boring">}</span></code></pre></pre>
<h2 id="type_float"><a class="header" href="#type_float">type_::float!() <a name="float-macro"></a></a></h2>
<p>The <code>type_::float!()</code> macro allows you to convert a value into a floating point number.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::macros::type_;

let result = type_::float!(43.5);
assert_eq!(result.to_raw().build(), "type::float(43.5)");

let float_field = Field::new("float_field");
let result = type_::float!(float_field);
assert_eq!(result.to_raw().build(), "type::float(float_field)");

let float_param = Param::new("float_param");
let result = type_::float!(float_param);
assert_eq!(result.to_raw().build(), "type::float($float_param)");
<span class="boring">}</span></code></pre></pre>
<h2 id="type_int"><a class="header" href="#type_int">type_::int!() <a name="int-macro"></a></a></h2>
<p>The <code>type_::int!()</code> macro allows you to convert a value into an integer.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::macros::type_;

let result = type_::int!(99);
assert_eq!(result.to_raw().build(), "type::int(99)");

let int_field = Field::new("int_field");
let result = type_::int!(int_field);
assert_eq!(result.to_raw().build(), "type::int(int_field)");

let int_param = Param::new("int_param");
let result = type_::int!(int_param);
assert_eq!(result.to_raw().build(), "type::int($int_param)");
<span class="boring">}</span></code></pre></pre>
<h2 id="type_number"><a class="header" href="#type_number">type_::number!() <a name="number-macro"></a></a></h2>
<p>The <code>type_::number!()</code> macro allows you to convert a value into a number.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::macros::type_;

let result = type_::number!(5);
assert_eq!(result.to_raw().build(), "type::number(5)");

let number_field = Field::new("number_field");
let result = type_::number!(number_field);
assert_eq!(result.to_raw().build(), "type::number(number_field)");

let number_param = Param::new("number_param");
let result = type_::number!(number_param);
assert_eq!(result.to_raw().build(), "type::number($number_param)");
<span class="boring">}</span></code></pre></pre>
<h2 id="type_point"><a class="header" href="#type_point">type_::point!() <a name="point-macro"></a></a></h2>
<p>The <code>type_::point!()</code> macro allows you to convert a value into a geometry point.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::macros::type_;

let result = type_::point!(51.509865, -0.118092);
assert_eq!(result.to_raw().build(), "type::point(51.509865, -0.118092)");

let point_field = Field::new("point_field");
let result = type_::point!(point_field);
assert_eq!(result.to_raw().build(), "type::point(point_field)");

let point_param = Param::new("point_param");
let result = type

_::point!(point_param);
assert_eq!(result.to_raw().build(), "type::point($point_param)");
<span class="boring">}</span></code></pre></pre>
<h2 id="type_regex"><a class="header" href="#type_regex">type_::regex!() <a name="regex-macro"></a></a></h2>
<p>The <code>type_::regex!()</code> macro allows you to convert a value into a regular expression.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::macros::type_;

let result = type_::regex!("/[A-Z]{3}/");
assert_eq!(result.to_raw().build(), "type::regex('/[A-Z]{3}/')");

let regex_field = Field::new("regex_field");
let result = type_::regex!(regex_field);
assert_eq!(result.to_raw().build(), "type::regex(regex_field)");

let regex_param = Param::new("regex_param");
let result = type_::regex!(regex_param);
assert_eq!(result.to_raw().build(), "type::regex($regex_param)");
<span class="boring">}</span></code></pre></pre>
<h2 id="type_string"><a class="header" href="#type_string">type_::string!() <a name="string-macro"></a></a></h2>
<p>The <code>type_::string!()</code> macro allows you to convert a value into a string.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::macros::type_;

let result = type_::string!(5454);
assert_eq!(result.to_raw().build(), "type::string(5454)");

let string_field = Field::new("string_field");
let result = type_::string!(string_field);
assert_eq!(result.to_raw().build(), "type::string(string_field)");

let string_param = Param::new("string_param");
let result = type_::string!(string_param);
assert_eq!(result.to_raw().build(), "type::string($string_param)");
<span class="boring">}</span></code></pre></pre>
<h2 id="type_table"><a class="header" href="#type_table">type_::table!() <a name="table-macro"></a></a></h2>
<p>The <code>type_::table!()</code> macro allows you to convert a value into a table definition.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::macros::type_;
use surreal_orm::statements::let_;

let result = type_::table!("user");
assert_eq!(result.to_raw().build(), "type::table(user)");

let table_field = Field::new("table_field");
let result = type_::table!(table_field);
assert_eq!(result.to_raw().build(), "type::table(table_field)");

let table_param = let_("table_param").equal_to("user").get_param();
let result = type_::table!(table_param);
assert_eq!(result.to_raw().build(), "type::table($table_param)");
<span class="boring">}</span></code></pre></pre>
<h2 id="type_thing"><a class="header" href="#type_thing">type_::thing!() <a name="thing-macro"></a></a></h2>
<p>The <code>type_::thing!()</code> macro allows you to convert a value into a record pointer.</p>
<p><strong>Examples:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::macros::type_;
use surreal_orm::Table;

let user = Table::from("user");
let id = "oyelowo";
let result = type_::thing!(user, id);
assert_eq!(result.to_raw().build(), "type::thing(user, 'oyelowo')");

let table = Table::new("table");
let id = Field::new("id");
let result = type_::thing!(table, id);
assert_eq!(result.to_raw().build(), "type::thing(table, id)");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripting-function"><a class="header" href="#scripting-function">Scripting function</a></h1>
<h2 id="table-of-contents-47"><a class="header" href="#table-of-contents-47">Table of Contents</a></h2>
<ul>
<li><a href="functions/scripting.html#function-macro">function!()</a></li>
</ul>
<h2 id="function"><a class="header" href="#function">function!() <a name="function-macro"></a></a></h2>
<p>The <code>function!()</code> macro allows you to define JavaScript functions with different parameters and function bodies.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use surreal_orm::macros::function;
use surreal_orm::statements::let_;

let value = let_("value").equal_to("SurrealDB").get_param();
let words = let_("words").equal_to(vec!["awesome", "advanced", "cool"]).get_param();

let f2 = function!(
    (value, words),
    "{ return `${arguments[0]} is ${arguments[1]}`; }"
);

assert_eq!(
    f2.build(),
    "function($value, $words) { return `${arguments[0]} is ${arguments[1]}`; }"
);

assert_eq!(
    f2.to_raw().build(),
    "function($value, $words) { return `${arguments[0]} is ${arguments[1]}`; }"
);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion-6"><a class="header" href="#conclusion-6">Conclusion</a></h1>
<p>Throughout our exploration of Surreal ORM, we've traversed the vast landscape of
database management, from the foundational concepts of Object-Relational Mapping
to the intricate nuances of creating advanced and efficient database queries.
The journey, while occasionally challenging, has been immensely rewarding.</p>
<p>We started by understanding the core tenets of ORM and how Surreal ORM aims to
revolutionize the way we interact with databases. The emphasis on a more
intuitive, macro-driven approach not only simplifies query building but also
offers a level of flexibility previously unseen in conventional ORM tools.</p>
<p>Our in-depth discussions shed light on the importance of efficient query
building. With the help of the <code>surreal_orm</code> query builder, we explored how to
craft complex queries that maintain readability and efficiency. The cond
function and <code>cond!</code> macro was a particular highlight, providing a convenient
method to generate filters without sacrificing clarity or performance.</p>
<p>The challenges of nested queries and multi-level operations were not overlooked.
By introducing an elegant solution in the form of recursive macros, Surreal ORM
ensures that developers can handle any level of complexity with ease.</p>
<p>However, it's essential to remember that while tools like Surreal ORM can
significantly simplify database operations, the true power lies in understanding
the underlying principles. A tool is only as good as the craftsman wielding it.
Your grasp on the intricacies of ORM and your ability to adapt and innovate will
define the success of your projects.</p>
<p>As we conclude this guide, it's worth noting that the world of technology is
ever-evolving. While Surreal ORM offers a robust solution for today's
challenges, the future might bring new requirements. Engage with the Surreal ORM
community, share your insights, learn from others, and contribute towards
refining and expanding this already formidable tool.</p>
<p>Thank you for accompanying me on this enlightening journey through Surreal ORM.
Armed with the knowledge from our discussions, you're now well-equipped to
harness the full potential of this tool. Here's to building more efficient,
intuitive, and scalable applications!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>

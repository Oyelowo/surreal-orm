use _core::ops::Deref;
use insta;
use regex;
use serde::{Deserialize, Serialize};
use static_assertions::*;
use std::time::Duration;
use surrealdb::{
    engine::local::{Db, Mem},
    opt::IntoResource,
    sql::{self, Id},
    Result, Surreal,
};
// use surreal_derive::{Edge, Node};

use std::fmt::{Debug, Display};
use surreal_orm::{
    functions::*,
    statements::{
        define_field, define_table, for_, order, select, DefineFieldStatement,
        DefineTableStatement, For, PermissionType, SelectStatement,
    },
    *,
};

use test_case::test_case;
use typed_builder::TypedBuilder;

fn gama() -> SelectStatement {
    crypto::argon2::compare!("Rer", "Erer");
    // All

    select(All).from(Table::new("user"))
}
fn full() -> u32 {
    54
}
fn perm() -> RawStatement {
    use CrudType::*;
    let name = Field::new("name");
    let age = Field::new("age");
    // vec![
    //     for_(&[Create, Delete]).where_(name.is("Oyelowo")),
    //     for_(Update).where_(age.less_than_or_equal(130)),
    // ]
    // .into_iter()
    // .map(|e| e.to_raw())
    // .collect::<Vec<_>>()
    // .to_vec()
    PermissionType::from(vec![
        for_(&[Create, Delete]).where_(name.is("Oyelowo")),
        for_(Update).where_(age.less_than_or_equal(130)),
    ])
    // .to_raw()
}
// use Duration;
fn we() -> sql::Value {
    surrealdb::sql::Value::Duration(Duration::from_secs(60 * 60 * 24 * 7).into())
}

fn erer() -> Filter {
    cond(value().is_not(NONE)).and(value().like("email"))
}
// fn define_age() -> DefineFieldStatement {
//     use surreal_orm::{Model, Node};
//     use CrudType::*;
//     let student_schema::Student { age, firstName, .. } = Student::schema();
//
//     use FieldType::*;
//
//     // let statement = define_field(Student::schema().age)
//     //     .on_table(Student::table_name())
//     //     .type_(String)
//     //     .value("example@codebreather.com")
//     //     .assert(cond(value().is_not(NONE)).and(value().like("is_email")))
//     //     // .permissions_for(for_(Select).where_(age.greater_than_or_equal(18))) // Single works
//     //     .permissions_for(PermissionForables::from(
//     //         for_(&[Create, Update])
//     //             .where_(firstName.is("Oyedayo"))
//     //             .to_raw(),
//     //     )) //Multiple
//     //     .permissions_for(
//     //         PermissionForables::from(&[
//     //             for_(&[Create, Delete]).where_(firstName.is("Oyelowo")),
//     //             for_(Update).where_(age.less_than_or_equal(130)),
//     //         ])
//     //         .to_raw(),
//     //     );
//     let statement = define_field(Student::schema().age)
//         .on_table(Student::table_name())
//         .type_(String)
//         .value("example@codebreather.com")
//         .assert(cond(value().is_not(NONE)).and(value().like("is_email")))
//         .permissions(for_(Select).where_(age.greater_than_or_equal(18))) // Single works
//         .permissions(for_(&[Create, Update]).where_(firstName.is("Oyedayo"))) //Multiple
//         .permissions(
//             &[
//                 for_(&[Create, Delete]).where_(firstName.is("Oyelowo")),
//                 for_(Update).where_(age.less_than_or_equal(130)),
//             ], // .into_iter()
//                // .map(|e| e.to_raw())
//                // .collect::<Vec<_>>()
//                // .to_vec(),
//         );
//     statement
// }

#[derive(Node, TypedBuilder, Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
#[surreal_orm(
    table_name = "student",
    // drop,
    // schemafull,
    // as = "select(All)",
    // permissions = "perm()",
    // define = "define_student()"
)]
pub struct Student {
    id: SurrealId<Student, String>,
    first_name: String,
    last_name: String,
    #[surreal_orm(
        type = "int",
        // value = "we()",
        value = "18",
        // assert = "erer()",
        assert = "cond(value().is_not(NONE)).and(value().gte(18))",
        permissions = "perm()",
        // define = "define_age()"
    )]
    age: u8,

    #[surreal_orm(
        type = "int",
        value = "we()",
        // value = "18",
        assert = "erer()",
        // assert = "cond(value().is_not(NONE)).and(value().gte(18))",
        permissions = "perm()",
        // define = "define_age()"
    )]
    score: u8,

    // Even if ypu dont list the type for all links, the types are autogenerated at compile time
    // becuase I have enough info from the annotation to derive it
    #[surreal_orm(link_self = "Student", type = "record(student)")]
    best_friend: LinkSelf<Student>,

    #[surreal_orm(link_one = "Book")]
    #[serde(rename = "unoBook")]
    fav_book: LinkOne<Book>,

    #[surreal_orm(link_one = "Book", skip_serializing)]
    course: LinkOne<Book>,

    #[surreal_orm(link_many = "Book", type = "array", item_type = "record(book)")]
    #[serde(rename = "semesterCourses")]
    all_semester_courses: LinkMany<Book>,

    #[surreal_orm(relate(model = "StudentWritesBook", connection = "->writes->book"))]
    #[serde(skip_serializing)]
    written_books: Relate<Book>,

    #[surreal_orm(relate(model = "StudentWritesBlog", connection = "->writes->blog"))]
    #[serde(skip_serializing)]
    blogsssss: Relate<Blog>,
}

impl Default for Student {
    fn default() -> Self {
        let id = Self::create_id(sql::Id::rand().to_raw());
        Self {
            id,
            first_name: Default::default(),
            last_name: Default::default(),
            age: Default::default(),
            score: Default::default(),
            best_friend: Default::default(),
            fav_book: Default::default(),
            course: Default::default(),
            all_semester_courses: Default::default(),
            written_books: Default::default(),
            blogsssss: Default::default(),
        }
    }
}

#[derive(surreal_orm::Edge, TypedBuilder, Serialize, Deserialize, Debug, Clone, Default)]
#[serde(rename_all = "camelCase")]
#[surreal_orm(table_name = "writes")]
pub struct Writes<In: Node, Out: Node> {
    pub id: SurrealSimpleId<Writes<In, Out>>,

    #[serde(rename = "in", skip_serializing)]
    pub in_: LinkOne<In>,
    #[serde(skip_serializing)]
    pub out: LinkOne<Out>,
    pub time_written: Duration,
    pub count: i32,
}

pub type StudentWritesBook = Writes<Student, Book>;
pub type StudentWritesBlog = Writes<Student, Blog>;

#[derive(Edge, TypedBuilder, Serialize, Deserialize, Debug, Clone, Default)]
#[serde(rename_all = "camelCase")]
#[surreal_orm(table_name = "likes")]
pub struct Likes<In: Node, Out: Node> {
    pub id: SurrealSimpleId<Likes<In, Out>>,

    #[serde(rename = "in", skip_serializing)]
    pub in_: LinkOne<In>,
    #[serde(skip_serializing)]
    pub out: LinkOne<Out>,
    pub likes_count: u64,
}
pub type StudentLiksBook = Likes<Student, Book>;

#[derive(Node, TypedBuilder, Serialize, Deserialize, Debug, Clone, Default)]
#[serde(rename_all = "camelCase")]
#[surreal_orm(table_name = "book")]
pub struct Book {
    id: SurrealSimpleId<Book>,
    title: String,
    content: String,
}

#[derive(Node, TypedBuilder, Serialize, Deserialize, Debug, Clone, Default)]
#[serde(rename_all = "camelCase")]
#[surreal_orm(table_name = "blog")]
pub struct Blog {
    id: SurrealSimpleId<Blog>,
    title: String,
    content: String,
}
//
// #[derive(Node, TypedBuilder, Serialize, Deserialize, Debug, Clone)]
// #[serde(rename_all = "camelCase")]
// #[surreal_orm(
//     table_name = "student"
//     drop,
//     schemafull,
//     as = "select(All)",
//     permissions = "perm()",
//     // permissions_fn = "perm",
//     // define = "define_student()",
//     // define_fn = "define_student"
// )]
// pub struct StudentWithFn {
//     id: SurrealId<Student, String>,
//
//     first_name: String,
//     last_name: String,
//     #[surreal_orm(
//         // type="array(int)",
//         // type = "geometry(feature, point, collection, polygon)",
//         // value = "we()",
//         // value = "Duration::from_secs(54)",
//         // assert_fn = "erer",
//         // assert = "erer()",
//         // assert_fn = "erer",
//         // assert = "cond(value().is_not(NONE))",
//         // assert = "cond(value().is_not(NONE)).and(value().like("is_email"))",
//         // permissions = "perm()",
//         // permissions_fn = "perm",
//         // define = "define_age()",
//         define_fn = "define_age"
//     )]
//     age: u8,
//
//     // Even if ypu dont list the type for all links, the types are autogenerated at compile time
//     // becuase I have enough info from the annotation to derive it
//     #[surreal_orm(link_self = "Student", type = "record(student)")]
//     best_friend: LinkSelf<Student>,
//
//     #[surreal_orm(link_one = "Book")]
//     #[serde(rename = "unoBook")]
//     fav_book: LinkOne<Book>,
//
//     #[surreal_orm(link_one = "Book", skip_serializing)]
//     course: LinkOne<Book>,
//
//     #[surreal_orm(
//         link_many = "Book",
//         type = "array",
//         item_type = "record(book)",
//         item_assert_fn = "erer"
//     )]
//     #[serde(rename = "semesterCourses")]
//     all_semester_courses: LinkMany<Book>,
//
//     #[surreal_orm(relate(model = "StudentWritesBook", connection = "->writes->book"))]
//     #[serde(skip_serializing)]
//     written_books: Relate<Book>,
//
//     // #[surreal_orm(relate(model = "StudentWritesBook", connection = "->writes->book"))]
//     // #[serde(skip_serializing)]
//     // prof_book: Relate<Book>,
//     #[surreal_orm(relate(model = "StudentWritesBlog", connection = "->writes->blog"))]
//     #[serde(skip_serializing)]
//     blogsssss: Relate<Blog>,
// }
//
// fn define_student() -> DefineTableStatement {
//     use CrudType::*;
//     let name = Field::new("name");
//     let _user_table = Table::from("user");
//     let age = Field::new("age");
//     let country = Field::new("country");
//     let fake_id2 = sql::Thing::from(("user".to_string(), "oyedayo".to_string()));
//
//     let statement = define_table(Student::table_name())
//         .drop()
//         .as_(
//             select(All)
//                 .from(fake_id2)
//                 .where_(country.is("INDONESIA"))
//                 .order_by(order(&age).numeric().desc())
//                 .limit(20)
//                 .start(5),
//         )
//         .schemafull()
//         .permissions(for_(Select).where_(age.greater_than_or_equal(18))) // Single works
//         .permissions(for_([Create, Delete]).where_(name.is("Oyedayo"))) //Multiple
//         .permissions([
//             for_([Create, Delete]).where_(name.is("Oyedayo")),
//             for_(Update).where_(age.less_than_or_equal(130)),
//         ]);
//
//     statement
// }
//
// fn define_score() -> DefineFieldStatement {
//     use surreal_orm::{Model, Node};
//     use CrudType::*;
//     let student_schema::Student { age, firstName, .. } = Student::schema();
//
//     use FieldType::*;
//
//     let statement = define_field(Student::schema().age)
//         .on_table(Student::table_name())
//         .type_(FieldType::String)
//         .value(18)
//         .permissions(for_(FieldType::Select).where_(age.gte(50))) // Single works
//         .permissions(
//             for_([Create, Update])
//                 .where_(firstName.is("Oyedayo"))
//                 .to_raw(),
//         ) //Multiple
//         .permissions(
//             [
//                 for_([Create, Delete]).where_(firstName.is("Oyelowo")),
//                 for_(Update).where_(age.less_than_or_equal(130)),
//             ]
//             .to_raw(),
//         );
//     statement
// }
// #[derive(Node, TypedBuilder, Serialize, Deserialize, Debug, Clone)]
// #[serde(rename_all = "camelCase")]
// #[surreal_orm(table_name = "student_external_defs", define_fn = "define_student")]
// pub struct StudentExternalDefs {
//     id: SurrealId<StudentExternalDefs, String>,
//     first_name: String,
//     last_name: String,
//     #[surreal_orm(
//         // type="array(int)",
//         // type = "geometry(feature, point, collection, polygon)",
//         // value = "we()",
//         // value = "Duration::from_secs(54)",
//         // assert_fn = "erer",
//         // assert = "erer()",
//         // assert_fn = "erer",
//         // assert = "cond(value().is_not(NONE))",
//         // assert = "cond(value().is_not(NONE)).and(value().like("is_email"))",
//         // permissions = "perm()",
//         // permissions_fn = "perm",
//         // define = "define_age()",
//         define_fn = "define_age"
//     )]
//     age: u8,
//
//     #[surreal_orm(
//         link_self = "StudentExternalDefs",
//         type = "record(student_external_defs)"
//     )]
//     best_friend: LinkSelf<StudentExternalDefs>,
//
//     #[surreal_orm(link_one = "Book")]
//     #[serde(rename = "unoBook")]
//     fav_book: LinkOne<Book>,
//
//     #[surreal_orm(link_one = "Book", skip_serializing)]
//     course: LinkOne<Book>,
//
//     #[surreal_orm(
//         link_many = "Book",
//         type = "array",
//         item_type = "record(book)",
//         item_assert_fn = "erer"
//     )]
//     #[serde(rename = "semesterCourses")]
//     all_semester_courses: LinkMany<Book>,
//
//     #[surreal_orm(relate(model = "StudentWritesBook", connection = "->writes->book"))]
//     #[serde(skip_serializing)]
//     written_books: Relate<Book>,
//
//     // #[surreal_orm(relate(model = "StudentWritesBook", connection = "->writes->book"))]
//     // #[serde(skip_serializing)]
//     // prof_book: Relate<Book>,
//     #[surreal_orm(relate(model = "StudentWritesBlog", connection = "->writes->blog"))]
//     #[serde(skip_serializing)]
//     blogsssss: Relate<Blog>,
// }
//
// =====================================
// Recursive expansion of the Node macro
// =====================================

use surreal_orm::Aliasable as _;
use surreal_orm::ToRaw as _;
impl surreal_orm::SchemaGetter for Student {
    type Schema = student_schema::Student;
    fn schema() -> Self::Schema {
        student_schema::Student::new()
    }
    fn schema_prefixed(prefix: impl ::std::convert::Into<surreal_orm::Valuex>) -> Self::Schema {
        student_schema::Student::new_prefixed(prefix)
    }
}
impl surreal_orm::Node for Student {
    type TableNameChecker = student_schema::TableNameStaticChecker;
    type Aliases = student_schema::StudentAliases;
    type NonNullUpdater = StudentNonNullUpdater;
    fn with(
        clause: impl Into<surreal_orm::NodeClause>,
    ) -> <Self as surreal_orm::SchemaGetter>::Schema {
        let clause: surreal_orm::NodeClause = clause.into();
        student_schema::Student::__________connect_node_to_graph_traversal_string(
            student_schema::Student::empty(),
            clause.with_table("student"),
        )
    }
    fn aliases() -> Self::Aliases {
        student_schema::StudentAliases::new()
    }
    fn get_table_name() -> surreal_orm::Table {
        "student".into()
    }
    fn get_fields_relations_aliased() -> Vec<surreal_orm::Alias> {
        vec![
            surreal_orm::Field::new("->writes->book")
                .__as__(surreal_orm::AliasName::new("writtenBooks")),
            surreal_orm::Field::new("->writes->blog")
                .__as__(surreal_orm::AliasName::new("blogsssss")),
        ]
    }
}
#[allow(non_snake_case)]
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct StudentNonNullUpdater {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub firstName: ::std::option::Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lastName: ::std::option::Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub age: ::std::option::Option<u8>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub score: ::std::option::Option<u8>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bestFriend: ::std::option::Option<LinkSelf<Student>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unoBook: ::std::option::Option<LinkOne<Book>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub course: ::std::option::Option<LinkOne<Book>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub semesterCourses: ::std::option::Option<LinkMany<Book>>,
}
#[allow(non_snake_case)]
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct StudentRenamedCreator {
    pub id: &'static str,
    pub firstName: &'static str,
    pub lastName: &'static str,
    pub age: &'static str,
    pub score: &'static str,
    pub unoBook: &'static str,
    pub course: &'static str,
    pub semesterCourses: &'static str,
}
impl Student {
    pub const fn __get_serializable_field_names() -> [&'static str; 8usize] {
        [
            "surreal_orm :: Field :: new (\"id\")",
            "surreal_orm :: Field :: new (\"firstName\")",
            "surreal_orm :: Field :: new (\"lastName\")",
            "surreal_orm :: Field :: new (\"age\")",
            "surreal_orm :: Field :: new (\"score\")",
            "surreal_orm :: Field :: new (\"bestFriend\")",
            "surreal_orm :: Field :: new (\"unoBook\")",
            "surreal_orm :: Field :: new (\"semesterCourses\")",
        ]
    }
}
impl surreal_orm::Model for Student {
    type Id = SurrealId<Student, String>;
    type NonNullUpdater = StudentNonNullUpdater;
    type StructRenamedCreator = StudentRenamedCreator;
    fn table_name() -> surreal_orm::Table {
        "student".into()
    }
    fn get_id(self) -> Self::Id {
        self.id
    }
    fn get_id_as_thing(&self) -> surreal_orm::sql::Thing {
        surreal_orm::sql::thing(self.id.to_raw().as_str()).unwrap()
    }
    fn get_serializable_fields() -> Vec<surreal_orm::Field> {
        return vec![
            surreal_orm::Field::new("id"),
            surreal_orm::Field::new("firstName"),
            surreal_orm::Field::new("lastName"),
            surreal_orm::Field::new("age"),
            surreal_orm::Field::new("score"),
            surreal_orm::Field::new("bestFriend"),
            surreal_orm::Field::new("unoBook"),
            surreal_orm::Field::new("semesterCourses"),
        ];
    }
    fn get_linked_fields() -> Vec<surreal_orm::Field> {
        return vec![
            surreal_orm::Field::new("bestFriend"),
            surreal_orm::Field::new("unoBook"),
            surreal_orm::Field::new("semesterCourses"),
        ];
    }
    fn get_link_one_fields() -> Vec<surreal_orm::Field> {
        return vec![surreal_orm::Field::new("unoBook")];
    }
    fn get_link_self_fields() -> Vec<surreal_orm::Field> {
        return vec![surreal_orm::Field::new("bestFriend")];
    }
    fn get_link_one_and_self_fields() -> Vec<surreal_orm::Field> {
        return vec![
            surreal_orm::Field::new("bestFriend"),
            surreal_orm::Field::new("unoBook"),
        ];
    }
    fn get_link_many_fields() -> Vec<surreal_orm::Field> {
        return vec![surreal_orm::Field::new("semesterCourses")];
    }
    fn define_table() -> surreal_orm::Raw {
        surreal_orm::statements::define_table(Self::table_name()).to_raw()
    }
    fn define_fields() -> Vec<surreal_orm::Raw> {
        vec![
            surreal_orm::statements::define_field(surreal_orm::Field::new("id"))
                .on_table(surreal_orm::Table::from(Self::table_name()))
                .type_(surreal_orm::FieldType::Record(Self::table_name()))
                .to_raw(),
            surreal_orm::statements::define_field(surreal_orm::Field::new("firstName"))
                .on_table(surreal_orm::Table::from(Self::table_name()))
                .type_(surreal_orm::FieldType::String)
                .to_raw(),
            surreal_orm::statements::define_field(surreal_orm::Field::new("lastName"))
                .on_table(surreal_orm::Table::from(Self::table_name()))
                .type_(surreal_orm::FieldType::String)
                .to_raw(),
            surreal_orm::statements::define_field(surreal_orm::Field::new("age"))
                .on_table(surreal_orm::Table::from(Self::table_name()))
                .type_("int".parse::<surreal_orm::FieldType>().expect(
                    "Must have been checked at compile time. If not, this is a bug. Please report",
                ))
                .value(surreal_orm::Value::from((18)))
                .assert((cond(value().is_not(NONE)).and(value().gte(18))))
                .permissions_for((perm()).to_raw())
                .to_raw(),
            surreal_orm::statements::define_field(surreal_orm::Field::new("score"))
                .on_table(surreal_orm::Table::from(Self::table_name()))
                .type_("int".parse::<surreal_orm::FieldType>().expect(
                    "Must have been checked at compile time. If not, this is a bug. Please report",
                ))
                .value(surreal_orm::Value::from((we())))
                .assert((erer()))
                .permissions_for((perm()).to_raw())
                .to_raw(),
            surreal_orm::statements::define_field(surreal_orm::Field::new("bestFriend"))
                .on_table(surreal_orm::Table::from(Self::table_name()))
                .type_("record (student)".parse::<surreal_orm::FieldType>().expect(
                    "Must have been checked at compile time. If not, this is a bug. Please report",
                ))
                .to_raw(),
            surreal_orm::statements::define_field(surreal_orm::Field::new("unoBook"))
                .on_table(surreal_orm::Table::from(Self::table_name()))
                .type_(surreal_orm::FieldType::Record(Book::table_name()))
                .to_raw(),
            surreal_orm::statements::define_field(surreal_orm::Field::new("course"))
                .on_table(surreal_orm::Table::from(Self::table_name()))
                .type_(surreal_orm::FieldType::Record(Book::table_name()))
                .to_raw(),
            surreal_orm::statements::define_field(surreal_orm::Field::new("semesterCourses"))
                .on_table(surreal_orm::Table::from(Self::table_name()))
                .type_("array".parse::<surreal_orm::FieldType>().expect(
                    "Must have been checked at compile time. If not, this is a bug. Please report",
                ))
                .to_raw(),
            surreal_orm::statements::define_field(surreal_orm::Field::new("semesterCourses.*"))
                .on_table(surreal_orm::Table::from(Self::table_name()))
                .type_("record (book)".parse::<surreal_orm::FieldType>().expect(
                    "Must have been checked at compile time. If not, this is a bug. Please report",
                ))
                .to_raw(),
        ]
    }
}
#[allow(non_snake_case)]
pub mod student_schema {
    use super::*;
    use surreal_orm::Buildable as _;
    use surreal_orm::Erroneous as _;
    use surreal_orm::Parametric as _;
    pub struct TableNameStaticChecker {
        pub student: String,
    }
    type Book = <super::Book as surreal_orm::SchemaGetter>::Schema;
    mod _____field_names {
        use super::super::*;
        use surreal_orm::Buildable as _;
        use surreal_orm::Parametric as _;
        #[derive(Debug, Clone)]
        pub struct Id_______________(pub surreal_orm::Field);
        impl From<&str> for Id_______________ {
            fn from(field_name: &str) -> Self {
                Self(surreal_orm::Field::new(field_name))
            }
        }
        impl From<surreal_orm::Field> for Id_______________ {
            fn from(field_name: surreal_orm::Field) -> Self {
                Self(field_name)
            }
        }
        impl From<&Id_______________> for surreal_orm::Valuex {
            fn from(value: &Id_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<Id_______________> for surreal_orm::Valuex {
            fn from(value: Id_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<&Id_______________> for surreal_orm::Field {
            fn from(field_name: &Id_______________) -> Self {
                field_name.0.clone()
            }
        }
        impl From<Id_______________> for surreal_orm::Field {
            fn from(field_name: Id_______________) -> Self {
                field_name.0
            }
        }
        impl ::std::ops::Deref for Id_______________ {
            type Target = surreal_orm::Field;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl ::std::ops::DerefMut for Id_______________ {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<self::Id_______________> for surreal_orm::SetterArg<T> {
            fn from(value: self::Id_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<&self::Id_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: &self::Id_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl surreal_orm::SetterAssignable<surreal_orm::sql::Thing> for self::Id_______________ {}
        impl surreal_orm::Patchable<surreal_orm::sql::Thing> for self::Id_______________ {}
        #[derive(Debug, Clone)]
        pub struct FirstName_______________(pub surreal_orm::Field);
        impl From<&str> for FirstName_______________ {
            fn from(field_name: &str) -> Self {
                Self(surreal_orm::Field::new(field_name))
            }
        }
        impl From<surreal_orm::Field> for FirstName_______________ {
            fn from(field_name: surreal_orm::Field) -> Self {
                Self(field_name)
            }
        }
        impl From<&FirstName_______________> for surreal_orm::Valuex {
            fn from(value: &FirstName_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<FirstName_______________> for surreal_orm::Valuex {
            fn from(value: FirstName_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<&FirstName_______________> for surreal_orm::Field {
            fn from(field_name: &FirstName_______________) -> Self {
                field_name.0.clone()
            }
        }
        impl From<FirstName_______________> for surreal_orm::Field {
            fn from(field_name: FirstName_______________) -> Self {
                field_name.0
            }
        }
        impl ::std::ops::Deref for FirstName_______________ {
            type Target = surreal_orm::Field;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl ::std::ops::DerefMut for FirstName_______________ {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<self::FirstName_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: self::FirstName_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<&self::FirstName_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: &self::FirstName_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl surreal_orm::SetterAssignable<String> for self::FirstName_______________ {}
        impl surreal_orm::Patchable<String> for self::FirstName_______________ {}
        #[derive(Debug, Clone)]
        pub struct LastName_______________(pub surreal_orm::Field);
        impl From<&str> for LastName_______________ {
            fn from(field_name: &str) -> Self {
                Self(surreal_orm::Field::new(field_name))
            }
        }
        impl From<surreal_orm::Field> for LastName_______________ {
            fn from(field_name: surreal_orm::Field) -> Self {
                Self(field_name)
            }
        }
        impl From<&LastName_______________> for surreal_orm::Valuex {
            fn from(value: &LastName_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<LastName_______________> for surreal_orm::Valuex {
            fn from(value: LastName_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<&LastName_______________> for surreal_orm::Field {
            fn from(field_name: &LastName_______________) -> Self {
                field_name.0.clone()
            }
        }
        impl From<LastName_______________> for surreal_orm::Field {
            fn from(field_name: LastName_______________) -> Self {
                field_name.0
            }
        }
        impl ::std::ops::Deref for LastName_______________ {
            type Target = surreal_orm::Field;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl ::std::ops::DerefMut for LastName_______________ {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<self::LastName_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: self::LastName_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<&self::LastName_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: &self::LastName_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl surreal_orm::SetterAssignable<String> for self::LastName_______________ {}
        impl surreal_orm::Patchable<String> for self::LastName_______________ {}
        #[derive(Debug, Clone)]
        pub struct Age_______________(pub surreal_orm::Field);
        impl From<&str> for Age_______________ {
            fn from(field_name: &str) -> Self {
                Self(surreal_orm::Field::new(field_name))
            }
        }
        impl From<surreal_orm::Field> for Age_______________ {
            fn from(field_name: surreal_orm::Field) -> Self {
                Self(field_name)
            }
        }
        impl From<&Age_______________> for surreal_orm::Valuex {
            fn from(value: &Age_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<Age_______________> for surreal_orm::Valuex {
            fn from(value: Age_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<&Age_______________> for surreal_orm::Field {
            fn from(field_name: &Age_______________) -> Self {
                field_name.0.clone()
            }
        }
        impl From<Age_______________> for surreal_orm::Field {
            fn from(field_name: Age_______________) -> Self {
                field_name.0
            }
        }
        impl ::std::ops::Deref for Age_______________ {
            type Target = surreal_orm::Field;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl ::std::ops::DerefMut for Age_______________ {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<self::Age_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: self::Age_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<&self::Age_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: &self::Age_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl surreal_orm::SetterAssignable<u8> for self::Age_______________ {}
        impl surreal_orm::Patchable<u8> for self::Age_______________ {}
        impl surreal_orm::SetterNumeric<u8> for self::Age_______________ {}
        impl From<self::Age_______________> for surreal_orm::NumberLike {
            fn from(val: self::Age_______________) -> Self {
                val.0.into()
            }
        }
        impl From<&self::Age_______________> for surreal_orm::NumberLike {
            fn from(val: &self::Age_______________) -> Self {
                val.clone().0.into()
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Add<T> for Age_______________ {
            type Output = surreal_orm::Operation;
            fn add(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} + {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Sub<T> for Age_______________ {
            type Output = surreal_orm::Operation;
            fn sub(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} - {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Mul<T> for Age_______________ {
            type Output = surreal_orm::Operation;
            fn mul(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} * {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Div<T> for Age_______________ {
            type Output = surreal_orm::Operation;
            fn div(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} / {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Add<T> for &Age_______________ {
            type Output = surreal_orm::Operation;
            fn add(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} + {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Sub<T> for &Age_______________ {
            type Output = surreal_orm::Operation;
            fn sub(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} - {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Mul<T> for &Age_______________ {
            type Output = surreal_orm::Operation;
            fn mul(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} * {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Div<T> for &Age_______________ {
            type Output = surreal_orm::Operation;
            fn div(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} / {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct Score_______________(pub surreal_orm::Field);
        impl From<&str> for Score_______________ {
            fn from(field_name: &str) -> Self {
                Self(surreal_orm::Field::new(field_name))
            }
        }
        impl From<surreal_orm::Field> for Score_______________ {
            fn from(field_name: surreal_orm::Field) -> Self {
                Self(field_name)
            }
        }
        impl From<&Score_______________> for surreal_orm::Valuex {
            fn from(value: &Score_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<Score_______________> for surreal_orm::Valuex {
            fn from(value: Score_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<&Score_______________> for surreal_orm::Field {
            fn from(field_name: &Score_______________) -> Self {
                field_name.0.clone()
            }
        }
        impl From<Score_______________> for surreal_orm::Field {
            fn from(field_name: Score_______________) -> Self {
                field_name.0
            }
        }
        impl ::std::ops::Deref for Score_______________ {
            type Target = surreal_orm::Field;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl ::std::ops::DerefMut for Score_______________ {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<self::Score_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: self::Score_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<&self::Score_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: &self::Score_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl surreal_orm::SetterAssignable<u8> for self::Score_______________ {}
        impl surreal_orm::Patchable<u8> for self::Score_______________ {}
        impl surreal_orm::SetterNumeric<u8> for self::Score_______________ {}
        impl From<self::Score_______________> for surreal_orm::NumberLike {
            fn from(val: self::Score_______________) -> Self {
                val.0.into()
            }
        }
        impl From<&self::Score_______________> for surreal_orm::NumberLike {
            fn from(val: &self::Score_______________) -> Self {
                val.clone().0.into()
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Add<T> for Score_______________ {
            type Output = surreal_orm::Operation;
            fn add(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} + {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Sub<T> for Score_______________ {
            type Output = surreal_orm::Operation;
            fn sub(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} - {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Mul<T> for Score_______________ {
            type Output = surreal_orm::Operation;
            fn mul(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} * {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Div<T> for Score_______________ {
            type Output = surreal_orm::Operation;
            fn div(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} / {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Add<T>
            for &Score_______________
        {
            type Output = surreal_orm::Operation;
            fn add(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} + {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Sub<T>
            for &Score_______________
        {
            type Output = surreal_orm::Operation;
            fn sub(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} - {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Mul<T>
            for &Score_______________
        {
            type Output = surreal_orm::Operation;
            fn mul(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} * {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        impl<T: ::std::convert::Into<surreal_orm::NumberLike>> ::std::ops::Div<T>
            for &Score_______________
        {
            type Output = surreal_orm::Operation;
            fn div(self, rhs: T) -> Self::Output {
                let rhs: surreal_orm::NumberLike = rhs.into();
                surreal_orm::Operation {
                    query_string: format!("{} / {}", self.build(), rhs.build()),
                    bindings: [self.get_bindings(), rhs.get_bindings()].concat(),
                    errors: vec![],
                }
            }
        }
        #[derive(Debug, Clone)]
        pub struct BestFriend_______________(pub surreal_orm::Field);
        impl From<&str> for BestFriend_______________ {
            fn from(field_name: &str) -> Self {
                Self(surreal_orm::Field::new(field_name))
            }
        }
        impl From<surreal_orm::Field> for BestFriend_______________ {
            fn from(field_name: surreal_orm::Field) -> Self {
                Self(field_name)
            }
        }
        impl From<&BestFriend_______________> for surreal_orm::Valuex {
            fn from(value: &BestFriend_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<BestFriend_______________> for surreal_orm::Valuex {
            fn from(value: BestFriend_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<&BestFriend_______________> for surreal_orm::Field {
            fn from(field_name: &BestFriend_______________) -> Self {
                field_name.0.clone()
            }
        }
        impl From<BestFriend_______________> for surreal_orm::Field {
            fn from(field_name: BestFriend_______________) -> Self {
                field_name.0
            }
        }
        impl ::std::ops::Deref for BestFriend_______________ {
            type Target = surreal_orm::Field;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl ::std::ops::DerefMut for BestFriend_______________ {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<self::BestFriend_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: self::BestFriend_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<&self::BestFriend_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: &self::BestFriend_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl surreal_orm::SetterAssignable<LinkSelf<Student>> for self::BestFriend_______________ {}
        impl surreal_orm::Patchable<LinkSelf<Student>> for self::BestFriend_______________ {}
        #[derive(Debug, Clone)]
        pub struct UnoBook_______________(pub surreal_orm::Field);
        impl From<&str> for UnoBook_______________ {
            fn from(field_name: &str) -> Self {
                Self(surreal_orm::Field::new(field_name))
            }
        }
        impl From<surreal_orm::Field> for UnoBook_______________ {
            fn from(field_name: surreal_orm::Field) -> Self {
                Self(field_name)
            }
        }
        impl From<&UnoBook_______________> for surreal_orm::Valuex {
            fn from(value: &UnoBook_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<UnoBook_______________> for surreal_orm::Valuex {
            fn from(value: UnoBook_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<&UnoBook_______________> for surreal_orm::Field {
            fn from(field_name: &UnoBook_______________) -> Self {
                field_name.0.clone()
            }
        }
        impl From<UnoBook_______________> for surreal_orm::Field {
            fn from(field_name: UnoBook_______________) -> Self {
                field_name.0
            }
        }
        impl ::std::ops::Deref for UnoBook_______________ {
            type Target = surreal_orm::Field;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl ::std::ops::DerefMut for UnoBook_______________ {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<self::UnoBook_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: self::UnoBook_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<&self::UnoBook_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: &self::UnoBook_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl surreal_orm::SetterAssignable<LinkOne<Book>> for self::UnoBook_______________ {}
        impl surreal_orm::Patchable<LinkOne<Book>> for self::UnoBook_______________ {}
        #[derive(Debug, Clone)]
        pub struct Course_______________(pub surreal_orm::Field);
        impl From<&str> for Course_______________ {
            fn from(field_name: &str) -> Self {
                Self(surreal_orm::Field::new(field_name))
            }
        }
        impl From<surreal_orm::Field> for Course_______________ {
            fn from(field_name: surreal_orm::Field) -> Self {
                Self(field_name)
            }
        }
        impl From<&Course_______________> for surreal_orm::Valuex {
            fn from(value: &Course_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<Course_______________> for surreal_orm::Valuex {
            fn from(value: Course_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<&Course_______________> for surreal_orm::Field {
            fn from(field_name: &Course_______________) -> Self {
                field_name.0.clone()
            }
        }
        impl From<Course_______________> for surreal_orm::Field {
            fn from(field_name: Course_______________) -> Self {
                field_name.0
            }
        }
        impl ::std::ops::Deref for Course_______________ {
            type Target = surreal_orm::Field;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl ::std::ops::DerefMut for Course_______________ {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<self::Course_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: self::Course_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<&self::Course_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: &self::Course_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl surreal_orm::SetterAssignable<LinkOne<Book>> for self::Course_______________ {}
        impl surreal_orm::Patchable<LinkOne<Book>> for self::Course_______________ {}
        #[derive(Debug, Clone)]
        pub struct SemesterCourses_______________(pub surreal_orm::Field);
        impl From<&str> for SemesterCourses_______________ {
            fn from(field_name: &str) -> Self {
                Self(surreal_orm::Field::new(field_name))
            }
        }
        impl From<surreal_orm::Field> for SemesterCourses_______________ {
            fn from(field_name: surreal_orm::Field) -> Self {
                Self(field_name)
            }
        }
        impl From<&SemesterCourses_______________> for surreal_orm::Valuex {
            fn from(value: &SemesterCourses_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<SemesterCourses_______________> for surreal_orm::Valuex {
            fn from(value: SemesterCourses_______________) -> Self {
                let field: surreal_orm::Field = value.into();
                field.into()
            }
        }
        impl From<&SemesterCourses_______________> for surreal_orm::Field {
            fn from(field_name: &SemesterCourses_______________) -> Self {
                field_name.0.clone()
            }
        }
        impl From<SemesterCourses_______________> for surreal_orm::Field {
            fn from(field_name: SemesterCourses_______________) -> Self {
                field_name.0
            }
        }
        impl ::std::ops::Deref for SemesterCourses_______________ {
            type Target = surreal_orm::Field;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl ::std::ops::DerefMut for SemesterCourses_______________ {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<self::SemesterCourses_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: self::SemesterCourses_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl<T: surreal_orm::serde::Serialize> From<&self::SemesterCourses_______________>
            for surreal_orm::SetterArg<T>
        {
            fn from(value: &self::SemesterCourses_______________) -> Self {
                Self::Field(value.into())
            }
        }
        impl surreal_orm::SetterAssignable<LinkMany<Book>> for self::SemesterCourses_______________ {}
        impl surreal_orm::Patchable<LinkMany<Book>> for self::SemesterCourses_______________ {}
        impl surreal_orm::SetterArray<<Book as surreal_orm::Model>::Id>
            for self::SemesterCourses_______________
        {
        }
    }
    #[allow(non_snake_case)]
    #[derive(Debug, Clone)]
    pub struct Student {
        pub id: _____field_names::Id_______________,
        pub firstName: _____field_names::FirstName_______________,
        pub lastName: _____field_names::LastName_______________,
        pub age: _____field_names::Age_______________,
        pub score: _____field_names::Score_______________,
        pub bestFriend: _____field_names::BestFriend_______________,
        pub unoBook: _____field_names::UnoBook_______________,
        pub course: _____field_names::Course_______________,
        pub semesterCourses: _____field_names::SemesterCourses_______________,
        ___________graph_traversal_string: ::std::string::String,
        ___________bindings: surreal_orm::BindingsList,
        ___________errors: Vec<String>,
    }
    #[derive(Debug, Clone)]
    pub struct StudentAliases {
        pub writtenBooks: surreal_orm::AliasName,
        pub blogsssss: surreal_orm::AliasName,
    }
    impl StudentAliases {
        pub fn new() -> Self {
            Self {
                writtenBooks: "writtenBooks".into(),
                blogsssss: "blogsssss".into(),
            }
        }
    }
    impl surreal_orm::Aliasable for Student {}
    impl From<Student> for surreal_orm::Valuex {
        fn from(node: Student) -> Self {
            Self::new(node)
        }
    }
    impl surreal_orm::Parametric for Student {
        fn get_bindings(&self) -> surreal_orm::BindingsList {
            self.___________bindings.to_vec()
        }
    }
    impl surreal_orm::Buildable for Student {
        fn build(&self) -> ::std::string::String {
            self.___________graph_traversal_string.to_string()
        }
    }
    impl surreal_orm::Erroneous for Student {
        fn get_errors(&self) -> Vec<String> {
            self.___________errors.to_vec()
        }
    }
    impl ::std::fmt::Display for Student {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.write_fmt(format_args!("{}", self.___________graph_traversal_string))
        }
    }
    impl surreal_orm::Aliasable for &Student {}
    impl surreal_orm::Parametric for &Student {
        fn get_bindings(&self) -> surreal_orm::BindingsList {
            self.___________bindings.to_vec()
        }
    }
    impl surreal_orm::Buildable for &Student {
        fn build(&self) -> ::std::string::String {
            self.___________graph_traversal_string.to_string()
        }
    }
    impl surreal_orm::Erroneous for &Student {
        fn get_errors(&self) -> Vec<String> {
            self.___________errors.to_vec()
        }
    }
    impl Student {
        pub fn new() -> Self {
            Self {
                id: "id".into(),
                firstName: "firstName".into(),
                lastName: "lastName".into(),
                age: "age".into(),
                score: "score".into(),
                bestFriend: "bestFriend".into(),
                unoBook: "unoBook".into(),
                course: "course".into(),
                semesterCourses: "semesterCourses".into(),
                ___________graph_traversal_string: "".into(),
                ___________bindings: vec![],
                ___________errors: vec![],
            }
        }
        pub fn new_prefixed(prefix: impl ::std::convert::Into<surreal_orm::Valuex>) -> Self {
            let prefix: surreal_orm::Valuex = prefix.into();
            Self {
                id: surreal_orm::Field::new(format!("{}.{}", prefix.build(), "id"))
                    .with_bindings(prefix.get_bindings())
                    .into(),
                firstName: surreal_orm::Field::new(format!("{}.{}", prefix.build(), "firstName"))
                    .with_bindings(prefix.get_bindings())
                    .into(),
                lastName: surreal_orm::Field::new(format!("{}.{}", prefix.build(), "lastName"))
                    .with_bindings(prefix.get_bindings())
                    .into(),
                age: surreal_orm::Field::new(format!("{}.{}", prefix.build(), "age"))
                    .with_bindings(prefix.get_bindings())
                    .into(),
                score: surreal_orm::Field::new(format!("{}.{}", prefix.build(), "score"))
                    .with_bindings(prefix.get_bindings())
                    .into(),
                bestFriend: surreal_orm::Field::new(format!("{}.{}", prefix.build(), "bestFriend"))
                    .with_bindings(prefix.get_bindings())
                    .into(),
                unoBook: surreal_orm::Field::new(format!("{}.{}", prefix.build(), "unoBook"))
                    .with_bindings(prefix.get_bindings())
                    .into(),
                course: surreal_orm::Field::new(format!("{}.{}", prefix.build(), "course"))
                    .with_bindings(prefix.get_bindings())
                    .into(),
                semesterCourses: surreal_orm::Field::new(format!(
                    "{}.{}",
                    prefix.build(),
                    "semesterCourses"
                ))
                .with_bindings(prefix.get_bindings())
                .into(),
                ___________graph_traversal_string: prefix.build(),
                ___________bindings: prefix.get_bindings(),
                ___________errors: vec![],
            }
        }
        pub fn empty() -> Self {
            Self {
                id: "".into(),
                firstName: "".into(),
                lastName: "".into(),
                age: "".into(),
                score: "".into(),
                bestFriend: "".into(),
                unoBook: "".into(),
                course: "".into(),
                semesterCourses: "".into(),
                ___________graph_traversal_string: "".into(),
                ___________bindings: vec![],
                ___________errors: vec![],
            }
        }
        pub fn __________connect_node_to_graph_traversal_string(
            connection: impl surreal_orm::Buildable + surreal_orm::Parametric + surreal_orm::Erroneous,
            clause: impl Into<surreal_orm::NodeClause>,
        ) -> Self {
            let mut schema_instance = Self::new();
            let clause: surreal_orm::NodeClause = clause.into();
            let bindings = [
                connection.get_bindings().as_slice(),
                clause.get_bindings().as_slice(),
            ]
            .concat();
            let bindings = bindings.as_slice();
            schema_instance.___________bindings = bindings.into();
            let errors = [
                connection.get_errors().as_slice(),
                clause.get_errors().as_slice(),
            ]
            .concat();
            let errors = errors.as_slice();
            schema_instance.___________errors = errors.into();
            let connection_str = format!("{}{}", connection.build(), clause.build());
            schema_instance
                .___________graph_traversal_string
                .push_str(connection_str.as_str());
            let ___________graph_traversal_string =
                &schema_instance.___________graph_traversal_string;
            schema_instance.id = schema_instance
                .id
                .set_graph_string(format!("{}.{}", ___________graph_traversal_string, "id"))
                .____________update_many_bindings(bindings)
                .into();
            schema_instance.firstName = schema_instance
                .firstName
                .set_graph_string(format!(
                    "{}.{}",
                    ___________graph_traversal_string, "firstName"
                ))
                .____________update_many_bindings(bindings)
                .into();
            schema_instance.lastName = schema_instance
                .lastName
                .set_graph_string(format!(
                    "{}.{}",
                    ___________graph_traversal_string, "lastName"
                ))
                .____________update_many_bindings(bindings)
                .into();
            schema_instance.age = schema_instance
                .age
                .set_graph_string(format!("{}.{}", ___________graph_traversal_string, "age"))
                .____________update_many_bindings(bindings)
                .into();
            schema_instance.score = schema_instance
                .score
                .set_graph_string(format!("{}.{}", ___________graph_traversal_string, "score"))
                .____________update_many_bindings(bindings)
                .into();
            schema_instance.bestFriend = schema_instance
                .bestFriend
                .set_graph_string(format!(
                    "{}.{}",
                    ___________graph_traversal_string, "bestFriend"
                ))
                .____________update_many_bindings(bindings)
                .into();
            schema_instance.unoBook = schema_instance
                .unoBook
                .set_graph_string(format!(
                    "{}.{}",
                    ___________graph_traversal_string, "unoBook"
                ))
                .____________update_many_bindings(bindings)
                .into();
            schema_instance.course = schema_instance
                .course
                .set_graph_string(format!(
                    "{}.{}",
                    ___________graph_traversal_string, "course"
                ))
                .____________update_many_bindings(bindings)
                .into();
            schema_instance.semesterCourses = schema_instance
                .semesterCourses
                .set_graph_string(format!(
                    "{}.{}",
                    ___________graph_traversal_string, "semesterCourses"
                ))
                .____________update_many_bindings(bindings)
                .into();
            schema_instance
        }
        pub fn bestFriend(&self) -> Student {
            let clause = surreal_orm::Clause::from(surreal_orm::Empty);
            let normalized_field_name_str = if self.build().is_empty() {
                "bestFriend".to_string()
            } else {
                format!(".{}", "bestFriend")
            };
            Student::__________connect_node_to_graph_traversal_string(
                self,
                clause.with_field(normalized_field_name_str),
            )
        }
        pub fn unoBook(&self) -> Book {
            let clause = surreal_orm::Clause::from(surreal_orm::Empty);
            let normalized_field_name_str = if self.build().is_empty() {
                "unoBook".to_string()
            } else {
                format!(".{}", "unoBook")
            };
            Book::__________connect_node_to_graph_traversal_string(
                self,
                clause.with_field(normalized_field_name_str),
            )
        }
        pub fn course(&self) -> Book {
            let clause = surreal_orm::Clause::from(surreal_orm::Empty);
            let normalized_field_name_str = if self.build().is_empty() {
                "course".to_string()
            } else {
                format!(".{}", "course")
            };
            Book::__________connect_node_to_graph_traversal_string(
                self,
                clause.with_field(normalized_field_name_str),
            )
        }
        pub fn semesterCourses(&self, clause: impl Into<surreal_orm::NodeAliasClause>) -> Book {
            let clause: surreal_orm::NodeAliasClause = clause.into();
            let clause: surreal_orm::NodeClause = clause.into_inner();
            let normalized_field_name_str = if self.build().is_empty() {
                "semesterCourses".to_string()
            } else {
                format!(".{}", "semesterCourses")
            };
            Book::__________connect_node_to_graph_traversal_string(
                self,
                clause.with_field(normalized_field_name_str),
            )
        }
    }
    use super::StudentWritesBlog;
    use super::StudentWritesBook;
    impl Student {
        pub fn writes__(
            &self,
            clause: impl Into<surreal_orm::EdgeClause>,
        ) -> writes___schema________________::Writes__ {
            let clause: surreal_orm::EdgeClause = clause.into();
            let clause = clause.with_arrow("->").with_table("writes");
            writes___schema________________::Writes::__________connect_edge_to_graph_traversal_string(self,clause,).into()
        }
    }
    mod writes___schema________________ {
        use super::StudentWritesBlog;
        use super::StudentWritesBook;
        use surreal_orm::Buildable as _;
        use surreal_orm::Erroneous as _;
        use surreal_orm::Parametric as _;
        type ______________BookModel = <super::super::StudentWritesBook as surreal_orm::Edge>::Out;
        type Book = <______________BookModel as surreal_orm::SchemaGetter>::Schema;
        type ______________BlogModel = <super::super::StudentWritesBlog as surreal_orm::Edge>::Out;
        type Blog = <______________BlogModel as surreal_orm::SchemaGetter>::Schema;
        pub type Writes = <super::super::StudentWritesBook as surreal_orm::SchemaGetter>::Schema;
        pub struct Writes__(Writes);
        impl From<Writes> for Writes__ {
            fn from(value: Writes) -> Self {
                Self(value)
            }
        }
        impl surreal_orm::Buildable for Writes__ {
            fn build(&self) -> ::std::string::String {
                self.0.build()
            }
        }
        impl surreal_orm::Parametric for Writes__ {
            fn get_bindings(&self) -> surreal_orm::BindingsList {
                self.0.get_bindings()
            }
        }
        impl surreal_orm::Erroneous for Writes__ {
            fn get_errors(&self) -> Vec<::std::string::String> {
                self.0.get_errors()
            }
        }
        impl surreal_orm::Buildable for &Writes__ {
            fn build(&self) -> ::std::string::String {
                self.0.build()
            }
        }
        impl surreal_orm::Parametric for &Writes__ {
            fn get_bindings(&self) -> surreal_orm::BindingsList {
                self.0.get_bindings()
            }
        }
        impl surreal_orm::Erroneous for &Writes__ {
            fn get_errors(&self) -> Vec<::std::string::String> {
                self.0.get_errors()
            }
        }
        impl ::std::ops::Deref for Writes__ {
            type Target = Writes;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl Writes__ {
            pub fn book(self, clause: impl Into<surreal_orm::NodeClause>) -> Book {
                let clause: surreal_orm::NodeClause = clause.into();
                let clause = clause.with_arrow("->").with_table("book");
                Book::__________connect_node_to_graph_traversal_string(self, clause)
            }
            pub fn blog(self, clause: impl Into<surreal_orm::NodeClause>) -> Blog {
                let clause: surreal_orm::NodeClause = clause.into();
                let clause = clause.with_arrow("->").with_table("blog");
                Blog::__________connect_node_to_graph_traversal_string(self, clause)
            }
            pub fn writes__(&self, clause: impl Into<surreal_orm::EdgeClause>) -> Writes__ {
                let clause: surreal_orm::EdgeClause = clause.into();
                let clause = clause.with_arrow("->").with_table("writes");
                Writes::__________connect_edge_to_graph_traversal_string(self, clause).into()
            }
        }
    }
}
#[test]
fn test_student_schema_edge_name() {
    ::static_assertions::assert_impl_one!(String: ::std::convert::Into<surreal_orm::sql::Strand>);
    ::static_assertions::assert_impl_one!(String: ::std::convert::Into<surreal_orm::sql::Strand>);
    surreal_orm::validators::is_int::<u8>();
    surreal_orm::validators::is_int::<u8>();
    ::static_assertions::assert_type_eq_all!(LinkSelf<Student>, surreal_orm::LinkSelf<Student>);
    ::static_assertions::assert_impl_one!(Student:surreal_orm::Node);
    type IbestFriendRefChecker = <Student as surreal_orm::Node>::TableNameChecker;
    ::static_assertions::assert_fields!(IbestFriendRefChecker:student);
    ::static_assertions::assert_impl_one!(LinkSelf<Student> : ::std::convert::Into<Option<surreal_orm::sql::Thing>>);
    ::static_assertions::assert_type_eq_all!(LinkOne<Book>, surreal_orm::LinkOne<Book>);
    ::static_assertions::assert_impl_one!(Book:surreal_orm::Node);
    ::static_assertions::assert_type_eq_all!(LinkOne<Book>, surreal_orm::LinkOne<Book>);
    ::static_assertions::assert_impl_one!(Book:surreal_orm::Node);
    ::static_assertions::assert_type_eq_all!(LinkMany<Book>, surreal_orm::LinkMany<Book>);
    ::static_assertions::assert_impl_one!(Book:surreal_orm::Node);
    type IsemesterCoursesRefChecker = <Book as surreal_orm::Node>::TableNameChecker;
    ::static_assertions::assert_fields!(IsemesterCoursesRefChecker:book);
    surreal_orm::validators::assert_is_vec::<LinkMany<Book>>();
    type StudentWritesBookHomeNode = <StudentWritesBook as surreal_orm::Edge>::In;
    type StudentWritesBookHomeNodeTableNameChecker =
        <StudentWritesBookHomeNode as surreal_orm::Node>::TableNameChecker;
    ::static_assertions::assert_type_eq_all!(StudentWritesBookHomeNode, Student);
    ::static_assertions::assert_impl_one!(StudentWritesBookHomeNode:surreal_orm::Node);
    type StudentWritesBookForeignNode = <StudentWritesBook as surreal_orm::Edge>::Out;
    type StudentWritesBookForeignNodeTableNameChecker =
        <StudentWritesBookForeignNode as surreal_orm::Node>::TableNameChecker;
    ::static_assertions::assert_fields!(StudentWritesBookForeignNodeTableNameChecker:book);
    ::static_assertions::assert_impl_one!(StudentWritesBookForeignNode:surreal_orm::Node);
    type StudentWritesBookEdgeTableNameChecker =
        <StudentWritesBook as surreal_orm::Edge>::TableNameChecker;
    ::static_assertions::assert_fields!(StudentWritesBookEdgeTableNameChecker:writes);
    ::static_assertions::assert_impl_one!(StudentWritesBook:surreal_orm::Edge);
    ::static_assertions::assert_type_eq_all!(
        Relate<Book>,
        surreal_orm::Relate<StudentWritesBookForeignNode>
    );
    type StudentWritesBlogHomeNode = <StudentWritesBlog as surreal_orm::Edge>::In;
    type StudentWritesBlogHomeNodeTableNameChecker =
        <StudentWritesBlogHomeNode as surreal_orm::Node>::TableNameChecker;
    ::static_assertions::assert_type_eq_all!(StudentWritesBlogHomeNode, Student);
    ::static_assertions::assert_impl_one!(StudentWritesBlogHomeNode:surreal_orm::Node);
    type StudentWritesBlogForeignNode = <StudentWritesBlog as surreal_orm::Edge>::Out;
    type StudentWritesBlogForeignNodeTableNameChecker =
        <StudentWritesBlogForeignNode as surreal_orm::Node>::TableNameChecker;
    ::static_assertions::assert_fields!(StudentWritesBlogForeignNodeTableNameChecker:blog);
    ::static_assertions::assert_impl_one!(StudentWritesBlogForeignNode:surreal_orm::Node);
    type StudentWritesBlogEdgeTableNameChecker =
        <StudentWritesBlog as surreal_orm::Edge>::TableNameChecker;
    ::static_assertions::assert_fields!(StudentWritesBlogEdgeTableNameChecker:writes);
    ::static_assertions::assert_impl_one!(StudentWritesBlog:surreal_orm::Edge);
    ::static_assertions::assert_type_eq_all!(
        Relate<Blog>,
        surreal_orm::Relate<StudentWritesBlogForeignNode>
    );
}

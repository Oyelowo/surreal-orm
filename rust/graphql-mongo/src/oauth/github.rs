use anyhow::{Context, Ok};
use bson::DateTime;
use chrono::{Duration, Utc};

use common::sum;
use oauth2::{
    basic::{BasicClient, BasicTokenType},
    AuthUrl, AuthorizationCode, ClientId, ClientSecret, CsrfToken, EmptyExtraTokenFields,
    RedirectUrl, Scope, StandardTokenResponse, TokenResponse, TokenUrl,
};
use serde::{Deserialize, Serialize};
use url::Url;

use crate::app::user::{AccountOauth, OauthProvider, Role, TokenType, User};

#[derive(Debug, Deserialize, Serialize)]
enum GithubScopes {
    #[serde(rename = "public_repo")]
    PublicRepo,
    #[serde(rename = "user:email")]
    UserEmail,
}

#[derive(Debug, Deserialize, Serialize)]
struct RemoteOauthDataGithub {
    login: String,
    id: String,
    node_id: String,
    avatar_url: String,
    gravatar_id: String,
    url: String,
    html_url: String,
    followers_url: String,
    following_url: String,
    gists_url: String,
    starred_url: String,
    subscriptions_url: String,
    organizations_url: String,
    repos_url: String,
    events_url: String,
    received_events_url: String,

    #[serde(rename = "type")]
    account_type: String,
    site_admin: String,
    name: String,
    company: String,
    blog: String,
    location: String,
    email: Option<String>,
    hireable: String,
    bio: String,
    twitter_username: String,
    public_repos: String,
    public_gists: String,
    followers: String,
    following: String,
    created_at: String,
    updated_at: String,
}

enum ProviderType {
    Credentials,
}

// impl From<RemoteOauthDataGithub> for ProfileOauth {
//     fn from(remote: RemoteOauthDataGithub) -> Self {
//         let mut remote_name = remote.name.split("");
//         let first_name = remote_name.next().map(String::from);
//         let last_name = remote_name.next().map(String::from);

//         //  let mut rng = rand::thread_rng();
//         let autogenerated_id = uuid::Uuid::new_v4().to_string();
//         Self {
//             // id
//             // scopes
//             first_name,
//             last_name,
//             username: format!("{}-{autogenerated_id}", remote.login),
//             email: remote.email,
//             email_verified: false,
//         }
//     }
// }

// TODO: Account linking
// Linking Accounts to Users happen automatically, only when they have the same e-mail address, and the user is currently signed in. Check the FAQ for more information why this is a requirement.

struct RemoteOauth {
    token: StandardTokenResponse<EmptyExtraTokenFields, BasicTokenType>,
    profile: RemoteOauthDataGithub,
}

/*
#[derive(thiserror::Error)]
enum OauthError {
    #[error("Failed to map time failed.")]
    TimeOutOfRangeError(#[source] anyhow::Error),
}
*/

impl From<RemoteOauth> for User {
    // type Error = anyhow::Error;

    // fn try_from(remote: RemoteOauth) -> Result<Self, Self::Error> {
    fn from(remote: RemoteOauth) -> Self {
        let RemoteOauth { token, profile } = remote;

        let expiration = token.expires_in().unwrap_or(std::time::Duration::new(0, 0));
        let expiration = Duration::from_std(expiration).unwrap_or(Duration::seconds(0));

        let expires_at = Utc::now() + expiration;

        let scopes = token.scopes().map(|s| {
            s.iter()
                .map(|comma_separated| comma_separated.split(','))
                .flatten()
                .map(String::from)
                .collect::<Vec<_>>()
        });

        let account = AccountOauth::builder()
            .account_type(profile.account_type)
            .provider(OauthProvider::Github)
            .id(profile.name.clone())
            .provider_account_id(OauthProvider::Github)
            .access_token(token.access_token().secret().into())
            .refresh_token(token.refresh_token().map(|rf| rf.secret().into()))
            .expires_at(Some(expires_at))
            .token_type(Some(TokenType::Bearer))
            .scope(scopes)
            .build();

        let mut remote_name = profile.name.split("");
        let first_name = remote_name.next().map(String::from);
        let last_name = remote_name.next().map(String::from);
        let autogenerated_id = uuid::Uuid::new_v4().to_string();
        Self::builder()
            .username(format!("{}-{autogenerated_id}", profile.name))
            .first_name(first_name)
            .last_name(last_name)
            .email(profile.email)
            .roles(vec![Role::User])
            .accounts(vec![account])
            .age(None)
            .password(None)
            .build()
    }
}

struct Name {}
trait OauthProviderTrait {
    // type Confr;

    fn client(self) -> BasicClient;

    /// Generate the authorization URL to which we'll redirect the user.
    fn generate_auth_url(self) -> AuthUrlData;
}

const REDIRECT_URL: &str = "http://localhost:8080";

pub struct TypedAuthUrl(Url);

impl TypedAuthUrl {
    pub fn get_authorization_code(&self) -> AuthorizationCode {
        let value = self.get_query_param_value("code");
        AuthorizationCode::new(value.into_owned())
    }

    pub fn get_csrf_state(&self) -> CsrfToken {
        let value = self.get_query_param_value("state");
        CsrfToken::new(value.into_owned())
    }

    fn get_query_param_value(&self, query_param: &str) -> std::borrow::Cow<str> {
        let state_pair = self
            .0
            .query_pairs()
            .find(|pair| {
                let &(ref key, _) = pair;
                key == query_param
            })
            .expect("Not found. TODO: Handle error properly later");
        let (_, value) = state_pair;
        value
    }
}

#[derive(Debug, Clone)]
struct OauthConfig {
    client_id: ClientId,
    client_secret: ClientSecret,
    auth_url: AuthUrl,
    token_url: TokenUrl,
    scopes: Vec<Scope>,
}

#[derive(Debug, Clone)]
struct GithubConfig {
    basic_config: OauthConfig,
}

impl GithubConfig {
    pub fn new() -> Self {
        let basic_config = OauthConfig {
            // Get first two from environment variable
            client_id: ClientId::new("57d332c258954615aac7".to_string()),
            client_secret: ClientSecret::new("e41a1fb86af01532fe640a2d79ad6608c3774261".into()),
            auth_url: AuthUrl::new("https://github.com/login/oauth/authorize".to_string())
                .expect("Invalid authorization endpoint URL"),
            token_url: TokenUrl::new("https://github.com/login/oauth/access_token".to_string())
                .expect("Invalid token endpoint URL"),
            scopes: vec![
                Scope::new("public_repo".into()),
                Scope::new("read:user".into()),
            ],
        };
        Self { basic_config }
    }
}

#[derive(Debug, Clone)]
struct AuthUrlData {
    authorize_url: Url,
    csrf_state: CsrfToken,
}
impl OauthProviderTrait for GithubConfig {
    fn client(self) -> BasicClient {
        BasicClient::new(
            self.basic_config.client_id,
            Some(self.basic_config.client_secret),
            self.basic_config.auth_url,
            Some(self.basic_config.token_url),
        )
        // This example will be running its own server at localhost:8080.
        // See below for the server implementation.
        .set_redirect_uri(
            RedirectUrl::new("http://localhost:8080".to_string()).expect("Invalid redirect URL"),
        )
    }

    /// Generate the authorization URL to which we'll redirect the user.
    fn generate_auth_url(self) -> AuthUrlData {
        // let c = self;
        let (authorize_url, csrf_state) = self
            .clone()
            .client()
            .authorize_url(CsrfToken::new_random)
            // This example is requesting access to the user's public repos and email.
            // .add_scope(Scope::new("public_repo".to_string()))
            // .add_scope(Scope::new("read:user".to_string()))
            // .add_scope(Scope::new("user:email".to_string()))
            .add_scopes(self.basic_config.scopes)
            .url();
        AuthUrlData {
            authorize_url,
            csrf_state,
        }
    }
}

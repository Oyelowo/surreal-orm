// Don't Edit. This is autogenerated.
export interface IHarborHarbor {
    expose: Expose;
    externalURL: string;
    internalTLS: InternalTLS;
    ipFamily: IpFamily;
    persistence: Persistence;
    imagePullPolicy: string;
    imagePullSecrets?: any;
    updateStrategy: UpdateStrategy;
    logLevel: string;
    harborAdminPassword: string;
    caSecretName: string;
    secretKey: string;
    existingSecretSecretKey: string;
    proxy: Proxy;
    enableMigrateHelmHook: boolean;
    nginx: Nginx;
    portal: Nginx;
    core: Core2;
    jobservice: Jobservice2;
    registry: Registry3;
    chartmuseum: Chartmuseum;
    trivy: Trivy;
    notary: Notary2;
    database: Database;
    redis: Redis;
    exporter: Exporter;
    metrics: Metrics;
    trace: Trace;
    cache: Cache;
}
interface Cache {
    enabled: boolean;
    expireHours: number;
}
interface Trace {
    enabled: boolean;
    provider: string;
    sample_rate: number;
    jaeger: Jaeger;
    otel: Otel;
}
interface Otel {
    endpoint: string;
    url_path: string;
    compression: boolean;
    insecure: boolean;
    timeout: string;
}
interface Jaeger {
    endpoint: string;
}
interface Metrics {
    enabled: boolean;
    core: Core3;
    registry: Core3;
    jobservice: Core3;
    exporter: Core3;
    serviceMonitor: ServiceMonitor;
}
interface ServiceMonitor {
    enabled: boolean;
    additionalLabels: Annotations2;
    interval: string;
    metricRelabelings: any[];
    relabelings: any[];
}
interface Core3 {
    path: string;
    port: number;
}
interface Exporter {
    replicas: number;
    revisionHistoryLimit: number;
    podAnnotations: Annotations2;
    serviceAccountName: string;
    automountServiceAccountToken: boolean;
    image: Image;
    nodeSelector: Annotations2;
    tolerations: any[];
    affinity: Annotations2;
    cacheDuration: number;
    cacheCleanInterval: number;
    priorityClassName?: any;
}
interface Redis {
    type: string;
    internal: Internal2;
    external: External2;
    podAnnotations: Annotations2;
}
interface External2 {
    addr: string;
    sentinelMasterSet: string;
    coreDatabaseIndex: string;
    jobserviceDatabaseIndex: string;
    registryDatabaseIndex: string;
    chartmuseumDatabaseIndex: string;
    trivyAdapterIndex: string;
    password: string;
    existingSecret: string;
}
interface Internal2 {
    serviceAccountName: string;
    automountServiceAccountToken: boolean;
    image: Image;
    nodeSelector: Annotations2;
    tolerations: any[];
    affinity: Annotations2;
    priorityClassName?: any;
}
interface Database {
    type: string;
    internal: Internal;
    external: External;
    maxIdleConns: number;
    maxOpenConns: number;
    podAnnotations: Annotations2;
}
interface External {
    host: string;
    port: string;
    username: string;
    password: string;
    coreDatabase: string;
    notaryServerDatabase: string;
    notarySignerDatabase: string;
    existingSecret: string;
    sslmode: string;
}
interface Internal {
    serviceAccountName: string;
    automountServiceAccountToken: boolean;
    image: Image;
    password: string;
    shmSizeLimit: string;
    nodeSelector: Annotations2;
    tolerations: any[];
    affinity: Annotations2;
    priorityClassName?: any;
    initContainer: InitContainer;
}
interface InitContainer {
    migrator: Annotations2;
    permissions: Annotations2;
}
interface Notary2 {
    enabled: boolean;
    server: Server;
    signer: Server;
    secretName: string;
}
interface Server {
    serviceAccountName: string;
    automountServiceAccountToken: boolean;
    image: Image;
    replicas: number;
    nodeSelector: Annotations2;
    tolerations: any[];
    affinity: Annotations2;
    podAnnotations: Annotations2;
    priorityClassName?: any;
}
interface Trivy {
    enabled: boolean;
    image: Image;
    serviceAccountName: string;
    automountServiceAccountToken: boolean;
    replicas: number;
    debugMode: boolean;
    vulnType: string;
    severity: string;
    ignoreUnfixed: boolean;
    insecure: boolean;
    gitHubToken: string;
    skipUpdate: boolean;
    offlineScan: boolean;
    timeout: string;
    resources: Resources;
    nodeSelector: Annotations2;
    tolerations: any[];
    affinity: Annotations2;
    podAnnotations: Annotations2;
    priorityClassName?: any;
}
interface Resources {
    requests: Requests;
    limits: Limits;
}
interface Limits {
    cpu: number;
    memory: string;
}
interface Requests {
    cpu: string;
    memory: string;
}
interface Chartmuseum {
    enabled: boolean;
    serviceAccountName: string;
    automountServiceAccountToken: boolean;
    absoluteUrl: boolean;
    image: Image;
    replicas: number;
    revisionHistoryLimit: number;
    nodeSelector: Annotations2;
    tolerations: any[];
    affinity: Annotations2;
    podAnnotations: Annotations2;
    priorityClassName?: any;
    indexLimit: number;
}
interface Registry3 {
    serviceAccountName: string;
    automountServiceAccountToken: boolean;
    registry: Registry2;
    controller: Registry2;
    replicas: number;
    revisionHistoryLimit: number;
    nodeSelector: Annotations2;
    tolerations: any[];
    affinity: Annotations2;
    podAnnotations: Annotations2;
    priorityClassName?: any;
    secret: string;
    relativeurls: boolean;
    credentials: Credentials;
    middleware: Middleware;
    upload_purging: Uploadpurging;
}
interface Uploadpurging {
    enabled: boolean;
    age: string;
    interval: string;
    dryrun: boolean;
}
interface Middleware {
    enabled: boolean;
    type: string;
    cloudFront: CloudFront;
}
interface CloudFront {
    baseurl: string;
    keypairid: string;
    duration: string;
    ipfilteredby: string;
    privateKeySecret: string;
}
interface Credentials {
    username: string;
    password: string;
    existingSecret: string;
}
interface Registry2 {
    image: Image;
}
interface Jobservice2 {
    image: Image;
    replicas: number;
    revisionHistoryLimit: number;
    serviceAccountName: string;
    automountServiceAccountToken: boolean;
    maxJobWorkers: number;
    jobLoggers: string[];
    loggerSweeperDuration: number;
    nodeSelector: Annotations2;
    tolerations: any[];
    affinity: Annotations2;
    podAnnotations: Annotations2;
    secret: string;
    priorityClassName?: any;
}
interface Core2 {
    image: Image;
    serviceAccountName: string;
    automountServiceAccountToken: boolean;
    replicas: number;
    revisionHistoryLimit: number;
    startupProbe: StartupProbe;
    nodeSelector: Annotations2;
    tolerations: any[];
    affinity: Annotations2;
    podAnnotations: Annotations2;
    secret: string;
    secretName: string;
    xsrfKey: string;
    priorityClassName?: any;
    artifactPullAsyncFlushDuration?: any;
    gdpr: Gdpr;
}
interface Gdpr {
    deleteUser: boolean;
}
interface StartupProbe {
    enabled: boolean;
    initialDelaySeconds: number;
}
interface Nginx {
    image: Image;
    serviceAccountName: string;
    automountServiceAccountToken: boolean;
    replicas: number;
    revisionHistoryLimit: number;
    nodeSelector: Annotations2;
    tolerations: any[];
    affinity: Annotations2;
    podAnnotations: Annotations2;
    priorityClassName?: any;
}
interface Image {
    repository: string;
    tag: string;
}
interface Proxy {
    httpProxy?: any;
    httpsProxy?: any;
    noProxy: string;
    components: string[];
}
interface UpdateStrategy {
    type: string;
}
interface Persistence {
    enabled: boolean;
    resourcePolicy: string;
    persistentVolumeClaim: PersistentVolumeClaim;
    imageChartStorage: ImageChartStorage;
}
interface ImageChartStorage {
    disableredirect: boolean;
    type: string;
    filesystem: Filesystem;
    azure: Azure;
    gcs: Gcs;
    s3: S3;
    swift: Swift;
    oss: Oss;
}
interface Oss {
    accesskeyid: string;
    accesskeysecret: string;
    region: string;
    bucket: string;
}
interface Swift {
    authurl: string;
    username: string;
    password: string;
    container: string;
}
interface S3 {
    region: string;
    bucket: string;
}
interface Gcs {
    bucket: string;
    encodedkey: string;
    existingSecret: string;
    useWorkloadIdentity: boolean;
}
interface Azure {
    accountname: string;
    accountkey: string;
    container: string;
    existingSecret: string;
}
interface Filesystem {
    rootdirectory: string;
}
interface PersistentVolumeClaim {
    registry: Registry;
    chartmuseum: Registry;
    jobservice: Jobservice;
    database: Registry;
    redis: Registry;
    trivy: Registry;
}
interface Jobservice {
    jobLog: Registry;
    scanDataExports: Registry;
}
interface Registry {
    existingClaim: string;
    storageClass: string;
    subPath: string;
    accessMode: string;
    size: string;
    annotations: Annotations2;
}
interface IpFamily {
    ipv6: Ipv6;
    ipv4: Ipv6;
}
interface Ipv6 {
    enabled: boolean;
}
interface InternalTLS {
    enabled: boolean;
    certSource: string;
    trustCa: string;
    core: Core;
    jobservice: Core;
    registry: Core;
    portal: Core;
    chartmuseum: Core;
    trivy: Core;
}
interface Core {
    secretName: string;
    crt: string;
    key: string;
}
interface Expose {
    type: string;
    tls: Tls;
    ingress: Ingress;
    clusterIP: ClusterIP;
    nodePort: NodePort;
    loadBalancer: LoadBalancer;
}
interface LoadBalancer {
    name: string;
    IP: string;
    ports: Ports;
    annotations: Annotations2;
    sourceRanges: any[];
}
interface NodePort {
    name: string;
    ports: Ports2;
}
interface Ports2 {
    http: Http;
    https: Http;
    notary: Http;
}
interface Http {
    port: number;
    nodePort: number;
}
interface ClusterIP {
    name: string;
    annotations: Annotations2;
    ports: Ports;
}
interface Ports {
    httpPort: number;
    httpsPort: number;
    notaryPort: number;
}
interface Ingress {
    hosts: Hosts;
    controller: string;
    kubeVersionOverride: string;
    className: string;
    annotations: Annotations;
    notary: Notary;
    harbor: Notary;
}
interface Notary {
    annotations: Annotations2;
    labels: Annotations2;
}
interface Annotations2 {}
interface Annotations {
    'ingress.kubernetes.io/ssl-redirect': string;
    'ingress.kubernetes.io/proxy-body-size': string;
    'nginx.ingress.kubernetes.io/ssl-redirect': string;
    'nginx.ingress.kubernetes.io/proxy-body-size': string;
}
interface Hosts {
    core: string;
    notary: string;
}
interface Tls {
    enabled: boolean;
    certSource: string;
    auto: Auto;
    secret: Secret;
}
interface Secret {
    secretName: string;
    notarySecretName: string;
}
interface Auto {
    commonName: string;
}

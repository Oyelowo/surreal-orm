// Don't Edit. This is autogenerated.
export interface IGrafanaGrafana {
	rbac: Rbac;
	serviceAccount: ServiceAccount;
	replicas: number;
	headlessService: boolean;
	autoscaling: Autoscaling;
	podDisruptionBudget: PodDisruptionBudget;
	deploymentStrategy: DeploymentStrategy;
	readinessProbe: ReadinessProbe;
	livenessProbe: LivenessProbe;
	image: Image;
	testFramework: TestFramework;
	securityContext: SecurityContext;
	containerSecurityContext: PodDisruptionBudget;
	createConfigmap: boolean;
	extraConfigmapMounts: any[];
	extraEmptyDirMounts: any[];
	extraLabels: PodDisruptionBudget;
	downloadDashboardsImage: Image;
	downloadDashboards: DownloadDashboards;
	podPortName: string;
	service: Service;
	serviceMonitor: ServiceMonitor;
	extraExposePorts: any[];
	hostAliases: any[];
	ingress: Ingress;
	resources: PodDisruptionBudget;
	nodeSelector: PodDisruptionBudget;
	tolerations: any[];
	affinity: PodDisruptionBudget;
	topologySpreadConstraints: any[];
	extraInitContainers: any[];
	extraContainers: string;
	extraContainerVolumes: any[];
	persistence: Persistence;
	initChownData: InitChownData;
	adminUser: string;
	admin: Admin;
	env: PodDisruptionBudget;
	envValueFrom: PodDisruptionBudget;
	envFromSecret: string;
	envRenderSecret: PodDisruptionBudget;
	envFromSecrets: any[];
	envFromConfigMaps: any[];
	enableServiceLinks: boolean;
	extraSecretMounts: any[];
	extraVolumeMounts: any[];
	lifecycleHooks: PodDisruptionBudget;
	plugins: any[];
	datasources: PodDisruptionBudget;
	alerting: PodDisruptionBudget;
	notifiers: PodDisruptionBudget;
	dashboardProviders: PodDisruptionBudget;
	dashboards: PodDisruptionBudget;
	dashboardsConfigMaps: PodDisruptionBudget;
	"grafana.ini": Grafanaini;
	ldap: Ldap;
	smtp: Admin;
	sidecar: Sidecar;
	namespaceOverride: string;
	revisionHistoryLimit: number;
	imageRenderer: ImageRenderer;
	networkPolicy: NetworkPolicy2;
	enableKubeBackwardCompatibility: boolean;
	useStatefulSet: boolean;
	extraObjects: any[];
}
interface NetworkPolicy2 {
	enabled: boolean;
	ingress: boolean;
	allowExternal: boolean;
	explicitNamespacesSelector: PodDisruptionBudget;
	egress: Egress;
}
interface Egress {
	enabled: boolean;
	ports: any[];
}
interface ImageRenderer {
	deploymentStrategy: PodDisruptionBudget;
	enabled: boolean;
	replicas: number;
	image: Image;
	env: Env;
	serviceAccountName: string;
	securityContext: PodDisruptionBudget;
	containerSecurityContext: ContainerSecurityContext;
	hostAliases: any[];
	priorityClassName: string;
	service: Service2;
	grafanaProtocol: string;
	grafanaSubPath: string;
	podPortName: string;
	revisionHistoryLimit: number;
	networkPolicy: NetworkPolicy;
	resources: PodDisruptionBudget;
	nodeSelector: PodDisruptionBudget;
	tolerations: any[];
	affinity: PodDisruptionBudget;
}
interface NetworkPolicy {
	limitIngress: boolean;
	limitEgress: boolean;
}
interface Service2 {
	enabled: boolean;
	portName: string;
	port: number;
	targetPort: number;
	appProtocol: string;
}
interface ContainerSecurityContext {
	capabilities: Capabilities;
	allowPrivilegeEscalation: boolean;
	readOnlyRootFilesystem: boolean;
}
interface Capabilities {
	drop: string[];
}
interface Env {
	HTTP_HOST: string;
}
interface Sidecar {
	image: Image2;
	imagePullPolicy: string;
	resources: PodDisruptionBudget;
	securityContext: PodDisruptionBudget;
	enableUniqueFilenames: boolean;
	readinessProbe: PodDisruptionBudget;
	livenessProbe: PodDisruptionBudget;
	alerts: Alerts;
	dashboards: Dashboards;
	datasources: Datasources;
	plugins: Plugins;
	notifiers: Notifiers;
}
interface Notifiers {
	enabled: boolean;
	env: PodDisruptionBudget;
	label: string;
	labelValue: string;
	searchNamespace?: any;
	watchMethod: string;
	resource: string;
	reloadURL: string;
	script?: any;
	skipReload: boolean;
	initNotifiers: boolean;
	sizeLimit: PodDisruptionBudget;
}
interface Plugins {
	enabled: boolean;
	env: PodDisruptionBudget;
	label: string;
	labelValue: string;
	searchNamespace?: any;
	watchMethod: string;
	resource: string;
	reloadURL: string;
	script?: any;
	skipReload: boolean;
	initPlugins: boolean;
	sizeLimit: PodDisruptionBudget;
}
interface Datasources {
	enabled: boolean;
	env: PodDisruptionBudget;
	label: string;
	labelValue: string;
	searchNamespace?: any;
	watchMethod: string;
	resource: string;
	reloadURL: string;
	script?: any;
	skipReload: boolean;
	initDatasources: boolean;
	sizeLimit: PodDisruptionBudget;
}
interface Dashboards {
	enabled: boolean;
	env: PodDisruptionBudget;
	SCProvider: boolean;
	label: string;
	labelValue: string;
	folder: string;
	defaultFolderName?: any;
	searchNamespace?: any;
	watchMethod: string;
	resource: string;
	folderAnnotation?: any;
	script?: any;
	provider: Provider;
	extraMounts: any[];
	sizeLimit: PodDisruptionBudget;
}
interface Provider {
	name: string;
	orgid: number;
	folder: string;
	type: string;
	disableDelete: boolean;
	allowUiUpdates: boolean;
	foldersFromFilesStructure: boolean;
}
interface Alerts {
	enabled: boolean;
	env: PodDisruptionBudget;
	label: string;
	labelValue: string;
	searchNamespace?: any;
	watchMethod: string;
	resource: string;
	reloadURL: string;
	script?: any;
	skipReload: boolean;
	sizeLimit: PodDisruptionBudget;
}
interface Image2 {
	repository: string;
	tag: string;
	sha: string;
}
interface Ldap {
	enabled: boolean;
	existingSecret: string;
	config: string;
}
interface Grafanaini {
	paths: Paths;
	analytics: Analytics;
	log: Log;
	grafana_net: Grafananet;
	server: Server;
}
interface Server {
	domain: string;
}
interface Grafananet {
	url: string;
}
interface Log {
	mode: string;
}
interface Analytics {
	check_for_updates: boolean;
}
interface Paths {
	data: string;
	logs: string;
	plugins: string;
	provisioning: string;
}
interface Admin {
	existingSecret: string;
	userKey: string;
	passwordKey: string;
}
interface InitChownData {
	enabled: boolean;
	image: Image;
	resources: PodDisruptionBudget;
	securityContext: SecurityContext2;
}
interface SecurityContext2 {
	runAsNonRoot: boolean;
	runAsUser: number;
}
interface Persistence {
	type: string;
	enabled: boolean;
	accessModes: string[];
	size: string;
	finalizers: string[];
	inMemory: Autoscaling;
}
interface Ingress {
	enabled: boolean;
	annotations: PodDisruptionBudget;
	labels: PodDisruptionBudget;
	path: string;
	pathType: string;
	hosts: string[];
	extraPaths: any[];
	tls: any[];
}
interface ServiceMonitor {
	enabled: boolean;
	path: string;
	labels: PodDisruptionBudget;
	interval: string;
	scheme: string;
	tlsConfig: PodDisruptionBudget;
	scrapeTimeout: string;
	relabelings: any[];
}
interface Service {
	enabled: boolean;
	type: string;
	port: number;
	targetPort: number;
	annotations: PodDisruptionBudget;
	labels: PodDisruptionBudget;
	portName: string;
	appProtocol: string;
}
interface DownloadDashboards {
	env: PodDisruptionBudget;
	envFromSecret: string;
	resources: PodDisruptionBudget;
	securityContext: PodDisruptionBudget;
}
interface SecurityContext {
	runAsUser: number;
	runAsGroup: number;
	fsGroup: number;
}
interface TestFramework {
	enabled: boolean;
	image: string;
	tag: string;
	imagePullPolicy: string;
	securityContext: PodDisruptionBudget;
}
interface Image {
	repository: string;
	tag: string;
	sha: string;
	pullPolicy: string;
}
interface LivenessProbe {
	httpGet: HttpGet;
	initialDelaySeconds: number;
	timeoutSeconds: number;
	failureThreshold: number;
}
interface ReadinessProbe {
	httpGet: HttpGet;
}
interface HttpGet {
	path: string;
	port: number;
}
interface DeploymentStrategy {
	type: string;
}
interface PodDisruptionBudget {}
interface Autoscaling {
	enabled: boolean;
}
interface ServiceAccount {
	create: boolean;
	name?: any;
	nameTest?: any;
	autoMount: boolean;
}
interface Rbac {
	create: boolean;
	pspEnabled: boolean;
	pspUseAppArmor: boolean;
	namespaced: boolean;
	extraRoleRules: any[];
	extraClusterRoleRules: any[];
}

// Don't Edit. This is autogenerated.
export interface ILokiDistributedGrafana {
	global: Global;
	nameOverride?: any;
	fullnameOverride?: any;
	imagePullSecrets: any[];
	loki: Loki;
	runtimeConfig: Annotations;
	serviceAccount: ServiceAccount;
	rbac: Rbac;
	serviceMonitor: ServiceMonitor;
	prometheusRule: PrometheusRule;
	ingester: Ingester;
	distributor: Distributor;
	querier: Querier;
	queryFrontend: Distributor;
	queryScheduler: QueryScheduler;
	tableManager: TableManager;
	ingress: Ingress;
	gateway: Gateway;
	compactor: Compactor;
	ruler: Ruler;
	indexGateway: IndexGateway;
	memcached: Memcached;
	memcachedExporter: MemcachedExporter;
	memcachedChunks: MemcachedChunks;
	memcachedFrontend: MemcachedFrontend;
	memcachedIndexQueries: MemcachedChunks;
	memcachedIndexWrites: MemcachedChunks;
	networkPolicy: NetworkPolicy;
}
interface NetworkPolicy {
	enabled: boolean;
	metrics: Metrics;
	ingress: Ingress3;
	alertmanager: Alertmanager;
	externalStorage: ExternalStorage;
	discovery: Discovery;
}
interface Discovery {
	port?: any;
	podSelector: Annotations;
	namespaceSelector: Annotations;
}
interface ExternalStorage {
	ports: any[];
	cidrs: any[];
}
interface Alertmanager {
	port: number;
	podSelector: Annotations;
	namespaceSelector: Annotations;
}
interface Ingress3 {
	podSelector: Annotations;
	namespaceSelector: Annotations;
}
interface Metrics {
	podSelector: Annotations;
	namespaceSelector: Annotations;
	cidrs: any[];
}
interface MemcachedFrontend {
	enabled: boolean;
	replicas: number;
	priorityClassName?: any;
	podLabels: Annotations;
	podAnnotations: Annotations;
	serviceLabels: Annotations;
	extraArgs: string[];
	extraEnv: any[];
	extraEnvFrom: any[];
	resources: Annotations;
	extraContainers: any[];
	terminationGracePeriodSeconds: number;
	affinity: string;
	maxUnavailable: number;
	nodeSelector: Annotations;
	tolerations: any[];
}
interface MemcachedChunks {
	enabled: boolean;
	replicas: number;
	priorityClassName?: any;
	podLabels: Annotations;
	podAnnotations: Annotations;
	serviceLabels: Annotations;
	extraArgs: string[];
	extraEnv: any[];
	extraEnvFrom: any[];
	resources: Annotations;
	extraContainers: any[];
	terminationGracePeriodSeconds: number;
	affinity: string;
	maxUnavailable?: any;
	nodeSelector: Annotations;
	tolerations: any[];
}
interface MemcachedExporter {
	enabled: boolean;
	image: Image4;
	podLabels: Annotations;
	resources: Annotations;
	containerSecurityContext: ContainerSecurityContext;
}
interface Memcached {
	readinessProbe: ReadinessProbe2;
	livenessProbe: LivenessProbe2;
	image: Image4;
	podLabels: Annotations;
	podSecurityContext: PodSecurityContext;
	containerSecurityContext: ContainerSecurityContext;
	serviceAnnotations: Annotations;
	appProtocol: string;
}
interface LivenessProbe2 {
	tcpSocket: TcpSocket;
	initialDelaySeconds: number;
}
interface ReadinessProbe2 {
	tcpSocket: TcpSocket;
	initialDelaySeconds: number;
	timeoutSeconds: number;
}
interface TcpSocket {
	port: string;
}
interface IndexGateway {
	enabled: boolean;
	replicas: number;
	image: Image3;
	priorityClassName?: any;
	podLabels: Annotations;
	podAnnotations: Annotations;
	serviceLabels: Annotations;
	extraArgs: any[];
	extraEnv: any[];
	extraEnvFrom: any[];
	extraVolumeMounts: any[];
	extraVolumes: any[];
	resources: Annotations;
	extraContainers: any[];
	initContainers: any[];
	terminationGracePeriodSeconds: number;
	affinity: string;
	maxUnavailable?: any;
	nodeSelector: Annotations;
	tolerations: any[];
	persistence: Persistence;
}
interface Ruler {
	enabled: boolean;
	kind: string;
	replicas: number;
	image: Image3;
	command?: any;
	priorityClassName?: any;
	podLabels: Annotations;
	podAnnotations: Annotations;
	serviceLabels: Annotations;
	extraArgs: any[];
	extraEnv: any[];
	extraEnvFrom: any[];
	extraVolumeMounts: any[];
	extraVolumes: any[];
	resources: Annotations;
	extraContainers: any[];
	initContainers: any[];
	terminationGracePeriodSeconds: number;
	affinity: string;
	maxUnavailable?: any;
	nodeSelector: Annotations;
	tolerations: any[];
	dnsConfig: Annotations;
	persistence: Persistence2;
	directories: Annotations;
}
interface Compactor {
	enabled: boolean;
	image: Image3;
	command?: any;
	priorityClassName?: any;
	podLabels: Annotations;
	podAnnotations: Annotations;
	affinity: Annotations;
	serviceLabels: Annotations;
	extraArgs: any[];
	extraEnv: any[];
	extraEnvFrom: any[];
	extraVolumeMounts: any[];
	extraVolumes: any[];
	resources: Annotations;
	extraContainers: any[];
	initContainers: any[];
	terminationGracePeriodSeconds: number;
	nodeSelector: Annotations;
	tolerations: any[];
	persistence: Persistence2;
	serviceAccount: ServiceAccount;
}
interface Gateway {
	enabled: boolean;
	replicas: number;
	verboseLogging: boolean;
	autoscaling: Autoscaling;
	deploymentStrategy: DeploymentStrategy;
	image: Image4;
	priorityClassName?: any;
	podLabels: Annotations;
	podAnnotations: Annotations;
	extraArgs: any[];
	extraEnv: any[];
	extraEnvFrom: any[];
	extraVolumes: any[];
	extraVolumeMounts: any[];
	podSecurityContext: PodSecurityContext;
	containerSecurityContext: ContainerSecurityContext;
	resources: Annotations;
	extraContainers: any[];
	terminationGracePeriodSeconds: number;
	affinity: string;
	maxUnavailable?: any;
	nodeSelector: Annotations;
	tolerations: any[];
	dnsConfig: Annotations;
	service: Service;
	ingress: Ingress2;
	basicAuth: BasicAuth;
	readinessProbe: ReadinessProbe;
	livenessProbe: LivenessProbe;
	nginxConfig: NginxConfig;
}
interface NginxConfig {
	logFormat: string;
	serverSnippet: string;
	httpSnippet: string;
	resolver: string;
	file: string;
}
interface BasicAuth {
	enabled: boolean;
	username?: any;
	password?: any;
	htpasswd: string;
	existingSecret?: any;
}
interface Ingress2 {
	enabled: boolean;
	ingressClassName: string;
	annotations: Annotations;
	hosts: Host[];
	tls: Tl[];
}
interface Tl {
	secretName: string;
	hosts: string[];
}
interface Host {
	host: string;
	paths: Path[];
}
interface Path {
	path: string;
}
interface Service {
	port: number;
	type: string;
	clusterIP?: any;
	nodePort?: any;
	loadBalancerIP?: any;
	loadBalancerSourceRanges: any[];
	appProtocol?: any;
	annotations: Annotations;
	labels: Annotations;
}
interface Image4 {
	registry: string;
	repository: string;
	tag: string;
	pullPolicy: string;
}
interface DeploymentStrategy {
	type: string;
}
interface Ingress {
	enabled: boolean;
	annotations: Annotations;
	paths: Paths;
	hosts: string[];
}
interface Paths {
	distributor: string[];
	querier: string[];
	"query-frontend": string[];
	ruler: string[];
}
interface TableManager {
	enabled: boolean;
	image: Image3;
	command?: any;
	priorityClassName?: any;
	podLabels: Annotations;
	podAnnotations: Annotations;
	serviceLabels: Annotations;
	extraArgs: any[];
	extraEnv: any[];
	extraEnvFrom: any[];
	extraVolumeMounts: any[];
	extraVolumes: any[];
	resources: Annotations;
	extraContainers: any[];
	terminationGracePeriodSeconds: number;
	affinity: string;
	nodeSelector: Annotations;
	tolerations: any[];
}
interface QueryScheduler {
	enabled: boolean;
	replicas: number;
	image: Image3;
	priorityClassName?: any;
	podLabels: Annotations;
	podAnnotations: Annotations;
	serviceLabels: Annotations;
	extraArgs: any[];
	extraEnv: any[];
	extraEnvFrom: any[];
	extraVolumeMounts: any[];
	extraVolumes: any[];
	resources: Annotations;
	extraContainers: any[];
	terminationGracePeriodSeconds: number;
	affinity: string;
	maxUnavailable: number;
	nodeSelector: Annotations;
	tolerations: any[];
}
interface Querier {
	replicas: number;
	autoscaling: Autoscaling;
	image: Image3;
	command?: any;
	priorityClassName?: any;
	podLabels: Annotations;
	podAnnotations: Annotations;
	serviceLabels: Annotations;
	extraArgs: any[];
	extraEnv: any[];
	extraEnvFrom: any[];
	extraVolumeMounts: any[];
	extraVolumes: any[];
	resources: Annotations;
	extraContainers: any[];
	initContainers: any[];
	terminationGracePeriodSeconds: number;
	affinity: string;
	maxUnavailable?: any;
	nodeSelector: Annotations;
	tolerations: any[];
	dnsConfig: Annotations;
	persistence: Persistence2;
	appProtocol: AppProtocol;
}
interface Persistence2 {
	enabled: boolean;
	size: string;
	storageClass?: any;
}
interface Distributor {
	replicas: number;
	autoscaling: Autoscaling;
	image: Image3;
	command?: any;
	priorityClassName?: any;
	podLabels: Annotations;
	podAnnotations: Annotations;
	serviceLabels: Annotations;
	extraArgs: any[];
	extraEnv: any[];
	extraEnvFrom: any[];
	extraVolumeMounts: any[];
	extraVolumes: any[];
	resources: Annotations;
	extraContainers: any[];
	terminationGracePeriodSeconds: number;
	affinity: string;
	maxUnavailable?: any;
	nodeSelector: Annotations;
	tolerations: any[];
	appProtocol: AppProtocol;
}
interface Ingester {
	kind: string;
	replicas: number;
	autoscaling: Autoscaling;
	image: Image3;
	command?: any;
	priorityClassName?: any;
	podLabels: Annotations;
	podAnnotations: Annotations;
	serviceLabels: Annotations;
	extraArgs: any[];
	extraEnv: any[];
	extraEnvFrom: any[];
	extraVolumeMounts: any[];
	extraVolumes: any[];
	resources: Annotations;
	extraContainers: any[];
	initContainers: any[];
	terminationGracePeriodSeconds: number;
	topologySpreadConstraints: string;
	affinity: string;
	maxUnavailable?: any;
	nodeSelector: Annotations;
	tolerations: any[];
	readinessProbe: Annotations;
	livenessProbe: Annotations;
	persistence: Persistence;
	appProtocol: AppProtocol;
}
interface AppProtocol {
	grpc: string;
}
interface Persistence {
	enabled: boolean;
	inMemory: boolean;
	size: string;
	storageClass?: any;
}
interface Image3 {
	registry?: any;
	repository?: any;
	tag?: any;
}
interface Autoscaling {
	enabled: boolean;
	minReplicas: number;
	maxReplicas: number;
	targetCPUUtilizationPercentage: number;
	targetMemoryUtilizationPercentage?: any;
}
interface PrometheusRule {
	enabled: boolean;
	namespace?: any;
	annotations: Annotations;
	labels: Annotations;
	groups: any[];
}
interface ServiceMonitor {
	enabled: boolean;
	namespace?: any;
	namespaceSelector: Annotations;
	annotations: Annotations;
	labels: Annotations;
	interval?: any;
	scrapeTimeout?: any;
	relabelings: any[];
	metricRelabelings: any[];
	targetLabels: any[];
	scheme: string;
	tlsConfig?: any;
}
interface Rbac {
	pspEnabled: boolean;
	sccEnabled: boolean;
}
interface ServiceAccount {
	create: boolean;
	name?: any;
	imagePullSecrets: any[];
	annotations: Annotations;
	automountServiceAccountToken: boolean;
}
interface Loki {
	annotations: Annotations;
	readinessProbe: ReadinessProbe;
	livenessProbe: LivenessProbe;
	image: Image2;
	podLabels: Annotations;
	podAnnotations: Annotations;
	command?: any;
	revisionHistoryLimit: number;
	podSecurityContext: PodSecurityContext;
	containerSecurityContext: ContainerSecurityContext;
	existingSecretForConfig: string;
	appProtocol: string;
	serviceAnnotations: Annotations;
	config: string;
	schemaConfig: SchemaConfig;
	storageConfig: StorageConfig;
	structuredConfig: Annotations;
}
interface StorageConfig {
	boltdb_shipper: Boltdbshipper;
	filesystem: Filesystem;
}
interface Filesystem {
	directory: string;
}
interface Boltdbshipper {
	shared_store: string;
	active_index_directory: string;
	cache_location: string;
	cache_ttl: string;
}
interface SchemaConfig {
	configs: Config[];
}
interface Config {
	from: string;
	store: string;
	object_store: string;
	schema: string;
	index: Index;
}
interface Index {
	prefix: string;
	period: string;
}
interface ContainerSecurityContext {
	readOnlyRootFilesystem: boolean;
	capabilities: Capabilities;
	allowPrivilegeEscalation: boolean;
}
interface Capabilities {
	drop: string[];
}
interface PodSecurityContext {
	fsGroup: number;
	runAsGroup: number;
	runAsNonRoot: boolean;
	runAsUser: number;
}
interface Image2 {
	registry: string;
	repository: string;
	tag?: any;
	pullPolicy: string;
}
interface LivenessProbe {
	httpGet: HttpGet;
	initialDelaySeconds: number;
}
interface ReadinessProbe {
	httpGet: HttpGet;
	initialDelaySeconds: number;
	timeoutSeconds: number;
}
interface HttpGet {
	path: string;
	port: string;
}
interface Annotations {}
interface Global {
	image: Image;
	priorityClassName?: any;
	clusterDomain: string;
	dnsService: string;
	dnsNamespace: string;
}
interface Image {
	registry?: any;
}

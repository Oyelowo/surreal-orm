// Don't Edit. This is autogenerated.
export interface IThanosBitnami {
	global: Global;
	kubeVersion: string;
	nameOverride: string;
	fullnameOverride: string;
	commonLabels: CommonLabels;
	commonAnnotations: CommonLabels;
	clusterDomain: string;
	extraDeploy: any[];
	image: Image;
	objstoreConfig: string;
	indexCacheConfig: string;
	bucketCacheConfig: string;
	existingObjstoreSecret: string;
	existingObjstoreSecretItems: any[];
	httpConfig: string;
	existingHttpConfigSecret: string;
	https: Https;
	auth: Auth;
	serviceAccount: ServiceAccount;
	query: Query;
	queryFrontend: QueryFrontend;
	bucketweb: Bucketweb;
	compactor: Compactor;
	storegateway: Storegateway;
	ruler: Ruler;
	receive: Receive;
	receiveDistributor: ReceiveDistributor;
	metrics: Metrics;
	volumePermissions: VolumePermissions;
	minio: Minio;
	networkPolicy: NetworkPolicy;
}
interface NetworkPolicy {
	enabled: boolean;
	allowExternal: boolean;
	explicitNamespacesSelector: CommonLabels;
}
interface Minio {
	enabled: boolean;
	auth: Auth2;
	defaultBuckets: string;
}
interface Auth2 {
	rootUser: string;
	rootPassword: string;
}
interface VolumePermissions {
	enabled: boolean;
	image: Image;
}
interface Metrics {
	enabled: boolean;
	serviceMonitor: ServiceMonitor;
	prometheusRule: PrometheusRule;
}
interface PrometheusRule {
	enabled: boolean;
	namespace: string;
	additionalLabels: CommonLabels;
	groups: any[];
}
interface ServiceMonitor {
	enabled: boolean;
	namespace: string;
	labels: CommonLabels;
	jobLabel: string;
	interval: string;
	scrapeTimeout: string;
	metricRelabelings: any[];
	relabelings: any[];
	selector: CommonLabels;
}
interface ReceiveDistributor {
	enabled: boolean;
	logLevel: string;
	logFormat: string;
	replicaLabel: string;
	replicationFactor: number;
	extraEnvVars: any[];
	extraEnvVarsCM: string;
	extraEnvVarsSecret: string;
	extraFlags: any[];
	command: any[];
	args: any[];
	replicaCount: number;
	updateStrategy: UpdateStrategy;
	podSecurityContext: PodSecurityContext;
	containerSecurityContext: ContainerSecurityContext;
	resources: Resources;
	livenessProbe: LivenessProbe;
	readinessProbe: LivenessProbe;
	startupProbe: LivenessProbe;
	customLivenessProbe: CommonLabels;
	customReadinessProbe: CommonLabels;
	customStartupProbe: CommonLabels;
	initContainers: any[];
	sidecars: any[];
	extraVolumes: any[];
	extraVolumeMounts: any[];
	podAffinityPreset: string;
	podAntiAffinityPreset: string;
	nodeAffinityPreset: NodeAffinityPreset;
	affinity: CommonLabels;
	nodeSelector: CommonLabels;
	tolerations: any[];
	podLabels: CommonLabels;
	podAnnotations: CommonLabels;
	hostAliases: any[];
	lifecycleHooks: CommonLabels;
	priorityClassName: string;
	schedulerName: string;
	topologySpreadConstraints: any[];
	automountServiceAccountToken: boolean;
	serviceAccount: ServiceAccount;
	autoscaling: Autoscaling;
	pdb: Pdb;
}
interface Receive {
	enabled: boolean;
	mode: string;
	logLevel: string;
	logFormat: string;
	tsdbRetention: string;
	replicationFactor: number;
	config: any[];
	existingConfigmap: string;
	replicaLabel: string;
	grpc: Grpc3;
	extraEnvVars: any[];
	extraEnvVarsCM: string;
	extraEnvVarsSecret: string;
	extraFlags: any[];
	command: any[];
	args: any[];
	replicaCount: number;
	updateStrategy: UpdateStrategy;
	podManagementPolicy: string;
	podSecurityContext: PodSecurityContext;
	containerSecurityContext: ContainerSecurityContext;
	resources: Resources;
	livenessProbe: LivenessProbe;
	readinessProbe: LivenessProbe;
	startupProbe: LivenessProbe;
	customLivenessProbe: CommonLabels;
	customReadinessProbe: CommonLabels;
	customStartupProbe: CommonLabels;
	initContainers: any[];
	sidecars: any[];
	extraVolumes: any[];
	extraVolumeMounts: any[];
	podAffinityPreset: string;
	podAntiAffinityPreset: string;
	nodeAffinityPreset: NodeAffinityPreset;
	affinity: CommonLabels;
	nodeSelector: CommonLabels;
	tolerations: any[];
	podLabels: CommonLabels;
	podAnnotations: CommonLabels;
	hostAliases: any[];
	lifecycleHooks: CommonLabels;
	priorityClassName: string;
	schedulerName: string;
	topologySpreadConstraints: any[];
	service: Service6;
	automountServiceAccountToken: boolean;
	serviceAccount: ServiceAccount;
	autoscaling: Autoscaling;
	pdb: Pdb;
	persistence: Persistence;
	ingress: Grpc2;
}
interface Service6 {
	type: string;
	ports: Ports4;
	nodePorts: NodePorts4;
	clusterIP: string;
	loadBalancerIP: string;
	loadBalancerSourceRanges: any[];
	externalTrafficPolicy: string;
	annotations: CommonLabels;
	extraPorts: any[];
	labelSelectorsOverride: CommonLabels;
	additionalHeadless: boolean;
}
interface NodePorts4 {
	http: string;
	grpc: string;
	remote: string;
}
interface Ports4 {
	http: number;
	grpc: number;
	remote: number;
}
interface Ruler {
	enabled: boolean;
	logLevel: string;
	logFormat: string;
	replicaLabel: string;
	dnsDiscovery: DnsDiscovery2;
	alertmanagers: any[];
	alertmanagersConfig: string;
	evalInterval: string;
	clusterName: string;
	config: string;
	existingConfigmap: string;
	extraEnvVars: any[];
	extraEnvVarsCM: string;
	extraEnvVarsSecret: string;
	extraFlags: any[];
	command: any[];
	args: any[];
	replicaCount: number;
	updateStrategy: UpdateStrategy;
	podManagementPolicy: string;
	podSecurityContext: PodSecurityContext;
	containerSecurityContext: ContainerSecurityContext;
	resources: Resources;
	livenessProbe: LivenessProbe;
	readinessProbe: LivenessProbe;
	startupProbe: LivenessProbe;
	customLivenessProbe: CommonLabels;
	customReadinessProbe: CommonLabels;
	customStartupProbe: CommonLabels;
	initContainers: any[];
	sidecars: any[];
	extraVolumes: any[];
	extraVolumeMounts: any[];
	podAffinityPreset: string;
	podAntiAffinityPreset: string;
	nodeAffinityPreset: NodeAffinityPreset;
	affinity: CommonLabels;
	nodeSelector: CommonLabels;
	tolerations: any[];
	podLabels: CommonLabels;
	podAnnotations: CommonLabels;
	hostAliases: any[];
	lifecycleHooks: CommonLabels;
	priorityClassName: string;
	schedulerName: string;
	topologySpreadConstraints: any[];
	service: Service4;
	persistence: Persistence;
	automountServiceAccountToken: boolean;
	serviceAccount: ServiceAccount;
	autoscaling: Autoscaling;
	pdb: Pdb;
	ingress: Ingress2;
}
interface Ingress2 {
	enabled: boolean;
	hostname: string;
	ingressClassName: string;
	annotations: CommonLabels;
	extraHosts: any[];
	extraTls: any[];
	secrets: any[];
	extraRules: any[];
	apiVersion: string;
	path: string;
	pathType: string;
}
interface DnsDiscovery2 {
	enabled: boolean;
}
interface Storegateway {
	enabled: boolean;
	logLevel: string;
	logFormat: string;
	config: string;
	existingConfigmap: string;
	grpc: Grpc3;
	extraEnvVars: any[];
	extraEnvVarsCM: string;
	extraEnvVarsSecret: string;
	extraFlags: any[];
	command: any[];
	args: any[];
	replicaCount: number;
	updateStrategy: UpdateStrategy;
	podManagementPolicy: string;
	podSecurityContext: PodSecurityContext;
	containerSecurityContext: ContainerSecurityContext;
	resources: Resources;
	livenessProbe: LivenessProbe;
	readinessProbe: LivenessProbe;
	startupProbe: LivenessProbe;
	customLivenessProbe: CommonLabels;
	customReadinessProbe: CommonLabels;
	customStartupProbe: CommonLabels;
	initContainers: any[];
	sidecars: any[];
	extraVolumes: any[];
	extraVolumeMounts: any[];
	podAffinityPreset: string;
	podAntiAffinityPreset: string;
	nodeAffinityPreset: NodeAffinityPreset;
	affinity: CommonLabels;
	nodeSelector: CommonLabels;
	tolerations: any[];
	podLabels: CommonLabels;
	podAnnotations: CommonLabels;
	hostAliases: any[];
	lifecycleHooks: CommonLabels;
	priorityClassName: string;
	topologySpreadConstraints: any[];
	schedulerName: string;
	service: Service4;
	persistence: Persistence2;
	automountServiceAccountToken: boolean;
	serviceAccount: ServiceAccount;
	autoscaling: Autoscaling;
	pdb: Pdb;
	ingress: Ingress;
	sharded: Sharded;
}
interface Sharded {
	enabled: boolean;
	hashPartitioning: HashPartitioning;
	timePartitioning: TimePartitioning[];
	service: Service5;
}
interface Service5 {
	clusterIPs: any[];
	loadBalancerIPs: any[];
	http: Http;
	grpc: Http;
}
interface Http {
	nodePorts: any[];
}
interface TimePartitioning {
	min: string;
	max: string;
}
interface HashPartitioning {
	shards: string;
}
interface Persistence2 {
	enabled: boolean;
	storageClass: string;
	accessModes: string[];
	size: string;
	labels: CommonLabels;
	annotations: CommonLabels;
	existingClaim: string;
}
interface Service4 {
	type: string;
	ports: Ports3;
	nodePorts: NodePorts3;
	clusterIP: string;
	loadBalancerIP: string;
	loadBalancerSourceRanges: any[];
	externalTrafficPolicy: string;
	annotations: CommonLabels;
	extraPorts: any[];
	labelSelectorsOverride: CommonLabels;
	additionalHeadless: boolean;
}
interface NodePorts3 {
	http: string;
	grpc: string;
}
interface Ports3 {
	http: number;
	grpc: number;
}
interface Grpc3 {
	server: Server;
}
interface Compactor {
	enabled: boolean;
	logLevel: string;
	logFormat: string;
	retentionResolutionRaw: string;
	retentionResolution5m: string;
	retentionResolution1h: string;
	consistencyDelay: string;
	extraEnvVars: any[];
	extraEnvVarsCM: string;
	extraEnvVarsSecret: string;
	extraFlags: any[];
	command: any[];
	args: any[];
	updateStrategy: UpdateStrategy;
	podSecurityContext: PodSecurityContext;
	containerSecurityContext: ContainerSecurityContext;
	resources: Resources;
	livenessProbe: LivenessProbe;
	readinessProbe: LivenessProbe;
	startupProbe: LivenessProbe;
	customLivenessProbe: CommonLabels;
	customReadinessProbe: CommonLabels;
	customStartupProbe: CommonLabels;
	initContainers: any[];
	sidecars: any[];
	extraVolumes: any[];
	extraVolumeMounts: any[];
	podAffinityPreset: string;
	podAntiAffinityPreset: string;
	nodeAffinityPreset: NodeAffinityPreset;
	affinity: CommonLabels;
	nodeSelector: CommonLabels;
	tolerations: any[];
	podLabels: CommonLabels;
	podAnnotations: CommonLabels;
	hostAliases: any[];
	lifecycleHooks: CommonLabels;
	priorityClassName: string;
	schedulerName: string;
	topologySpreadConstraints: any[];
	service: Service3;
	automountServiceAccountToken: boolean;
	serviceAccount: ServiceAccount;
	ingress: Grpc2;
	persistence: Persistence;
}
interface Persistence {
	enabled: boolean;
	storageClass: string;
	accessModes: string[];
	size: string;
	annotations: CommonLabels;
	existingClaim: string;
}
interface Bucketweb {
	enabled: boolean;
	logLevel: string;
	logFormat: string;
	refresh: string;
	timeout: string;
	extraEnvVars: any[];
	extraEnvVarsCM: string;
	extraEnvVarsSecret: string;
	extraFlags: any[];
	command: any[];
	args: any[];
	replicaCount: number;
	updateStrategy: UpdateStrategy;
	podSecurityContext: PodSecurityContext;
	containerSecurityContext: ContainerSecurityContext;
	resources: Resources;
	livenessProbe: LivenessProbe;
	readinessProbe: LivenessProbe;
	startupProbe: LivenessProbe;
	customLivenessProbe: CommonLabels;
	customReadinessProbe: CommonLabels;
	customStartupProbe: CommonLabels;
	initContainers: any[];
	sidecars: any[];
	extraVolumes: any[];
	extraVolumeMounts: any[];
	podAffinityPreset: string;
	podAntiAffinityPreset: string;
	nodeAffinityPreset: NodeAffinityPreset;
	affinity: CommonLabels;
	nodeSelector: CommonLabels;
	tolerations: any[];
	podLabels: CommonLabels;
	podAnnotations: CommonLabels;
	hostAliases: any[];
	lifecycleHooks: CommonLabels;
	priorityClassName: string;
	schedulerName: string;
	topologySpreadConstraints: any[];
	service: Service3;
	automountServiceAccountToken: boolean;
	serviceAccount: ServiceAccount;
	autoscaling: Autoscaling;
	pdb: Pdb;
	ingress: Grpc2;
}
interface Service3 {
	type: string;
	ports: Ports;
	nodePorts: NodePorts;
	clusterIP: string;
	loadBalancerIP: string;
	loadBalancerSourceRanges: any[];
	externalTrafficPolicy: string;
	annotations: CommonLabels;
	extraPorts: any[];
	labelSelectorsOverride: CommonLabels;
}
interface QueryFrontend {
	enabled: boolean;
	logLevel: string;
	logFormat: string;
	config: string;
	existingConfigmap: string;
	extraEnvVars: any[];
	extraEnvVarsCM: string;
	extraEnvVarsSecret: string;
	extraFlags: any[];
	command: any[];
	args: any[];
	replicaCount: number;
	updateStrategy: UpdateStrategy;
	podSecurityContext: PodSecurityContext;
	containerSecurityContext: ContainerSecurityContext;
	resources: Resources;
	livenessProbe: LivenessProbe;
	readinessProbe: LivenessProbe;
	startupProbe: LivenessProbe;
	customLivenessProbe: CommonLabels;
	customReadinessProbe: CommonLabels;
	customStartupProbe: CommonLabels;
	initContainers: any[];
	sidecars: any[];
	extraVolumes: any[];
	extraVolumeMounts: any[];
	podAffinityPreset: string;
	podAntiAffinityPreset: string;
	nodeAffinityPreset: NodeAffinityPreset;
	affinity: CommonLabels;
	nodeSelector: CommonLabels;
	tolerations: any[];
	podLabels: CommonLabels;
	podAnnotations: CommonLabels;
	hostAliases: any[];
	lifecycleHooks: CommonLabels;
	priorityClassName: string;
	schedulerName: string;
	topologySpreadConstraints: any[];
	service: Service2;
	automountServiceAccountToken: boolean;
	serviceAccount: ServiceAccount;
	rbac: Rbac;
	pspEnabled: boolean;
	autoscaling: Autoscaling;
	pdb: Pdb;
	ingress: Grpc2;
}
interface Service2 {
	type: string;
	ports: Ports;
	nodePorts: NodePorts;
	clusterIP: string;
	loadBalancerIP: string;
	loadBalancerSourceRanges: any[];
	externalTrafficPolicy: string;
	annotations: CommonLabels;
	labels: CommonLabels;
	extraPorts: any[];
	labelSelectorsOverride: CommonLabels;
}
interface Query {
	enabled: boolean;
	logLevel: string;
	logFormat: string;
	replicaLabel: string[];
	dnsDiscovery: DnsDiscovery;
	stores: any[];
	sdConfig: string;
	existingSDConfigmap: string;
	extraEnvVars: any[];
	extraEnvVarsCM: string;
	extraEnvVarsSecret: string;
	extraFlags: any[];
	command: any[];
	args: any[];
	replicaCount: number;
	updateStrategy: UpdateStrategy;
	podSecurityContext: PodSecurityContext;
	containerSecurityContext: ContainerSecurityContext;
	resources: Resources;
	livenessProbe: LivenessProbe;
	readinessProbe: LivenessProbe;
	startupProbe: LivenessProbe;
	customLivenessProbe: CommonLabels;
	customReadinessProbe: CommonLabels;
	customStartupProbe: CommonLabels;
	initContainers: any[];
	sidecars: any[];
	extraVolumes: any[];
	extraVolumeMounts: any[];
	podAffinityPreset: string;
	podAntiAffinityPreset: string;
	nodeAffinityPreset: NodeAffinityPreset;
	affinity: CommonLabels;
	nodeSelector: CommonLabels;
	tolerations: any[];
	podLabels: CommonLabels;
	podAnnotations: CommonLabels;
	hostAliases: any[];
	lifecycleHooks: CommonLabels;
	priorityClassName: string;
	schedulerName: string;
	topologySpreadConstraints: any[];
	grpc: Grpc;
	service: Service;
	serviceGrpc: ServiceGrpc;
	automountServiceAccountToken: boolean;
	serviceAccount: ServiceAccount;
	rbac: Rbac;
	pspEnabled: boolean;
	autoscaling: Autoscaling;
	pdb: Pdb;
	ingress: Ingress;
}
interface Ingress {
	enabled: boolean;
	hostname: string;
	ingressClassName: string;
	annotations: CommonLabels;
	extraHosts: any[];
	extraTls: any[];
	secrets: any[];
	extraRules: any[];
	tls: boolean;
	selfSigned: boolean;
	apiVersion: string;
	path: string;
	pathType: string;
	grpc: Grpc2;
}
interface Grpc2 {
	enabled: boolean;
	hostname: string;
	ingressClassName: string;
	annotations: CommonLabels;
	extraHosts: any[];
	extraTls: any[];
	secrets: any[];
	extraRules: any[];
	tls: boolean;
	selfSigned: boolean;
	apiVersion: string;
	path: string;
	pathType: string;
}
interface Pdb {
	create: boolean;
	minAvailable: number;
	maxUnavailable: string;
}
interface Autoscaling {
	enabled: boolean;
	minReplicas: string;
	maxReplicas: string;
	targetCPU: string;
	targetMemory: string;
}
interface Rbac {
	create: boolean;
	rules: any[];
}
interface ServiceGrpc {
	type: string;
	ports: Ports2;
	nodePorts: NodePorts2;
	clusterIP: string;
	loadBalancerIP: string;
	loadBalancerSourceRanges: any[];
	externalTrafficPolicy: string;
	annotations: CommonLabels;
	extraPorts: any[];
	labelSelectorsOverride: CommonLabels;
	additionalHeadless: boolean;
}
interface NodePorts2 {
	grpc: string;
}
interface Ports2 {
	grpc: number;
}
interface Service {
	type: string;
	ports: Ports;
	nodePorts: NodePorts;
	clusterIP: string;
	loadBalancerIP: string;
	loadBalancerSourceRanges: any[];
	externalTrafficPolicy: string;
	annotations: CommonLabels;
	extraPorts: any[];
	labelSelectorsOverride: CommonLabels;
	additionalHeadless: boolean;
}
interface NodePorts {
	http: string;
}
interface Ports {
	http: number;
}
interface Grpc {
	server: Server;
	client: Client;
}
interface Client {
	serverName: string;
	tls: Tls;
}
interface Server {
	tls: Tls;
}
interface Tls {
	enabled: boolean;
	autoGenerated: boolean;
	cert: string;
	key: string;
	ca: string;
	existingSecret: CommonLabels;
}
interface NodeAffinityPreset {
	type: string;
	key: string;
	values: any[];
}
interface LivenessProbe {
	enabled: boolean;
	initialDelaySeconds: number;
	timeoutSeconds: number;
	periodSeconds: number;
	successThreshold: number;
	failureThreshold: number;
}
interface Resources {
	limits: CommonLabels;
	requests: CommonLabels;
}
interface ContainerSecurityContext {
	enabled: boolean;
	runAsUser: number;
	runAsNonRoot: boolean;
	allowPrivilegeEscalation: boolean;
	readOnlyRootFilesystem: boolean;
}
interface PodSecurityContext {
	enabled: boolean;
	fsGroup: number;
}
interface UpdateStrategy {
	type: string;
}
interface DnsDiscovery {
	enabled: boolean;
	sidecarsService: string;
	sidecarsNamespace: string;
}
interface ServiceAccount {
	create: boolean;
	name: string;
	automountServiceAccountToken: boolean;
	annotations: CommonLabels;
}
interface Auth {
	basicAuthUsers: CommonLabels;
}
interface Https {
	enabled: boolean;
	autoGenerated: boolean;
	existingSecret: string;
	certFilename: string;
	keyFilename: string;
	caFilename: string;
	key: string;
	cert: string;
	ca: string;
	clientAuthType: string;
}
interface Image {
	registry: string;
	repository: string;
	tag: string;
	digest: string;
	pullPolicy: string;
	pullSecrets: any[];
}
interface CommonLabels {}
interface Global {
	imageRegistry: string;
	imagePullSecrets: any[];
	storageClass: string;
}

// Don't Edit. This is autogenerated.
export interface IRookCephClusterRookCeph {
    operatorNamespace: string;
    toolbox: Toolbox;
    monitoring: Monitoring;
    pspEnable: boolean;
    cephClusterSpec: CephClusterSpec;
    ingress: Ingress;
    cephBlockPools: CephBlockPool[];
    cephFileSystems: CephFileSystem[];
    cephFileSystemVolumeSnapshotClass: CephFileSystemVolumeSnapshotClass;
    cephBlockPoolsVolumeSnapshotClass: CephFileSystemVolumeSnapshotClass;
    cephObjectStores: CephObjectStore[];
}
interface CephObjectStore {
    name: string;
    spec: Spec3;
    storageClass: StorageClass3;
}
interface StorageClass3 {
    enabled: boolean;
    name: string;
    reclaimPolicy: string;
    parameters: Parameters3;
}
interface Parameters3 {
    region: string;
}
interface Spec3 {
    metadataPool: Spec;
    dataPool: DataPool2;
    preservePoolsOnDelete: boolean;
    gateway: Gateway;
    healthCheck: HealthCheck2;
}
interface HealthCheck2 {
    bucket: Bucket;
}
interface Bucket {
    interval: string;
}
interface Gateway {
    port: number;
    resources: Resources;
    instances: number;
    priorityClassName: string;
}
interface DataPool2 {
    failureDomain: string;
    erasureCoded: ErasureCoded;
}
interface ErasureCoded {
    dataChunks: number;
    codingChunks: number;
}
interface CephFileSystemVolumeSnapshotClass {
    enabled: boolean;
    name: string;
    isDefault: boolean;
    deletionPolicy: string;
    annotations: Affinity;
    labels: Affinity;
    parameters: Affinity;
}
interface CephFileSystem {
    name: string;
    spec: Spec2;
    storageClass: StorageClass2;
}
interface StorageClass2 {
    enabled: boolean;
    isDefault: boolean;
    name: string;
    pool: string;
    reclaimPolicy: string;
    allowVolumeExpansion: boolean;
    mountOptions: any[];
    parameters: Parameters2;
}
interface Parameters2 {
    'csi.storage.k8s.io/provisioner-secret-name': string;
    'csi.storage.k8s.io/provisioner-secret-namespace': string;
    'csi.storage.k8s.io/controller-expand-secret-name': string;
    'csi.storage.k8s.io/controller-expand-secret-namespace': string;
    'csi.storage.k8s.io/node-stage-secret-name': string;
    'csi.storage.k8s.io/node-stage-secret-namespace': string;
    'csi.storage.k8s.io/fstype': string;
}
interface Spec2 {
    metadataPool: MetadataPool;
    dataPools: DataPool[];
    metadataServer: MetadataServer;
}
interface MetadataServer {
    activeCount: number;
    activeStandby: boolean;
    resources: Resources;
    priorityClassName: string;
}
interface DataPool {
    failureDomain: string;
    replicated: Replicated;
    name: string;
}
interface MetadataPool {
    replicated: Replicated;
}
interface CephBlockPool {
    name: string;
    spec: Spec;
    storageClass: StorageClass;
}
interface StorageClass {
    enabled: boolean;
    name: string;
    isDefault: boolean;
    reclaimPolicy: string;
    allowVolumeExpansion: boolean;
    mountOptions: any[];
    parameters: Parameters;
}
interface Parameters {
    imageFormat: string;
    imageFeatures: string;
    'csi.storage.k8s.io/provisioner-secret-name': string;
    'csi.storage.k8s.io/provisioner-secret-namespace': string;
    'csi.storage.k8s.io/controller-expand-secret-name': string;
    'csi.storage.k8s.io/controller-expand-secret-namespace': string;
    'csi.storage.k8s.io/node-stage-secret-name': string;
    'csi.storage.k8s.io/node-stage-secret-namespace': string;
    'csi.storage.k8s.io/fstype': string;
}
interface Spec {
    failureDomain: string;
    replicated: Replicated;
}
interface Replicated {
    size: number;
}
interface Ingress {
    dashboard: Affinity;
}
interface CephClusterSpec {
    cephVersion: CephVersion;
    dataDirHostPath: string;
    skipUpgradeChecks: boolean;
    continueUpgradeAfterChecksEvenIfNotHealthy: boolean;
    waitTimeoutForHealthyOSDInMinutes: number;
    mon: Mon;
    mgr: Mgr;
    dashboard: Dashboard;
    crashCollector: CrashCollector;
    cleanupPolicy: CleanupPolicy;
    resources: Resources2;
    removeOSDsIfOutAndSafeToRemove: boolean;
    priorityClassNames: PriorityClassNames;
    storage: Storage;
    disruptionManagement: DisruptionManagement;
    healthCheck: HealthCheck;
}
interface HealthCheck {
    daemonHealth: DaemonHealth;
    livenessProbe: LivenessProbe;
}
interface LivenessProbe {
    mon: Mon3;
    mgr: Mon3;
    osd: Mon3;
}
interface Mon3 {
    disabled: boolean;
}
interface DaemonHealth {
    mon: Mon2;
    osd: Mon2;
    status: Mon2;
}
interface Mon2 {
    disabled: boolean;
    interval: string;
}
interface DisruptionManagement {
    managePodBudgets: boolean;
    osdMaintenanceTimeout: number;
    pgHealthCheckTimeout: number;
    manageMachineDisruptionBudgets: boolean;
    machineDisruptionBudgetNamespace: string;
}
interface Storage {
    useAllNodes: boolean;
    useAllDevices: boolean;
}
interface PriorityClassNames {
    mon: string;
    osd: string;
    mgr: string;
}
interface Resources2 {
    mgr: Resources;
    mon: Resources;
    osd: Resources;
    prepareosd: Prepareosd;
    'mgr-sidecar': Resources;
    crashcollector: Resources;
    logcollector: Resources;
    cleanup: Resources;
}
interface Prepareosd {
    requests: Limits;
}
interface CleanupPolicy {
    confirmation: string;
    sanitizeDisks: SanitizeDisks;
    allowUninstallWithVolumes: boolean;
}
interface SanitizeDisks {
    method: string;
    dataSource: string;
    iteration: number;
}
interface CrashCollector {
    disable: boolean;
}
interface Dashboard {
    enabled: boolean;
    ssl: boolean;
}
interface Mgr {
    count: number;
    allowMultiplePerNode: boolean;
    modules: Module[];
}
interface Module {
    name: string;
    enabled: boolean;
}
interface Mon {
    count: number;
    allowMultiplePerNode: boolean;
}
interface CephVersion {
    image: string;
    allowUnsupported: boolean;
}
interface Monitoring {
    enabled: boolean;
    createPrometheusRules: boolean;
    rulesNamespaceOverride?: any;
    prometheusRule: PrometheusRule;
}
interface PrometheusRule {
    labels: Affinity;
    annotations: Affinity;
}
interface Toolbox {
    enabled: boolean;
    image: string;
    tolerations: any[];
    affinity: Affinity;
    resources: Resources;
}
interface Resources {
    limits: Limits;
    requests: Limits;
}
interface Limits {
    cpu: string;
    memory: string;
}
interface Affinity {}

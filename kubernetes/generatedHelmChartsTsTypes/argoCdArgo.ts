// Don't Edit. This is autogenerated.
export interface IArgocdargo {
    nameOverride: string;
    fullnameOverride: string;
    kubeVersionOverride: string;
    apiVersionOverrides: ApiVersionOverrides;
    createAggregateRoles: boolean;
    openshift: Openshift;
    crds: Crds;
    global: Global;
    configs: Configs;
    extraObjects: any[];
    controller: Controller;
    dex: Dex;
    redis: Redis;
    'redis-ha': Redisha;
    externalRedis: ExternalRedis;
    server: Server;
    repoServer: RepoServer;
    applicationSet: ApplicationSet;
    notifications: Notifications;
}
interface Notifications {
    enabled: boolean;
    name: string;
    affinity: Annotations;
    argocdUrl?: any;
    image: Image;
    imagePullSecrets: any[];
    nodeSelector: Annotations;
    updateStrategy: UpdateStrategy;
    context: Annotations;
    secret: Secret2;
    logFormat: string;
    logLevel: string;
    extraArgs: any[];
    extraEnv: any[];
    extraEnvFrom: any[];
    extraVolumeMounts: any[];
    extraVolumes: any[];
    metrics: Metrics5;
    notifiers: Annotations;
    podAnnotations: Annotations;
    podLabels: Annotations;
    securityContext: SecurityContext2;
    containerSecurityContext: Annotations;
    priorityClassName: string;
    resources: Annotations;
    serviceAccount: ServiceAccount4;
    cm: Cm;
    subscriptions: any[];
    templates: Annotations;
    tolerations: any[];
    triggers: Annotations;
    bots: Bots;
}
interface Bots {
    slack: Slack;
}
interface Slack {
    enabled: boolean;
    updateStrategy: UpdateStrategy;
    image: Image;
    imagePullSecrets: any[];
    service: Service7;
    serviceAccount: ServiceAccount4;
    securityContext: SecurityContext2;
    containerSecurityContext: Annotations;
    resources: Annotations;
    affinity: Annotations;
    tolerations: any[];
    nodeSelector: Annotations;
}
interface Service7 {
    annotations: Annotations;
    port: number;
    type: string;
}
interface Cm {
    create: boolean;
}
interface ServiceAccount4 {
    create: boolean;
    name: string;
    annotations: Annotations;
}
interface SecurityContext2 {
    runAsNonRoot: boolean;
}
interface Metrics5 {
    enabled: boolean;
    port: number;
    service: Service3;
    serviceMonitor: ServiceMonitor2;
}
interface ServiceMonitor2 {
    enabled: boolean;
    selector: Annotations;
    additionalLabels: Annotations;
    scheme: string;
    tlsConfig: Annotations;
}
interface Secret2 {
    create: boolean;
    annotations: Annotations;
    items: Annotations;
}
interface UpdateStrategy {
    type: string;
}
interface ApplicationSet {
    enabled: boolean;
    name: string;
    replicaCount: number;
    image: Image;
    args: Args;
    logFormat: string;
    logLevel: string;
    extraContainers: any[];
    metrics: Metrics4;
    imagePullSecrets: any[];
    service: Service;
    serviceAccount: ServiceAccount3;
    podAnnotations: Annotations;
    podLabels: Annotations;
    podSecurityContext: Annotations;
    securityContext: Annotations;
    resources: Annotations;
    nodeSelector: Annotations;
    tolerations: any[];
    affinity: Annotations;
    priorityClassName: string;
    extraVolumeMounts: any[];
    extraVolumes: any[];
    extraArgs: any[];
    extraEnv: any[];
    extraEnvFrom: any[];
    webhook: Webhook;
}
interface Webhook {
    ingress: Ingress2;
}
interface Ingress2 {
    enabled: boolean;
    annotations: Annotations;
    labels: Annotations;
    ingressClassName: string;
    hosts: any[];
    paths: string[];
    pathType: string;
    extraPaths: any[];
    tls: any[];
}
interface ServiceAccount3 {
    create: boolean;
    annotations: Annotations;
    labels: Annotations;
    name: string;
}
interface Args {
    metricsAddr: string;
    probeBindAddr: string;
    enableLeaderElection: boolean;
    policy: string;
    debug: boolean;
    dryRun: boolean;
}
interface RepoServer {
    name: string;
    replicas: number;
    autoscaling: Autoscaling;
    image: Image;
    extraArgs: any[];
    env: any[];
    envFrom: any[];
    podAnnotations: Annotations;
    podLabels: Annotations;
    containerPort: number;
    readinessProbe: ReadinessProbe;
    livenessProbe: ReadinessProbe;
    volumeMounts: any[];
    volumes: any[];
    nodeSelector: Annotations;
    tolerations: any[];
    affinity: Annotations;
    topologySpreadConstraints: any[];
    priorityClassName: string;
    containerSecurityContext: Annotations;
    resources: Annotations;
    service: Service;
    metrics: Metrics4;
    clusterAdminAccess: Openshift;
    clusterRoleRules: ClusterRoleRules;
    serviceAccount: ServiceAccount2;
    extraContainers: any[];
    rbac: any[];
    copyutil: Copyutil;
    initContainers: any[];
    pdb: Pdb;
    imagePullSecrets: any[];
}
interface Copyutil {
    resources: Annotations;
}
interface Server {
    name: string;
    replicas: number;
    autoscaling: Autoscaling;
    image: Image;
    extraArgs: any[];
    env: any[];
    envFrom: any[];
    lifecycle: Annotations;
    podAnnotations: Annotations;
    podLabels: Annotations;
    containerPort: number;
    readinessProbe: ReadinessProbe;
    livenessProbe: ReadinessProbe;
    volumeMounts: any[];
    volumes: any[];
    nodeSelector: Annotations;
    tolerations: any[];
    affinity: Annotations;
    topologySpreadConstraints: any[];
    priorityClassName: string;
    containerSecurityContext: Annotations;
    resources: Annotations;
    certificate: Certificate;
    service: Service6;
    metrics: Metrics4;
    serviceAccount: ServiceAccount;
    ingress: Ingress;
    ingressGrpc: IngressGrpc;
    route: Route;
    configEnabled: boolean;
    config: Config2;
    configAnnotations: Annotations;
    rbacConfig: Annotations;
    rbacConfigAnnotations: Annotations;
    rbacConfigCreate: boolean;
    clusterAdminAccess: Openshift;
    GKEbackendConfig: GKEbackendConfig;
    GKEmanagedCertificate: GKEmanagedCertificate;
    GKEfrontendConfig: GKEbackendConfig;
    extraContainers: any[];
    initContainers: any[];
    extensions: Extensions;
    pdb: Pdb;
    imagePullSecrets: any[];
}
interface Extensions {
    enabled: boolean;
    image: Image;
    resources: Annotations;
    contents: any[];
}
interface GKEmanagedCertificate {
    enabled: boolean;
    domains: string[];
}
interface GKEbackendConfig {
    enabled: boolean;
    spec: Annotations;
}
interface Config2 {
    url: string;
    'application.instanceLabelKey': string;
    'server.rbac.log.enforce.enable': string;
    'exec.enabled': string;
    'admin.enabled': string;
}
interface Route {
    enabled: boolean;
    annotations: Annotations;
    hostname: string;
    termination_type: string;
    termination_policy: string;
}
interface IngressGrpc {
    enabled: boolean;
    isAWSALB: boolean;
    annotations: Annotations;
    labels: Annotations;
    ingressClassName: string;
    awsALB: AwsALB;
    hosts: any[];
    paths: string[];
    pathType: string;
    extraPaths: any[];
    tls: any[];
    https: boolean;
}
interface AwsALB {
    serviceType: string;
    backendProtocolVersion: string;
}
interface Ingress {
    enabled: boolean;
    annotations: Annotations;
    labels: Annotations;
    ingressClassName: string;
    hosts: any[];
    paths: string[];
    pathType: string;
    extraPaths: any[];
    tls: any[];
    https: boolean;
}
interface Metrics4 {
    enabled: boolean;
    service: Service2;
    serviceMonitor: ServiceMonitor;
}
interface Service6 {
    annotations: Annotations;
    labels: Annotations;
    type: string;
    nodePortHttp: number;
    nodePortHttps: number;
    servicePortHttp: number;
    servicePortHttps: number;
    servicePortHttpName: string;
    servicePortHttpsName: string;
    namedTargetPort: boolean;
    loadBalancerIP: string;
    loadBalancerSourceRanges: any[];
    externalIPs: any[];
    externalTrafficPolicy: string;
    sessionAffinity: string;
}
interface Certificate {
    enabled: boolean;
    domain: string;
    duration: string;
    renewBefore: string;
    privateKey: PrivateKey;
    issuer: Issuer;
    additionalHosts: any[];
    secretName: string;
}
interface Issuer {
    group: string;
    kind: string;
    name: string;
}
interface PrivateKey {
    rotationPolicy: string;
    encoding: string;
    algorithm: string;
    size: number;
}
interface Autoscaling {
    enabled: boolean;
    minReplicas: number;
    maxReplicas: number;
    targetCPUUtilizationPercentage: number;
    targetMemoryUtilizationPercentage: number;
    behavior: Annotations;
}
interface ExternalRedis {
    host: string;
    username: string;
    password: string;
    port: number;
    existingSecret: string;
    secretAnnotations: Annotations;
}
interface Redisha {
    enabled: boolean;
    exporter: Openshift;
    persistentVolume: Openshift;
    redis: Redis2;
    haproxy: Haproxy;
    image: Image2;
    topologySpreadConstraints: TopologySpreadConstraints;
}
interface TopologySpreadConstraints {
    enabled: boolean;
    maxSkew: string;
    topologyKey: string;
    whenUnsatisfiable: string;
}
interface Image2 {
    tag: string;
}
interface Haproxy {
    enabled: boolean;
    metrics: Openshift;
}
interface Redis2 {
    masterGroupName: string;
    config: Config;
}
interface Config {
    save: string;
}
interface Redis {
    enabled: boolean;
    name: string;
    image: Image;
    extraArgs: any[];
    containerPort: number;
    servicePort: number;
    env: any[];
    envFrom: any[];
    podAnnotations: Annotations;
    podLabels: Annotations;
    nodeSelector: Annotations;
    tolerations: any[];
    affinity: Annotations;
    topologySpreadConstraints: any[];
    priorityClassName: string;
    containerSecurityContext: Annotations;
    securityContext: SecurityContext;
    serviceAccount: ServiceAccount2;
    resources: Annotations;
    volumeMounts: any[];
    volumes: any[];
    extraContainers: any[];
    initContainers: any[];
    service: Service4;
    metrics: Metrics3;
    pdb: Pdb;
    imagePullSecrets: any[];
}
interface Metrics3 {
    enabled: boolean;
    image: Image;
    containerPort: number;
    resources: Annotations;
    service: Service5;
    serviceMonitor: ServiceMonitor;
}
interface Service5 {
    type: string;
    clusterIP: string;
    annotations: Annotations;
    labels: Annotations;
    servicePort: number;
    portName: string;
}
interface Service4 {
    annotations: Annotations;
    labels: Annotations;
}
interface SecurityContext {
    runAsNonRoot: boolean;
    runAsUser: number;
}
interface Dex {
    enabled: boolean;
    name: string;
    extraArgs: any[];
    metrics: Metrics2;
    image: Image;
    initImage: Image;
    env: any[];
    envFrom: any[];
    podAnnotations: Annotations;
    podLabels: Annotations;
    livenessProbe: LivenessProbe;
    readinessProbe: LivenessProbe;
    serviceAccount: ServiceAccount2;
    volumeMounts: any[];
    volumes: any[];
    containerPortHttp: number;
    servicePortHttp: number;
    servicePortHttpName: string;
    containerPortGrpc: number;
    servicePortGrpc: number;
    servicePortGrpcName: string;
    containerPortMetrics: number;
    servicePortMetrics: number;
    nodeSelector: Annotations;
    tolerations: any[];
    affinity: Annotations;
    topologySpreadConstraints: any[];
    priorityClassName: string;
    containerSecurityContext: Annotations;
    resources: Annotations;
    extraContainers: any[];
    initContainers: any[];
    pdb: Pdb;
    imagePullSecrets: any[];
}
interface ServiceAccount2 {
    create: boolean;
    name: string;
    annotations: Annotations;
    automountServiceAccountToken: boolean;
}
interface LivenessProbe {
    enabled: boolean;
    failureThreshold: number;
    initialDelaySeconds: number;
    periodSeconds: number;
    successThreshold: number;
    timeoutSeconds: number;
}
interface Metrics2 {
    enabled: boolean;
    service: Service3;
    serviceMonitor: ServiceMonitor;
}
interface Service3 {
    annotations: Annotations;
    labels: Annotations;
    portName: string;
}
interface Controller {
    name: string;
    image: Image;
    replicas: number;
    args: Annotations;
    extraArgs: any[];
    env: any[];
    envFrom: any[];
    podAnnotations: Annotations;
    podLabels: Annotations;
    containerSecurityContext: Annotations;
    containerPort: number;
    readinessProbe: ReadinessProbe;
    livenessProbe: ReadinessProbe;
    volumeMounts: any[];
    volumes: any[];
    service: Service;
    nodeSelector: Annotations;
    tolerations: any[];
    affinity: Annotations;
    topologySpreadConstraints: any[];
    priorityClassName: string;
    resources: Annotations;
    serviceAccount: ServiceAccount;
    metrics: Metrics;
    clusterAdminAccess: Openshift;
    clusterRoleRules: ClusterRoleRules;
    extraContainers: any[];
    initContainers: any[];
    pdb: Pdb;
    imagePullSecrets: any[];
}
interface Pdb {
    labels: Annotations;
    annotations: Annotations;
    enabled: boolean;
}
interface ClusterRoleRules {
    enabled: boolean;
    rules: any[];
}
interface Metrics {
    enabled: boolean;
    applicationLabels: ApplicationLabels;
    service: Service2;
    serviceMonitor: ServiceMonitor;
    rules: Rules;
}
interface Rules {
    enabled: boolean;
    spec: any[];
}
interface ServiceMonitor {
    enabled: boolean;
    interval: string;
    relabelings: any[];
    metricRelabelings: any[];
    selector: Annotations;
    scheme: string;
    tlsConfig: Annotations;
    namespace: string;
    additionalLabels: Annotations;
}
interface Service2 {
    annotations: Annotations;
    labels: Annotations;
    servicePort: number;
    portName: string;
}
interface ApplicationLabels {
    enabled: boolean;
    labels: any[];
}
interface ServiceAccount {
    create: boolean;
    name: string;
    annotations: Annotations;
    labels: Annotations;
    automountServiceAccountToken: boolean;
}
interface Service {
    annotations: Annotations;
    labels: Annotations;
    port: number;
    portName: string;
}
interface ReadinessProbe {
    failureThreshold: number;
    initialDelaySeconds: number;
    periodSeconds: number;
    successThreshold: number;
    timeoutSeconds: number;
}
interface Configs {
    clusterCredentials: any[];
    gpgKeysAnnotations: Annotations;
    gpgKeys: Annotations;
    knownHostsAnnotations: Annotations;
    knownHosts: KnownHosts;
    tlsCertsAnnotations: Annotations;
    tlsCerts: Annotations;
    credentialTemplates: Annotations;
    credentialTemplatesAnnotations: Annotations;
    repositories: Annotations;
    repositoriesAnnotations: Annotations;
    secret: Secret;
    styles: string;
    params: Params;
}
interface Params {
    annotations: Annotations;
    'otlp.address': string;
    'timeout.reconciliation': number;
    'timeout.hard.reconciliation': number;
    'controller.status.processors': number;
    'controller.operation.processors': number;
    'controller.self.heal.timeout.seconds': number;
    'controller.repo.server.timeout.seconds': number;
    'server.insecure': boolean;
    'server.basehref': string;
    'server.rootpath': string;
    'server.staticassets': string;
    'server.disable.auth': boolean;
    'server.enable.gzip': boolean;
    'server.x.frame.options': string;
    'reposerver.parallelism.limit': number;
}
interface Secret {
    createSecret: boolean;
    annotations: Annotations;
    githubSecret: string;
    gitlabSecret: string;
    bitbucketServerSecret: string;
    bitbucketUUID: string;
    gogsSecret: string;
    extra: Annotations;
    argocdServerTlsConfig: Annotations;
    argocdServerAdminPassword: string;
    argocdServerAdminPasswordMtime: string;
}
interface KnownHosts {
    data: Data;
}
interface Data {
    ssh_known_hosts: string;
}
interface Global {
    image: Image;
    logging: Logging;
    podAnnotations: Annotations;
    podLabels: Annotations;
    securityContext: Annotations;
    imagePullSecrets: any[];
    hostAliases: any[];
    additionalLabels: Annotations;
    networkPolicy: NetworkPolicy;
}
interface NetworkPolicy {
    create: boolean;
    defaultDenyIngress: boolean;
}
interface Logging {
    format: string;
    level: string;
}
interface Image {
    repository: string;
    tag: string;
    imagePullPolicy: string;
}
interface Crds {
    install: boolean;
    keep: boolean;
    annotations: Annotations;
}
interface Annotations {}
interface Openshift {
    enabled: boolean;
}
interface ApiVersionOverrides {
    certmanager: string;
    ingress: string;
    autoscaling: string;
}

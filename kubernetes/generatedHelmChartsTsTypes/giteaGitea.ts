// Don't Edit. This is autogenerated.
export interface IGiteaGitea {
    global: Global;
    replicaCount: number;
    clusterDomain: string;
    image: Image;
    imagePullSecrets: any[];
    podSecurityContext: PodSecurityContext;
    containerSecurityContext: ContainerSecurityContext;
    securityContext: ContainerSecurityContext;
    service: Service;
    ingress: Ingress;
    resources: ContainerSecurityContext;
    schedulerName: string;
    nodeSelector: ContainerSecurityContext;
    tolerations: any[];
    affinity: ContainerSecurityContext;
    dnsConfig: ContainerSecurityContext;
    statefulset: Statefulset;
    persistence: Persistence;
    extraVolumes: any[];
    extraContainerVolumeMounts: any[];
    extraInitVolumeMounts: any[];
    extraVolumeMounts: any[];
    initPreScript: string;
    signing: Signing;
    gitea: Gitea;
    memcached: Memcached;
    postgresql: Postgresql2;
    mysql: Mysql;
    mariadb: Mariadb;
    checkDeprecation: boolean;
}
interface Mariadb {
    enabled: boolean;
    auth: Auth;
    primary: Primary;
}
interface Primary {
    service: Service2;
    persistence: Persistence2;
}
interface Auth {
    database: string;
    username: string;
    password: string;
    rootPassword: string;
}
interface Mysql {
    enabled: boolean;
    root: Root;
    db: Db;
    service: Service2;
    persistence: Persistence2;
}
interface Db {
    user: string;
    password: string;
    name: string;
}
interface Root {
    password: string;
}
interface Postgresql2 {
    enabled: boolean;
    global: Global2;
    persistence: Persistence2;
}
interface Persistence2 {
    size: string;
}
interface Global2 {
    postgresql: Postgresql;
}
interface Postgresql {
    postgresqlDatabase: string;
    postgresqlUsername: string;
    postgresqlPassword: string;
    servicePort: number;
}
interface Memcached {
    enabled: boolean;
    service: Service2;
}
interface Service2 {
    port: number;
}
interface Gitea {
    admin: Admin;
    metrics: Metrics;
    ldap: any[];
    oauth: any[];
    config: ContainerSecurityContext;
    additionalConfigSources: any[];
    additionalConfigFromEnvs: any[];
    podAnnotations: ContainerSecurityContext;
    livenessProbe: LivenessProbe;
    readinessProbe: LivenessProbe;
    startupProbe: LivenessProbe;
}
interface LivenessProbe {
    enabled: boolean;
    tcpSocket: TcpSocket;
    initialDelaySeconds: number;
    timeoutSeconds: number;
    periodSeconds: number;
    successThreshold: number;
    failureThreshold: number;
}
interface TcpSocket {
    port: string;
}
interface Metrics {
    enabled: boolean;
    serviceMonitor: ServiceMonitor;
}
interface ServiceMonitor {
    enabled: boolean;
}
interface Admin {
    existingSecret?: any;
    username: string;
    password: string;
    email: string;
}
interface Signing {
    enabled: boolean;
    gpgHome: string;
    privateKey: string;
    existingSecret: string;
}
interface Persistence {
    enabled: boolean;
    existingClaim?: any;
    size: string;
    accessModes: string[];
    labels: ContainerSecurityContext;
    annotations: ContainerSecurityContext;
    storageClass?: any;
    subPath?: any;
}
interface Statefulset {
    env: any[];
    terminationGracePeriodSeconds: number;
    labels: ContainerSecurityContext;
    annotations: ContainerSecurityContext;
}
interface Ingress {
    enabled: boolean;
    className?: any;
    annotations: ContainerSecurityContext;
    hosts: Host[];
    tls: any[];
}
interface Host {
    host: string;
    paths: Path[];
}
interface Path {
    path: string;
    pathType: string;
}
interface Service {
    http: Http;
    ssh: Ssh;
}
interface Ssh {
    type: string;
    port: number;
    clusterIP: string;
    loadBalancerIP?: any;
    nodePort?: any;
    externalTrafficPolicy?: any;
    externalIPs?: any;
    ipFamilyPolicy?: any;
    ipFamilies?: any;
    hostPort?: any;
    loadBalancerSourceRanges: any[];
    annotations: ContainerSecurityContext;
}
interface Http {
    type: string;
    port: number;
    clusterIP: string;
    loadBalancerIP?: any;
    nodePort?: any;
    externalTrafficPolicy?: any;
    externalIPs?: any;
    ipFamilyPolicy?: any;
    ipFamilies?: any;
    loadBalancerSourceRanges: any[];
    annotations: ContainerSecurityContext;
}
interface ContainerSecurityContext {}
interface PodSecurityContext {
    fsGroup: number;
}
interface Image {
    registry: string;
    repository: string;
    tag: string;
    pullPolicy: string;
    rootless: boolean;
}
interface Global {
    imageRegistry: string;
    imagePullSecrets: any[];
    storageClass: string;
}

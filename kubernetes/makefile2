install:
	npm i

# Used as base function for other generator functions for various environments
MANIFESTS_BASE_DIR=./manifests # Path where pulumi generates manifests for each environment <local, development, staging, production>
ENVIRONMENT_MANIFESTS_DIR=${MANIFESTS_BASE_DIR}/generated/$(environement) # Path where pulumi generates manifests for each environment <local, development, staging, production>
ENVIRONMENT_SEALED_SECRETS_MANIFESTS_DIR=${MANIFESTS_BASE_DIR}/sealed-secrets/$(environement) # Path where pulumi generates manifests for each environment <local, development, staging, production>
manifests_generator:
	make install
	rm -rf ./login
	mkdir ./login
	pulumi login file://login 

	export PULUMI_CONFIG_PASSPHRASE="" && pulumi stack init --stack dev
	
	# Set environment variables for pulumi and applications for yaml files generation
	export PULUMI_CONFIG_PASSPHRASE="" && \
	export IMAGE_TAG_REACT_WEB="$(tag)" && \
	export IMAGE_TAG_GRAPHQL_MONGO="$(tag)" && \
	export IMAGE_TAG_GRPC_MONGO="$(tag)" && \
	export IMAGE_TAG_GRAPHQL_POSTGRES="$(tag)" && \
	export ENVIRONMENT="$(environment)" && \
	pulumi update --yes --skip-preview --stack dev

	# Remove plain secret and/or Generate sealed secrets
	@if [ $(generate_sealed_secrets) ]; then \
		echo "Hello world"; \
		kubectl apply -R -f ${ENVIRONMENT_MANIFESTS_DIR}/namespaces; \
		\
		# Apply setups with sealed secret controller; \
		kubectl apply -R -f  ${ENVIRONMENT_MANIFESTS_DIR}/cluster-setup; \
		\
		# Wait for bitnami sealed secrets controller to be in running phase so that we can use it to encrypt secrets; \
		kubectl rollout status deployment/sealed-secrets-controller -n=kube-system; \
		\
		mkdir -p ${ENVIRONMENT_SEALED_SECRETS_MANIFESTS_DIR};\
	fi
	


	@for FILE in ${ENVIRONMENT_SEALED_SECRETS_MANIFESTS_DIR}/**/**/secret-*ml; do \
		@if [ $(generate_sealed_secrets) ]; then \
			kubeseal <$${FILE} -o yaml >${SECRETS_ENCRYPTED_DIR}/$${FILE##*/}; \
		fi \
		\
		echo "Removing unsealed plain secret manifest $${FILE}"; \
		rm -rf $${FILE}; \
	done


# Used as base function for other generator functions for various environments
MANIFESTS_BASE_DIR=./manifests # Path where pulumi generates manifests for each environment <local, development, staging, production>
ENVIRONMENT_MANIFESTS_DIR=${MANIFESTS_BASE_DIR}/generated/$(environement) # Path where pulumi generates manifests for each environment <local, development, staging, production>
ENVIRONMENT_SEALED_SECRETS_MANIFESTS_DIR=${MANIFESTS_BASE_DIR}/sealed-secrets/$(environement) # Path where pulumi generates manifests for each environment <local, development, staging, production>
manifests_generator:
	# make install
	# rm -rf ./login
	# mkdir ./login
	# pulumi login file://login 

	# export PULUMI_CONFIG_PASSPHRASE="" && pulumi stack init --stack dev
	
	# # Set environment variables for pulumi and applications for yaml files generation
	# export PULUMI_CONFIG_PASSPHRASE="" && \
	# export IMAGE_TAG_REACT_WEB="$(tag)" && \
	# export IMAGE_TAG_GRAPHQL_MONGO="$(tag)" && \
	# export IMAGE_TAG_GRPC_MONGO="$(tag)" && \
	# export IMAGE_TAG_GRAPHQL_POSTGRES="$(tag)" && \
	# export ENVIRONMENT="$(environment)" && \
	# pulumi update --yes --skip-preview --stack dev

	echo "Remove plain secret and/or Generate sealed secrets"
	@if [ $(generate_sealed_secrets) ]; then \
		echo "Hello world"; \
		kubectl apply -R -f ${ENVIRONMENT_MANIFESTS_DIR}/namespaces; \
		\
		echo "Apply setups with sealed secret controller"; \
		kubectl apply -R -f  ${ENVIRONMENT_MANIFESTS_DIR}/cluster-setup; \
		\
		echo "Wait for bitnami sealed secrets controller to be in running phase so that we can use it to encrypt secrets"; \
		kubectl rollout status deployment/sealed-secrets-controller -n=kube-system; \
		\
		mkdir -p ${ENVIRONMENT_SEALED_SECRETS_MANIFESTS_DIR};\
	fi
	

	@for FILE in ${ENVIRONMENT_SEALED_SECRETS_MANIFESTS_DIR}/**/**/secret-*ml; do \
		@if [ $(generate_sealed_secrets) ]; then \
			kubeseal <$${FILE} -o yaml >${SECRETS_ENCRYPTED_DIR}/$${FILE##*/}; \
		fi \
		\
		echo "Removing unsealed plain secret manifest $${FILE}"; \
		rm -rf $${FILE}; \
	done



# @if [ "test" = "test" ]; then \
# 	echo "Hello world"; \
# 	kubectl apply -R -f ${ENVIRONMENT_MANIFESTS_DIR}/namespaces; \
# 	\
# 	echo "Apply setups with sealed secret controller"; \
# 	kubectl apply -R -f  ${ENVIRONMENT_MANIFESTS_DIR}/cluster-setup; \
# 	\
# 	echo "Wait for bitnami sealed secrets controller to be in running phase so that we can use it to encrypt secrets"; \
# 	kubectl rollout status deployment/sealed-secrets-controller -n=kube-system; \
# 	\
# 	mkdir -p ${ENVIRONMENT_SEALED_SECRETS_MANIFESTS_DIR};\
# fi
# make manifests_local tag=local
manifests_local:
	make manifests_generator tag=local environment=local

# make manifests_development tag=github-sha  
manifests_development:
	make manifests_generator tag=$(tag) environment=development

# make manifests_staging tag=github-sha  
manifests_staging:
	make manifests_generator tag=$(tag) environment=staging

# make manifests_production tag=github-sha  
manifests_production:
	make manifests_generator tag=$(tag) environment=production

# Example Usage:  make manifests_temporary tag=temporary
manifests_temporary:
	export TEMPORARY_DIR="temporary" && \
	make manifests_generator tag=$(tag) environment=local



clean:
	@if [ "test" = "test" ]; then\
		echo "Hello world";\
	fi

# Example usage: ENVIRONMENT="production" make seal
BASEDIR=./manifests/generated/$(environement)
# GENERATED_DIR=${BASEDIR}/temporary
# GENERATED_DIR=./manifests/generated/$(environement)
SECRETS_ENCRYPTED_DIR=${BASEDIR}/sealed-secrets
sealed_secrets:
	kubectl apply -R -f ${GENERATED_DIR}/namespaces
	kubectl apply -R -f  ${GENERATED_DIR}/cluster-setup  # Apply setups with sealed secret controller
	# Wait for bitnami sealed secrets controller to be in running phase so that we can use it to encrypt secrets
	kubectl rollout status deployment/sealed-secrets-controller -n=kube-system

	mkdir -p ${SECRETS_ENCRYPTED_DIR}

	@for FILE in ${GENERATED_DIR}/**/**/secret-*ml; do \
		kubeseal <$${FILE} -o yaml >${SECRETS_ENCRYPTED_DIR}/$${FILE##*/}; \
		echo "REMOVING unsealed secret $${FILE}"; \
		rm -rf $${FILE}; \
	done

	rm -rf ${GENERATED_DIR}
# rm -rf ./shared/secrets-dont-push.json

setup:
	cp -R secrets.environment.example secrets.production.json
	# Then edit the file

# setup-cluster-production:	
create-sealed-secrets:	
	make generate_temporary
	ENVIRONMENT=production make seal

	# kubectl apply -R -f  ./manifests/local/secrets-encrypted



# setup-cluster-production:	
create-sealed-secrets:	
	make generate_temporary
	ENVIRONMENT=production make seal

	# kubectl apply -R -f  ./manifests/local/secrets-encrypted

# Does the generation and encryption
rotate-secret-local:
	# Example  usage: make setup ENVIRONMENT=production
	# k3d cluster delete local
	# k3d cluster create local --port 8080:80@loadbalancer --port 8443:443@loadbalancer --k3s-arg "--no-deploy=traefik@server:*"
	
	make generate_production
	ENVIRONMENT=$(ENVIRONMENT) make seal

start-dev:
	k3d cluster delete local
	k3d cluster create local --port 8080:80@loadbalancer --port 8443:443@loadbalancer --k3s-arg "--no-deploy=traefik@server:*"
	
	make generate_local
	# ENVIRONMENT=$(ENVIRONMENT) make seal
	ENVIRONMENT=local make seal

	kubectl apply -R -f  ./manifests/local/secrets-encrypted
	skaffold dev --trigger="manual" --no-prune=true --no-prune-children=true



# TODO: Parameterise environment 
seal_production:
	export ENVIRONMENT=production && \
	k3d cluster delete local
	k3d cluster create local --port 8080:80@loadbalancer --port 8443:443@loadbalancer --k3s-arg "--no-deploy=traefik@server:*"
	make generate_production
	make rollout

	@for FILE in ${GENERATED_DIR}/**/**/secret-*ml; do \
		kubeseal <$${FILE} -o yaml >${SECRETS_ENCRYPTED_DIR}/$${FILE##*/}; \
		echo "REMOVING unsealed secret $${FILE}"; \
		rm -rf $${FILE}; \
	done

# @for FILE in ${BASEDIR}/argocd/1-manifest/secret-*ml; do \
# 	echo "sealing secret: $${FILE} into ./outputs directory"; \
# 	kubeseal <$${FILE} -o yaml >${BASEDIR}/secrets-encrypted/$${FILE##*/} --namespace applications; \
# 	\
# 	echo "REMOVING unsealed secret $${FILE}"; \
# 	rm -rf $${FILE}; \
# done


kk:
	@for FILE in ${BASEDIR}/**/**/secret-*ml; do \
		echo "sealing secret: $${FILE} into ./outputs directory"; \
	done

# kubeseal --scope cluster-wide <$${FILE} >./outputs/$${FILE##*/} --namespace applications; \
# Merge into an existing secret
# kubeseal --merge-into mysealedsecret.json


# seal:
# 	@for FILE in ./rendered/applications/1-manifest/secret-*ml; do \
# 		echo "sealing secret: $${FILE} into ./outputs directory"; \
# 		kubeseal <$${FILE} -o yaml > ./outputs/$${FILE##*/} --namespace applications; \
# 		echo "removing unsealed secret $${FILE}"; \
# 		rm -rf $${FILE};
# 	done
# 		# kubeseal --scope cluster-wide <$${FILE} >./outputs/$${FILE##*/} --namespace applications; \
# 		# Merge into an existing secret
# 		# kubeseal --merge-into mysealedsecret.json